"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bl";
exports.ids = ["vendor-chunks/bl"];
exports.modules = {

/***/ "(ssr)/./node_modules/bl/BufferList.js":
/*!***************************************!*\
  !*** ./node_modules/bl/BufferList.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst symbol = Symbol.for(\"BufferList\");\nfunction BufferList(buf) {\n    if (!(this instanceof BufferList)) {\n        return new BufferList(buf);\n    }\n    BufferList._init.call(this, buf);\n}\nBufferList._init = function _init(buf) {\n    Object.defineProperty(this, symbol, {\n        value: true\n    });\n    this._bufs = [];\n    this.length = 0;\n    if (buf) {\n        this.append(buf);\n    }\n};\nBufferList.prototype._new = function _new(buf) {\n    return new BufferList(buf);\n};\nBufferList.prototype._offset = function _offset(offset) {\n    if (offset === 0) {\n        return [\n            0,\n            0\n        ];\n    }\n    let tot = 0;\n    for(let i = 0; i < this._bufs.length; i++){\n        const _t = tot + this._bufs[i].length;\n        if (offset < _t || i === this._bufs.length - 1) {\n            return [\n                i,\n                offset - tot\n            ];\n        }\n        tot = _t;\n    }\n};\nBufferList.prototype._reverseOffset = function(blOffset) {\n    const bufferId = blOffset[0];\n    let offset = blOffset[1];\n    for(let i = 0; i < bufferId; i++){\n        offset += this._bufs[i].length;\n    }\n    return offset;\n};\nBufferList.prototype.get = function get(index) {\n    if (index > this.length || index < 0) {\n        return undefined;\n    }\n    const offset = this._offset(index);\n    return this._bufs[offset[0]][offset[1]];\n};\nBufferList.prototype.slice = function slice(start, end) {\n    if (typeof start === \"number\" && start < 0) {\n        start += this.length;\n    }\n    if (typeof end === \"number\" && end < 0) {\n        end += this.length;\n    }\n    return this.copy(null, 0, start, end);\n};\nBufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {\n    if (typeof srcStart !== \"number\" || srcStart < 0) {\n        srcStart = 0;\n    }\n    if (typeof srcEnd !== \"number\" || srcEnd > this.length) {\n        srcEnd = this.length;\n    }\n    if (srcStart >= this.length) {\n        return dst || Buffer.alloc(0);\n    }\n    if (srcEnd <= 0) {\n        return dst || Buffer.alloc(0);\n    }\n    const copy = !!dst;\n    const off = this._offset(srcStart);\n    const len = srcEnd - srcStart;\n    let bytes = len;\n    let bufoff = copy && dstStart || 0;\n    let start = off[1];\n    // copy/slice everything\n    if (srcStart === 0 && srcEnd === this.length) {\n        if (!copy) {\n            // slice, but full concat if multiple buffers\n            return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);\n        }\n        // copy, need to copy individual buffers\n        for(let i = 0; i < this._bufs.length; i++){\n            this._bufs[i].copy(dst, bufoff);\n            bufoff += this._bufs[i].length;\n        }\n        return dst;\n    }\n    // easy, cheap case where it's a subset of one of the buffers\n    if (bytes <= this._bufs[off[0]].length - start) {\n        return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);\n    }\n    if (!copy) {\n        // a slice, we need something to copy in to\n        dst = Buffer.allocUnsafe(len);\n    }\n    for(let i = off[0]; i < this._bufs.length; i++){\n        const l = this._bufs[i].length - start;\n        if (bytes > l) {\n            this._bufs[i].copy(dst, bufoff, start);\n            bufoff += l;\n        } else {\n            this._bufs[i].copy(dst, bufoff, start, start + bytes);\n            bufoff += l;\n            break;\n        }\n        bytes -= l;\n        if (start) {\n            start = 0;\n        }\n    }\n    // safeguard so that we don't return uninitialized memory\n    if (dst.length > bufoff) return dst.slice(0, bufoff);\n    return dst;\n};\nBufferList.prototype.shallowSlice = function shallowSlice(start, end) {\n    start = start || 0;\n    end = typeof end !== \"number\" ? this.length : end;\n    if (start < 0) {\n        start += this.length;\n    }\n    if (end < 0) {\n        end += this.length;\n    }\n    if (start === end) {\n        return this._new();\n    }\n    const startOffset = this._offset(start);\n    const endOffset = this._offset(end);\n    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);\n    if (endOffset[1] === 0) {\n        buffers.pop();\n    } else {\n        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);\n    }\n    if (startOffset[1] !== 0) {\n        buffers[0] = buffers[0].slice(startOffset[1]);\n    }\n    return this._new(buffers);\n};\nBufferList.prototype.toString = function toString(encoding, start, end) {\n    return this.slice(start, end).toString(encoding);\n};\nBufferList.prototype.consume = function consume(bytes) {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes);\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) return this;\n    while(this._bufs.length){\n        if (bytes >= this._bufs[0].length) {\n            bytes -= this._bufs[0].length;\n            this.length -= this._bufs[0].length;\n            this._bufs.shift();\n        } else {\n            this._bufs[0] = this._bufs[0].slice(bytes);\n            this.length -= bytes;\n            break;\n        }\n    }\n    return this;\n};\nBufferList.prototype.duplicate = function duplicate() {\n    const copy = this._new();\n    for(let i = 0; i < this._bufs.length; i++){\n        copy.append(this._bufs[i]);\n    }\n    return copy;\n};\nBufferList.prototype.append = function append(buf) {\n    if (buf == null) {\n        return this;\n    }\n    if (buf.buffer) {\n        // append a view of the underlying ArrayBuffer\n        this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));\n    } else if (Array.isArray(buf)) {\n        for(let i = 0; i < buf.length; i++){\n            this.append(buf[i]);\n        }\n    } else if (this._isBufferList(buf)) {\n        // unwrap argument into individual BufferLists\n        for(let i = 0; i < buf._bufs.length; i++){\n            this.append(buf._bufs[i]);\n        }\n    } else {\n        // coerce number arguments to strings, since Buffer(number) does\n        // uninitialized memory allocation\n        if (typeof buf === \"number\") {\n            buf = buf.toString();\n        }\n        this._appendBuffer(Buffer.from(buf));\n    }\n    return this;\n};\nBufferList.prototype._appendBuffer = function appendBuffer(buf) {\n    this._bufs.push(buf);\n    this.length += buf.length;\n};\nBufferList.prototype.indexOf = function(search, offset, encoding) {\n    if (encoding === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        offset = undefined;\n    }\n    if (typeof search === \"function\" || Array.isArray(search)) {\n        throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.');\n    } else if (typeof search === \"number\") {\n        search = Buffer.from([\n            search\n        ]);\n    } else if (typeof search === \"string\") {\n        search = Buffer.from(search, encoding);\n    } else if (this._isBufferList(search)) {\n        search = search.slice();\n    } else if (Array.isArray(search.buffer)) {\n        search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);\n    } else if (!Buffer.isBuffer(search)) {\n        search = Buffer.from(search);\n    }\n    offset = Number(offset || 0);\n    if (isNaN(offset)) {\n        offset = 0;\n    }\n    if (offset < 0) {\n        offset = this.length + offset;\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (search.length === 0) {\n        return offset > this.length ? this.length : offset;\n    }\n    const blOffset = this._offset(offset);\n    let blIndex = blOffset[0] // index of which internal buffer we're working on\n    ;\n    let buffOffset = blOffset[1] // offset of the internal buffer we're working on\n    ;\n    // scan over each buffer\n    for(; blIndex < this._bufs.length; blIndex++){\n        const buff = this._bufs[blIndex];\n        while(buffOffset < buff.length){\n            const availableWindow = buff.length - buffOffset;\n            if (availableWindow >= search.length) {\n                const nativeSearchResult = buff.indexOf(search, buffOffset);\n                if (nativeSearchResult !== -1) {\n                    return this._reverseOffset([\n                        blIndex,\n                        nativeSearchResult\n                    ]);\n                }\n                buffOffset = buff.length - search.length + 1 // end of native search window\n                ;\n            } else {\n                const revOffset = this._reverseOffset([\n                    blIndex,\n                    buffOffset\n                ]);\n                if (this._match(revOffset, search)) {\n                    return revOffset;\n                }\n                buffOffset++;\n            }\n        }\n        buffOffset = 0;\n    }\n    return -1;\n};\nBufferList.prototype._match = function(offset, search) {\n    if (this.length - offset < search.length) {\n        return false;\n    }\n    for(let searchOffset = 0; searchOffset < search.length; searchOffset++){\n        if (this.get(offset + searchOffset) !== search[searchOffset]) {\n            return false;\n        }\n    }\n    return true;\n};\n(function() {\n    const methods = {\n        readDoubleBE: 8,\n        readDoubleLE: 8,\n        readFloatBE: 4,\n        readFloatLE: 4,\n        readInt32BE: 4,\n        readInt32LE: 4,\n        readUInt32BE: 4,\n        readUInt32LE: 4,\n        readInt16BE: 2,\n        readInt16LE: 2,\n        readUInt16BE: 2,\n        readUInt16LE: 2,\n        readInt8: 1,\n        readUInt8: 1,\n        readIntBE: null,\n        readIntLE: null,\n        readUIntBE: null,\n        readUIntLE: null\n    };\n    for(const m in methods){\n        (function(m) {\n            if (methods[m] === null) {\n                BufferList.prototype[m] = function(offset, byteLength) {\n                    return this.slice(offset, offset + byteLength)[m](0, byteLength);\n                };\n            } else {\n                BufferList.prototype[m] = function(offset = 0) {\n                    return this.slice(offset, offset + methods[m])[m](0);\n                };\n            }\n        })(m);\n    }\n})();\n// Used internally by the class and also as an indicator of this object being\n// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser\n// environment because there could be multiple different copies of the\n// BufferList class and some `BufferList`s might be `BufferList`s.\nBufferList.prototype._isBufferList = function _isBufferList(b) {\n    return b instanceof BufferList || BufferList.isBufferList(b);\n};\nBufferList.isBufferList = function isBufferList(b) {\n    return b != null && b[symbol];\n};\nmodule.exports = BufferList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sR0FBR2xHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2QtdGltZXNoZWV0LWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2JsL0J1ZmZlckxpc3QuanM/NmQ4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKCdCdWZmZXJMaXN0JylcblxuZnVuY3Rpb24gQnVmZmVyTGlzdCAoYnVmKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXJMaXN0KSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyTGlzdChidWYpXG4gIH1cblxuICBCdWZmZXJMaXN0Ll9pbml0LmNhbGwodGhpcywgYnVmKVxufVxuXG5CdWZmZXJMaXN0Ll9pbml0ID0gZnVuY3Rpb24gX2luaXQgKGJ1Zikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc3ltYm9sLCB7IHZhbHVlOiB0cnVlIH0pXG5cbiAgdGhpcy5fYnVmcyA9IFtdXG4gIHRoaXMubGVuZ3RoID0gMFxuXG4gIGlmIChidWYpIHtcbiAgICB0aGlzLmFwcGVuZChidWYpXG4gIH1cbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX25ldyA9IGZ1bmN0aW9uIF9uZXcgKGJ1Zikge1xuICByZXR1cm4gbmV3IEJ1ZmZlckxpc3QoYnVmKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fb2Zmc2V0ID0gZnVuY3Rpb24gX29mZnNldCAob2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICByZXR1cm4gWzAsIDBdXG4gIH1cblxuICBsZXQgdG90ID0gMFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IF90ID0gdG90ICsgdGhpcy5fYnVmc1tpXS5sZW5ndGhcbiAgICBpZiAob2Zmc2V0IDwgX3QgfHwgaSA9PT0gdGhpcy5fYnVmcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gW2ksIG9mZnNldCAtIHRvdF1cbiAgICB9XG4gICAgdG90ID0gX3RcbiAgfVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fcmV2ZXJzZU9mZnNldCA9IGZ1bmN0aW9uIChibE9mZnNldCkge1xuICBjb25zdCBidWZmZXJJZCA9IGJsT2Zmc2V0WzBdXG4gIGxldCBvZmZzZXQgPSBibE9mZnNldFsxXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVySWQ7IGkrKykge1xuICAgIG9mZnNldCArPSB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG9mZnNldFxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4KSB7XG4gIGlmIChpbmRleCA+IHRoaXMubGVuZ3RoIHx8IGluZGV4IDwgMCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IG9mZnNldCA9IHRoaXMuX29mZnNldChpbmRleClcblxuICByZXR1cm4gdGhpcy5fYnVmc1tvZmZzZXRbMF1dW29mZnNldFsxXV1cbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJiBzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInICYmIGVuZCA8IDApIHtcbiAgICBlbmQgKz0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGlzLmNvcHkobnVsbCwgMCwgc3RhcnQsIGVuZClcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRzdCwgZHN0U3RhcnQsIHNyY1N0YXJ0LCBzcmNFbmQpIHtcbiAgaWYgKHR5cGVvZiBzcmNTdGFydCAhPT0gJ251bWJlcicgfHwgc3JjU3RhcnQgPCAwKSB7XG4gICAgc3JjU3RhcnQgPSAwXG4gIH1cblxuICBpZiAodHlwZW9mIHNyY0VuZCAhPT0gJ251bWJlcicgfHwgc3JjRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBzcmNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHNyY1N0YXJ0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGRzdCB8fCBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGlmIChzcmNFbmQgPD0gMCkge1xuICAgIHJldHVybiBkc3QgfHwgQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBjb25zdCBjb3B5ID0gISFkc3RcbiAgY29uc3Qgb2ZmID0gdGhpcy5fb2Zmc2V0KHNyY1N0YXJ0KVxuICBjb25zdCBsZW4gPSBzcmNFbmQgLSBzcmNTdGFydFxuICBsZXQgYnl0ZXMgPSBsZW5cbiAgbGV0IGJ1Zm9mZiA9IChjb3B5ICYmIGRzdFN0YXJ0KSB8fCAwXG4gIGxldCBzdGFydCA9IG9mZlsxXVxuXG4gIC8vIGNvcHkvc2xpY2UgZXZlcnl0aGluZ1xuICBpZiAoc3JjU3RhcnQgPT09IDAgJiYgc3JjRW5kID09PSB0aGlzLmxlbmd0aCkge1xuICAgIGlmICghY29weSkge1xuICAgICAgLy8gc2xpY2UsIGJ1dCBmdWxsIGNvbmNhdCBpZiBtdWx0aXBsZSBidWZmZXJzXG4gICAgICByZXR1cm4gdGhpcy5fYnVmcy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB0aGlzLl9idWZzWzBdXG4gICAgICAgIDogQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZzLCB0aGlzLmxlbmd0aClcbiAgICB9XG5cbiAgICAvLyBjb3B5LCBuZWVkIHRvIGNvcHkgaW5kaXZpZHVhbCBidWZmZXJzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYpXG4gICAgICBidWZvZmYgKz0gdGhpcy5fYnVmc1tpXS5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gZHN0XG4gIH1cblxuICAvLyBlYXN5LCBjaGVhcCBjYXNlIHdoZXJlIGl0J3MgYSBzdWJzZXQgb2Ygb25lIG9mIHRoZSBidWZmZXJzXG4gIGlmIChieXRlcyA8PSB0aGlzLl9idWZzW29mZlswXV0ubGVuZ3RoIC0gc3RhcnQpIHtcbiAgICByZXR1cm4gY29weVxuICAgICAgPyB0aGlzLl9idWZzW29mZlswXV0uY29weShkc3QsIGRzdFN0YXJ0LCBzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgICAgIDogdGhpcy5fYnVmc1tvZmZbMF1dLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICB9XG5cbiAgaWYgKCFjb3B5KSB7XG4gICAgLy8gYSBzbGljZSwgd2UgbmVlZCBzb21ldGhpbmcgdG8gY29weSBpbiB0b1xuICAgIGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG4gIH1cblxuICBmb3IgKGxldCBpID0gb2ZmWzBdOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9idWZzW2ldLmxlbmd0aCAtIHN0YXJ0XG5cbiAgICBpZiAoYnl0ZXMgPiBsKSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0KVxuICAgICAgYnVmb2ZmICs9IGxcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmLCBzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgICAgIGJ1Zm9mZiArPSBsXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGJ5dGVzIC09IGxcblxuICAgIGlmIChzdGFydCkge1xuICAgICAgc3RhcnQgPSAwXG4gICAgfVxuICB9XG5cbiAgLy8gc2FmZWd1YXJkIHNvIHRoYXQgd2UgZG9uJ3QgcmV0dXJuIHVuaW5pdGlhbGl6ZWQgbWVtb3J5XG4gIGlmIChkc3QubGVuZ3RoID4gYnVmb2ZmKSByZXR1cm4gZHN0LnNsaWNlKDAsIGJ1Zm9mZilcblxuICByZXR1cm4gZHN0XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoYWxsb3dTbGljZSA9IGZ1bmN0aW9uIHNoYWxsb3dTbGljZSAoc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDBcbiAgZW5kID0gdHlwZW9mIGVuZCAhPT0gJ251bWJlcicgPyB0aGlzLmxlbmd0aCA6IGVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuX25ldygpXG4gIH1cblxuICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMuX29mZnNldChzdGFydClcbiAgY29uc3QgZW5kT2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KGVuZClcbiAgY29uc3QgYnVmZmVycyA9IHRoaXMuX2J1ZnMuc2xpY2Uoc3RhcnRPZmZzZXRbMF0sIGVuZE9mZnNldFswXSArIDEpXG5cbiAgaWYgKGVuZE9mZnNldFsxXSA9PT0gMCkge1xuICAgIGJ1ZmZlcnMucG9wKClcbiAgfSBlbHNlIHtcbiAgICBidWZmZXJzW2J1ZmZlcnMubGVuZ3RoIC0gMV0gPSBidWZmZXJzW2J1ZmZlcnMubGVuZ3RoIC0gMV0uc2xpY2UoMCwgZW5kT2Zmc2V0WzFdKVxuICB9XG5cbiAgaWYgKHN0YXJ0T2Zmc2V0WzFdICE9PSAwKSB7XG4gICAgYnVmZmVyc1swXSA9IGJ1ZmZlcnNbMF0uc2xpY2Uoc3RhcnRPZmZzZXRbMV0pXG4gIH1cblxuICByZXR1cm4gdGhpcy5fbmV3KGJ1ZmZlcnMpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gY29uc3VtZSAoYnl0ZXMpIHtcbiAgLy8gZmlyc3QsIG5vcm1hbGl6ZSB0aGUgYXJndW1lbnQsIGluIGFjY29yZGFuY2Ugd2l0aCBob3cgQnVmZmVyIGRvZXMgaXRcbiAgYnl0ZXMgPSBNYXRoLnRydW5jKGJ5dGVzKVxuICAvLyBkbyBub3RoaW5nIGlmIG5vdCBhIHBvc2l0aXZlIG51bWJlclxuICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGVzKSB8fCBieXRlcyA8PSAwKSByZXR1cm4gdGhpc1xuXG4gIHdoaWxlICh0aGlzLl9idWZzLmxlbmd0aCkge1xuICAgIGlmIChieXRlcyA+PSB0aGlzLl9idWZzWzBdLmxlbmd0aCkge1xuICAgICAgYnl0ZXMgLT0gdGhpcy5fYnVmc1swXS5sZW5ndGhcbiAgICAgIHRoaXMubGVuZ3RoIC09IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoXG4gICAgICB0aGlzLl9idWZzLnNoaWZ0KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmc1swXSA9IHRoaXMuX2J1ZnNbMF0uc2xpY2UoYnl0ZXMpXG4gICAgICB0aGlzLmxlbmd0aCAtPSBieXRlc1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbiBkdXBsaWNhdGUgKCkge1xuICBjb25zdCBjb3B5ID0gdGhpcy5fbmV3KClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3B5LmFwcGVuZCh0aGlzLl9idWZzW2ldKVxuICB9XG5cbiAgcmV0dXJuIGNvcHlcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChidWYpIHtcbiAgaWYgKGJ1ZiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlmIChidWYuYnVmZmVyKSB7XG4gICAgLy8gYXBwZW5kIGEgdmlldyBvZiB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlclxuICAgIHRoaXMuX2FwcGVuZEJ1ZmZlcihCdWZmZXIuZnJvbShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYnVmKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFwcGVuZChidWZbaV0pXG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX2lzQnVmZmVyTGlzdChidWYpKSB7XG4gICAgLy8gdW53cmFwIGFyZ3VtZW50IGludG8gaW5kaXZpZHVhbCBCdWZmZXJMaXN0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFwcGVuZChidWYuX2J1ZnNbaV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGNvZXJjZSBudW1iZXIgYXJndW1lbnRzIHRvIHN0cmluZ3MsIHNpbmNlIEJ1ZmZlcihudW1iZXIpIGRvZXNcbiAgICAvLyB1bmluaXRpYWxpemVkIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgaWYgKHR5cGVvZiBidWYgPT09ICdudW1iZXInKSB7XG4gICAgICBidWYgPSBidWYudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIHRoaXMuX2FwcGVuZEJ1ZmZlcihCdWZmZXIuZnJvbShidWYpKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX2FwcGVuZEJ1ZmZlciA9IGZ1bmN0aW9uIGFwcGVuZEJ1ZmZlciAoYnVmKSB7XG4gIHRoaXMuX2J1ZnMucHVzaChidWYpXG4gIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGhcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2gsIG9mZnNldCwgZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShzZWFyY2gpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBCdWZmZXJMaXN0LCBvciBVaW50OEFycmF5LicpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ251bWJlcicpIHtcbiAgICBzZWFyY2ggPSBCdWZmZXIuZnJvbShbc2VhcmNoXSlcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnc3RyaW5nJykge1xuICAgIHNlYXJjaCA9IEJ1ZmZlci5mcm9tKHNlYXJjaCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodGhpcy5faXNCdWZmZXJMaXN0KHNlYXJjaCkpIHtcbiAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VhcmNoLmJ1ZmZlcikpIHtcbiAgICBzZWFyY2ggPSBCdWZmZXIuZnJvbShzZWFyY2guYnVmZmVyLCBzZWFyY2guYnl0ZU9mZnNldCwgc2VhcmNoLmJ5dGVMZW5ndGgpXG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzZWFyY2gpKSB7XG4gICAgc2VhcmNoID0gQnVmZmVyLmZyb20oc2VhcmNoKVxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCB8fCAwKVxuXG4gIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gMFxuICB9XG5cbiAgaWYgKG9mZnNldCA8IDApIHtcbiAgICBvZmZzZXQgPSB0aGlzLmxlbmd0aCArIG9mZnNldFxuICB9XG5cbiAgaWYgKG9mZnNldCA8IDApIHtcbiAgICBvZmZzZXQgPSAwXG4gIH1cblxuICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvZmZzZXQgPiB0aGlzLmxlbmd0aCA/IHRoaXMubGVuZ3RoIDogb2Zmc2V0XG4gIH1cblxuICBjb25zdCBibE9mZnNldCA9IHRoaXMuX29mZnNldChvZmZzZXQpXG4gIGxldCBibEluZGV4ID0gYmxPZmZzZXRbMF0gLy8gaW5kZXggb2Ygd2hpY2ggaW50ZXJuYWwgYnVmZmVyIHdlJ3JlIHdvcmtpbmcgb25cbiAgbGV0IGJ1ZmZPZmZzZXQgPSBibE9mZnNldFsxXSAvLyBvZmZzZXQgb2YgdGhlIGludGVybmFsIGJ1ZmZlciB3ZSdyZSB3b3JraW5nIG9uXG5cbiAgLy8gc2NhbiBvdmVyIGVhY2ggYnVmZmVyXG4gIGZvciAoOyBibEluZGV4IDwgdGhpcy5fYnVmcy5sZW5ndGg7IGJsSW5kZXgrKykge1xuICAgIGNvbnN0IGJ1ZmYgPSB0aGlzLl9idWZzW2JsSW5kZXhdXG5cbiAgICB3aGlsZSAoYnVmZk9mZnNldCA8IGJ1ZmYubGVuZ3RoKSB7XG4gICAgICBjb25zdCBhdmFpbGFibGVXaW5kb3cgPSBidWZmLmxlbmd0aCAtIGJ1ZmZPZmZzZXRcblxuICAgICAgaWYgKGF2YWlsYWJsZVdpbmRvdyA+PSBzZWFyY2gubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZVNlYXJjaFJlc3VsdCA9IGJ1ZmYuaW5kZXhPZihzZWFyY2gsIGJ1ZmZPZmZzZXQpXG5cbiAgICAgICAgaWYgKG5hdGl2ZVNlYXJjaFJlc3VsdCAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZU9mZnNldChbYmxJbmRleCwgbmF0aXZlU2VhcmNoUmVzdWx0XSlcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZPZmZzZXQgPSBidWZmLmxlbmd0aCAtIHNlYXJjaC5sZW5ndGggKyAxIC8vIGVuZCBvZiBuYXRpdmUgc2VhcmNoIHdpbmRvd1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmV2T2Zmc2V0ID0gdGhpcy5fcmV2ZXJzZU9mZnNldChbYmxJbmRleCwgYnVmZk9mZnNldF0pXG5cbiAgICAgICAgaWYgKHRoaXMuX21hdGNoKHJldk9mZnNldCwgc2VhcmNoKSkge1xuICAgICAgICAgIHJldHVybiByZXZPZmZzZXRcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZPZmZzZXQrK1xuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZPZmZzZXQgPSAwXG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX21hdGNoID0gZnVuY3Rpb24gKG9mZnNldCwgc2VhcmNoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCAtIG9mZnNldCA8IHNlYXJjaC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IHNlYXJjaE9mZnNldCA9IDA7IHNlYXJjaE9mZnNldCA8IHNlYXJjaC5sZW5ndGg7IHNlYXJjaE9mZnNldCsrKSB7XG4gICAgaWYgKHRoaXMuZ2V0KG9mZnNldCArIHNlYXJjaE9mZnNldCkgIT09IHNlYXJjaFtzZWFyY2hPZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuOyhmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgcmVhZERvdWJsZUJFOiA4LFxuICAgIHJlYWREb3VibGVMRTogOCxcbiAgICByZWFkRmxvYXRCRTogNCxcbiAgICByZWFkRmxvYXRMRTogNCxcbiAgICByZWFkSW50MzJCRTogNCxcbiAgICByZWFkSW50MzJMRTogNCxcbiAgICByZWFkVUludDMyQkU6IDQsXG4gICAgcmVhZFVJbnQzMkxFOiA0LFxuICAgIHJlYWRJbnQxNkJFOiAyLFxuICAgIHJlYWRJbnQxNkxFOiAyLFxuICAgIHJlYWRVSW50MTZCRTogMixcbiAgICByZWFkVUludDE2TEU6IDIsXG4gICAgcmVhZEludDg6IDEsXG4gICAgcmVhZFVJbnQ4OiAxLFxuICAgIHJlYWRJbnRCRTogbnVsbCxcbiAgICByZWFkSW50TEU6IG51bGwsXG4gICAgcmVhZFVJbnRCRTogbnVsbCxcbiAgICByZWFkVUludExFOiBudWxsXG4gIH1cblxuICBmb3IgKGNvbnN0IG0gaW4gbWV0aG9kcykge1xuICAgIChmdW5jdGlvbiAobSkge1xuICAgICAgaWYgKG1ldGhvZHNbbV0gPT09IG51bGwpIHtcbiAgICAgICAgQnVmZmVyTGlzdC5wcm90b3R5cGVbbV0gPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBieXRlTGVuZ3RoKVttXSgwLCBieXRlTGVuZ3RoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBCdWZmZXJMaXN0LnByb3RvdHlwZVttXSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBtZXRob2RzW21dKVttXSgwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfShtKSlcbiAgfVxufSgpKVxuXG4vLyBVc2VkIGludGVybmFsbHkgYnkgdGhlIGNsYXNzIGFuZCBhbHNvIGFzIGFuIGluZGljYXRvciBvZiB0aGlzIG9iamVjdCBiZWluZ1xuLy8gYSBgQnVmZmVyTGlzdGAuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJMaXN0YCBpbiBhIGJyb3dzZXJcbi8vIGVudmlyb25tZW50IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50IGNvcGllcyBvZiB0aGVcbi8vIEJ1ZmZlckxpc3QgY2xhc3MgYW5kIHNvbWUgYEJ1ZmZlckxpc3RgcyBtaWdodCBiZSBgQnVmZmVyTGlzdGBzLlxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX2lzQnVmZmVyTGlzdCA9IGZ1bmN0aW9uIF9pc0J1ZmZlckxpc3QgKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXJMaXN0IHx8IEJ1ZmZlckxpc3QuaXNCdWZmZXJMaXN0KGIpXG59XG5cbkJ1ZmZlckxpc3QuaXNCdWZmZXJMaXN0ID0gZnVuY3Rpb24gaXNCdWZmZXJMaXN0IChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYltzeW1ib2xdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyTGlzdFxuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsInJlcXVpcmUiLCJzeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJCdWZmZXJMaXN0IiwiYnVmIiwiX2luaXQiLCJjYWxsIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIl9idWZzIiwibGVuZ3RoIiwiYXBwZW5kIiwicHJvdG90eXBlIiwiX25ldyIsIl9vZmZzZXQiLCJvZmZzZXQiLCJ0b3QiLCJpIiwiX3QiLCJfcmV2ZXJzZU9mZnNldCIsImJsT2Zmc2V0IiwiYnVmZmVySWQiLCJnZXQiLCJpbmRleCIsInVuZGVmaW5lZCIsInNsaWNlIiwic3RhcnQiLCJlbmQiLCJjb3B5IiwiZHN0IiwiZHN0U3RhcnQiLCJzcmNTdGFydCIsInNyY0VuZCIsImFsbG9jIiwib2ZmIiwibGVuIiwiYnl0ZXMiLCJidWZvZmYiLCJjb25jYXQiLCJhbGxvY1Vuc2FmZSIsImwiLCJzaGFsbG93U2xpY2UiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImJ1ZmZlcnMiLCJwb3AiLCJ0b1N0cmluZyIsImVuY29kaW5nIiwiY29uc3VtZSIsIk1hdGgiLCJ0cnVuYyIsIk51bWJlciIsImlzTmFOIiwic2hpZnQiLCJkdXBsaWNhdGUiLCJidWZmZXIiLCJfYXBwZW5kQnVmZmVyIiwiZnJvbSIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwiX2lzQnVmZmVyTGlzdCIsImFwcGVuZEJ1ZmZlciIsInB1c2giLCJpbmRleE9mIiwic2VhcmNoIiwiVHlwZUVycm9yIiwiaXNCdWZmZXIiLCJibEluZGV4IiwiYnVmZk9mZnNldCIsImJ1ZmYiLCJhdmFpbGFibGVXaW5kb3ciLCJuYXRpdmVTZWFyY2hSZXN1bHQiLCJyZXZPZmZzZXQiLCJfbWF0Y2giLCJzZWFyY2hPZmZzZXQiLCJtZXRob2RzIiwicmVhZERvdWJsZUJFIiwicmVhZERvdWJsZUxFIiwicmVhZEZsb2F0QkUiLCJyZWFkRmxvYXRMRSIsInJlYWRJbnQzMkJFIiwicmVhZEludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkVUludDMyTEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQxNkxFIiwicmVhZFVJbnQxNkJFIiwicmVhZFVJbnQxNkxFIiwicmVhZEludDgiLCJyZWFkVUludDgiLCJyZWFkSW50QkUiLCJyZWFkSW50TEUiLCJyZWFkVUludEJFIiwicmVhZFVJbnRMRSIsIm0iLCJiIiwiaXNCdWZmZXJMaXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bl/BufferList.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bl/bl.js":
/*!*******************************!*\
  !*** ./node_modules/bl/bl.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst DuplexStream = (__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/readable.js\").Duplex);\nconst inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\nconst BufferList = __webpack_require__(/*! ./BufferList */ \"(ssr)/./node_modules/bl/BufferList.js\");\nfunction BufferListStream(callback) {\n    if (!(this instanceof BufferListStream)) {\n        return new BufferListStream(callback);\n    }\n    if (typeof callback === \"function\") {\n        this._callback = callback;\n        const piper = (function piper(err) {\n            if (this._callback) {\n                this._callback(err);\n                this._callback = null;\n            }\n        }).bind(this);\n        this.on(\"pipe\", function onPipe(src) {\n            src.on(\"error\", piper);\n        });\n        this.on(\"unpipe\", function onUnpipe(src) {\n            src.removeListener(\"error\", piper);\n        });\n        callback = null;\n    }\n    BufferList._init.call(this, callback);\n    DuplexStream.call(this);\n}\ninherits(BufferListStream, DuplexStream);\nObject.assign(BufferListStream.prototype, BufferList.prototype);\nBufferListStream.prototype._new = function _new(callback) {\n    return new BufferListStream(callback);\n};\nBufferListStream.prototype._write = function _write(buf, encoding, callback) {\n    this._appendBuffer(buf);\n    if (typeof callback === \"function\") {\n        callback();\n    }\n};\nBufferListStream.prototype._read = function _read(size) {\n    if (!this.length) {\n        return this.push(null);\n    }\n    size = Math.min(size, this.length);\n    this.push(this.slice(0, size));\n    this.consume(size);\n};\nBufferListStream.prototype.end = function end(chunk) {\n    DuplexStream.prototype.end.call(this, chunk);\n    if (this._callback) {\n        this._callback(null, this.slice());\n        this._callback = null;\n    }\n};\nBufferListStream.prototype._destroy = function _destroy(err, cb) {\n    this._bufs.length = 0;\n    this.length = 0;\n    cb(err);\n};\nBufferListStream.prototype._isBufferList = function _isBufferList(b) {\n    return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);\n};\nBufferListStream.isBufferList = BufferList.isBufferList;\nmodule.exports = BufferListStream;\nmodule.exports.BufferListStream = BufferListStream;\nmodule.exports.BufferList = BufferList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUJBQWlCb0MsWUFBWSxHQUFHckMsV0FBV3FDLFlBQVk7QUFFdkRDLE9BQU9DLE9BQU8sR0FBR3RDO0FBQ2pCcUMsK0JBQStCLEdBQUdyQztBQUNsQ3FDLHlCQUF5QixHQUFHdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZC10aW1lc2hlZXQtYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvYmwvYmwuanM/MzkwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRHVwbGV4U3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuRHVwbGV4XG5jb25zdCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbmNvbnN0IEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL0J1ZmZlckxpc3QnKVxuXG5mdW5jdGlvbiBCdWZmZXJMaXN0U3RyZWFtIChjYWxsYmFjaykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyTGlzdFN0cmVhbSkpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckxpc3RTdHJlYW0oY2FsbGJhY2spXG4gIH1cblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFja1xuXG4gICAgY29uc3QgcGlwZXIgPSBmdW5jdGlvbiBwaXBlciAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soZXJyKVxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcylcblxuICAgIHRoaXMub24oJ3BpcGUnLCBmdW5jdGlvbiBvblBpcGUgKHNyYykge1xuICAgICAgc3JjLm9uKCdlcnJvcicsIHBpcGVyKVxuICAgIH0pXG4gICAgdGhpcy5vbigndW5waXBlJywgZnVuY3Rpb24gb25VbnBpcGUgKHNyYykge1xuICAgICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHBpcGVyKVxuICAgIH0pXG5cbiAgICBjYWxsYmFjayA9IG51bGxcbiAgfVxuXG4gIEJ1ZmZlckxpc3QuX2luaXQuY2FsbCh0aGlzLCBjYWxsYmFjaylcbiAgRHVwbGV4U3RyZWFtLmNhbGwodGhpcylcbn1cblxuaW5oZXJpdHMoQnVmZmVyTGlzdFN0cmVhbSwgRHVwbGV4U3RyZWFtKVxuT2JqZWN0LmFzc2lnbihCdWZmZXJMaXN0U3RyZWFtLnByb3RvdHlwZSwgQnVmZmVyTGlzdC5wcm90b3R5cGUpXG5cbkJ1ZmZlckxpc3RTdHJlYW0ucHJvdG90eXBlLl9uZXcgPSBmdW5jdGlvbiBfbmV3IChjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IEJ1ZmZlckxpc3RTdHJlYW0oY2FsbGJhY2spXG59XG5cbkJ1ZmZlckxpc3RTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoYnVmLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgdGhpcy5fYXBwZW5kQnVmZmVyKGJ1ZilcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2soKVxuICB9XG59XG5cbkJ1ZmZlckxpc3RTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gX3JlYWQgKHNpemUpIHtcbiAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnB1c2gobnVsbClcbiAgfVxuXG4gIHNpemUgPSBNYXRoLm1pbihzaXplLCB0aGlzLmxlbmd0aClcbiAgdGhpcy5wdXNoKHRoaXMuc2xpY2UoMCwgc2l6ZSkpXG4gIHRoaXMuY29uc3VtZShzaXplKVxufVxuXG5CdWZmZXJMaXN0U3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQgKGNodW5rKSB7XG4gIER1cGxleFN0cmVhbS5wcm90b3R5cGUuZW5kLmNhbGwodGhpcywgY2h1bmspXG5cbiAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sobnVsbCwgdGhpcy5zbGljZSgpKVxuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuICB9XG59XG5cbkJ1ZmZlckxpc3RTdHJlYW0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3kgKGVyciwgY2IpIHtcbiAgdGhpcy5fYnVmcy5sZW5ndGggPSAwXG4gIHRoaXMubGVuZ3RoID0gMFxuICBjYihlcnIpXG59XG5cbkJ1ZmZlckxpc3RTdHJlYW0ucHJvdG90eXBlLl9pc0J1ZmZlckxpc3QgPSBmdW5jdGlvbiBfaXNCdWZmZXJMaXN0IChiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyTGlzdFN0cmVhbSB8fCBiIGluc3RhbmNlb2YgQnVmZmVyTGlzdCB8fCBCdWZmZXJMaXN0U3RyZWFtLmlzQnVmZmVyTGlzdChiKVxufVxuXG5CdWZmZXJMaXN0U3RyZWFtLmlzQnVmZmVyTGlzdCA9IEJ1ZmZlckxpc3QuaXNCdWZmZXJMaXN0XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyTGlzdFN0cmVhbVxubW9kdWxlLmV4cG9ydHMuQnVmZmVyTGlzdFN0cmVhbSA9IEJ1ZmZlckxpc3RTdHJlYW1cbm1vZHVsZS5leHBvcnRzLkJ1ZmZlckxpc3QgPSBCdWZmZXJMaXN0XG4iXSwibmFtZXMiOlsiRHVwbGV4U3RyZWFtIiwicmVxdWlyZSIsIkR1cGxleCIsImluaGVyaXRzIiwiQnVmZmVyTGlzdCIsIkJ1ZmZlckxpc3RTdHJlYW0iLCJjYWxsYmFjayIsIl9jYWxsYmFjayIsInBpcGVyIiwiZXJyIiwiYmluZCIsIm9uIiwib25QaXBlIiwic3JjIiwib25VbnBpcGUiLCJyZW1vdmVMaXN0ZW5lciIsIl9pbml0IiwiY2FsbCIsIk9iamVjdCIsImFzc2lnbiIsInByb3RvdHlwZSIsIl9uZXciLCJfd3JpdGUiLCJidWYiLCJlbmNvZGluZyIsIl9hcHBlbmRCdWZmZXIiLCJfcmVhZCIsInNpemUiLCJsZW5ndGgiLCJwdXNoIiwiTWF0aCIsIm1pbiIsInNsaWNlIiwiY29uc3VtZSIsImVuZCIsImNodW5rIiwiX2Rlc3Ryb3kiLCJjYiIsIl9idWZzIiwiX2lzQnVmZmVyTGlzdCIsImIiLCJpc0J1ZmZlckxpc3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bl/bl.js\n");

/***/ })

};
;