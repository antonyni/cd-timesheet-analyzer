/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tmp";
exports.ids = ["vendor-chunks/tmp"];
exports.modules = {

/***/ "(ssr)/./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */ /*\n * Module dependencies.\n */ const fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst _c = {\n    fs: fs.constants,\n    os: os.constants\n};\nconst rimraf = __webpack_require__(/*! rimraf */ \"(ssr)/./node_modules/rimraf/rimraf.js\");\n/*\n * The working inner variables.\n */ const // the random characters to choose from\nRANDOM_CHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", TEMPLATE_PATTERN = /XXXXXX/, DEFAULT_TRIES = 3, CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR), // constants are off on the windows platform and will not match the actual errno codes\nIS_WIN32 = os.platform() === \"win32\", EBADF = _c.EBADF || _c.os.errno.EBADF, ENOENT = _c.ENOENT || _c.os.errno.ENOENT, DIR_MODE = 448 /* 448 */ , FILE_MODE = 384 /* 384 */ , EXIT = \"exit\", // this will hold the objects need to be removed on exit\n_removeObjects = [], // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\nFN_RMDIR_SYNC = fs.rmdirSync.bind(fs), FN_RIMRAF_SYNC = rimraf.sync;\nlet _gracefulCleanup = false;\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */ function tmpName(options, callback) {\n    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    try {\n        _assertAndSanitizeOptions(opts);\n    } catch (err) {\n        return cb(err);\n    }\n    let tries = opts.tries;\n    (function _getUniqueName() {\n        try {\n            const name = _generateTmpName(opts);\n            // check whether the path exists then retry if needed\n            fs.stat(name, function(err) {\n                /* istanbul ignore else */ if (!err) {\n                    /* istanbul ignore else */ if (tries-- > 0) return _getUniqueName();\n                    return cb(new Error(\"Could not get a unique tmp filename, max tries reached \" + name));\n                }\n                cb(null, name);\n            });\n        } catch (err) {\n            cb(err);\n        }\n    })();\n}\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */ function tmpNameSync(options) {\n    const args = _parseArguments(options), opts = args[0];\n    _assertAndSanitizeOptions(opts);\n    let tries = opts.tries;\n    do {\n        const name = _generateTmpName(opts);\n        try {\n            fs.statSync(name);\n        } catch (e) {\n            return name;\n        }\n    }while (tries-- > 0);\n    throw new Error(\"Could not get a unique tmp filename, max tries reached\");\n}\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */ function file(options, callback) {\n    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    // gets a temporary filename\n    tmpName(opts, function _tmpNameCreated(err, name) {\n        /* istanbul ignore else */ if (err) return cb(err);\n        // create and open the file\n        fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n            /* istanbu ignore else */ if (err) return cb(err);\n            if (opts.discardDescriptor) {\n                return fs.close(fd, function _discardCallback(possibleErr) {\n                    // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n                    return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n                });\n            } else {\n                // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n                // about the descriptor\n                const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n                cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n            }\n        });\n    });\n}\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */ function fileSync(options) {\n    const args = _parseArguments(options), opts = args[0];\n    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n    const name = tmpNameSync(opts);\n    var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n    /* istanbul ignore else */ if (opts.discardDescriptor) {\n        fs.closeSync(fd);\n        fd = undefined;\n    }\n    return {\n        name: name,\n        fd: fd,\n        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n    };\n}\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */ function dir(options, callback) {\n    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    // gets a temporary filename\n    tmpName(opts, function _tmpNameCreated(err, name) {\n        /* istanbul ignore else */ if (err) return cb(err);\n        // create the directory\n        fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n            /* istanbul ignore else */ if (err) return cb(err);\n            cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n        });\n    });\n}\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */ function dirSync(options) {\n    const args = _parseArguments(options), opts = args[0];\n    const name = tmpNameSync(opts);\n    fs.mkdirSync(name, opts.mode || DIR_MODE);\n    return {\n        name: name,\n        removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n    };\n}\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */ function _removeFileAsync(fdPath, next) {\n    const _handler = function(err) {\n        if (err && !_isENOENT(err)) {\n            // reraise any unanticipated error\n            return next(err);\n        }\n        next();\n    };\n    if (0 <= fdPath[0]) fs.close(fdPath[0], function() {\n        fs.unlink(fdPath[1], _handler);\n    });\n    else fs.unlink(fdPath[1], _handler);\n}\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */ function _removeFileSync(fdPath) {\n    let rethrownException = null;\n    try {\n        if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n    } catch (e) {\n        // reraise any unanticipated error\n        if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n    } finally{\n        try {\n            fs.unlinkSync(fdPath[1]);\n        } catch (e) {\n            // reraise any unanticipated error\n            if (!_isENOENT(e)) rethrownException = e;\n        }\n    }\n    if (rethrownException !== null) {\n        throw rethrownException;\n    }\n}\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */ function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n    const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [\n        fd,\n        name\n    ], sync);\n    const removeCallback = _prepareRemoveCallback(_removeFileAsync, [\n        fd,\n        name\n    ], sync, removeCallbackSync);\n    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n    return sync ? removeCallbackSync : removeCallback;\n}\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */ function _prepareTmpDirRemoveCallback(name, opts, sync) {\n    const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n    const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n    const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n    const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n    return sync ? removeCallbackSync : removeCallback;\n}\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */ function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n    let called = false;\n    // if sync is true, the next parameter will be ignored\n    return function _cleanupCallback(next) {\n        /* istanbul ignore else */ if (!called) {\n            // remove cleanupCallback from cache\n            const toRemove = cleanupCallbackSync || _cleanupCallback;\n            const index = _removeObjects.indexOf(toRemove);\n            /* istanbul ignore else */ if (index >= 0) _removeObjects.splice(index, 1);\n            called = true;\n            if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n                return removeFunction(fileOrDirName);\n            } else {\n                return removeFunction(fileOrDirName, next || function() {});\n            }\n        }\n    };\n}\n/**\n * The garbage collector.\n *\n * @private\n */ function _garbageCollector() {\n    /* istanbul ignore else */ if (!_gracefulCleanup) return;\n    // the function being called removes itself from _removeObjects,\n    // loop until _removeObjects is empty\n    while(_removeObjects.length){\n        try {\n            _removeObjects[0]();\n        } catch (e) {\n        // already removed?\n        }\n    }\n}\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */ function _randomChars(howMany) {\n    let value = [], rnd = null;\n    // make sure that we do not fail because we ran out of entropy\n    try {\n        rnd = crypto.randomBytes(howMany);\n    } catch (e) {\n        rnd = crypto.pseudoRandomBytes(howMany);\n    }\n    for(var i = 0; i < howMany; i++){\n        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n    }\n    return value.join(\"\");\n}\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */ function _isBlank(s) {\n    return s === null || _isUndefined(s) || !s.trim();\n}\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */ function _isUndefined(obj) {\n    return typeof obj === \"undefined\";\n}\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */ function _parseArguments(options, callback) {\n    /* istanbul ignore else */ if (typeof options === \"function\") {\n        return [\n            {},\n            options\n        ];\n    }\n    /* istanbul ignore else */ if (_isUndefined(options)) {\n        return [\n            {},\n            callback\n        ];\n    }\n    // copy options so we do not leak the changes we make internally\n    const actualOptions = {};\n    for (const key of Object.getOwnPropertyNames(options)){\n        actualOptions[key] = options[key];\n    }\n    return [\n        actualOptions,\n        callback\n    ];\n}\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */ function _generateTmpName(opts) {\n    const tmpDir = opts.tmpdir;\n    /* istanbul ignore else */ if (!_isUndefined(opts.name)) return path.join(tmpDir, opts.dir, opts.name);\n    /* istanbul ignore else */ if (!_isUndefined(opts.template)) return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n    // prefix and postfix\n    const name = [\n        opts.prefix ? opts.prefix : \"tmp\",\n        \"-\",\n        process.pid,\n        \"-\",\n        _randomChars(12),\n        opts.postfix ? \"-\" + opts.postfix : \"\"\n    ].join(\"\");\n    return path.join(tmpDir, opts.dir, name);\n}\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */ function _assertAndSanitizeOptions(options) {\n    options.tmpdir = _getTmpDir(options);\n    const tmpDir = options.tmpdir;\n    /* istanbul ignore else */ if (!_isUndefined(options.name)) _assertIsRelative(options.name, \"name\", tmpDir);\n    /* istanbul ignore else */ if (!_isUndefined(options.dir)) _assertIsRelative(options.dir, \"dir\", tmpDir);\n    /* istanbul ignore else */ if (!_isUndefined(options.template)) {\n        _assertIsRelative(options.template, \"template\", tmpDir);\n        if (!options.template.match(TEMPLATE_PATTERN)) throw new Error(`Invalid template, found \"${options.template}\".`);\n    }\n    /* istanbul ignore else */ if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0) throw new Error(`Invalid tries, found \"${options.tries}\".`);\n    // if a name was specified we will try once\n    options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n    options.keep = !!options.keep;\n    options.detachDescriptor = !!options.detachDescriptor;\n    options.discardDescriptor = !!options.discardDescriptor;\n    options.unsafeCleanup = !!options.unsafeCleanup;\n    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n    options.dir = _isUndefined(options.dir) ? \"\" : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n    options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n    // sanitize further if template is relative to options.dir\n    options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n    // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n    options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);\n    options.prefix = _isUndefined(options.prefix) ? \"\" : options.prefix;\n    options.postfix = _isUndefined(options.postfix) ? \"\" : options.postfix;\n}\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */ function _resolvePath(name, tmpDir) {\n    const sanitizedName = _sanitizeName(name);\n    if (sanitizedName.startsWith(tmpDir)) {\n        return path.resolve(sanitizedName);\n    } else {\n        return path.resolve(path.join(tmpDir, sanitizedName));\n    }\n}\n/**\n * Sanitize the specified path name by removing all quote characters.\n *\n * @param name\n * @returns {string}\n * @private\n */ function _sanitizeName(name) {\n    if (_isBlank(name)) {\n        return name;\n    }\n    return name.replace(/[\"']/g, \"\");\n}\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */ function _assertIsRelative(name, option, tmpDir) {\n    if (option === \"name\") {\n        // assert that name is not absolute and does not contain a path\n        if (path.isAbsolute(name)) throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n        // must not fail on valid .<name> or ..<name> or similar such constructs\n        let basename = path.basename(name);\n        if (basename === \"..\" || basename === \".\" || basename !== name) throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n    } else {\n        // assert that dir or template are relative to tmpDir\n        if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n            throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n        }\n        let resolvedPath = _resolvePath(name, tmpDir);\n        if (!resolvedPath.startsWith(tmpDir)) throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n    }\n}\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */ function _isEBADF(error) {\n    return _isExpectedError(error, -EBADF, \"EBADF\");\n}\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */ function _isENOENT(error) {\n    return _isExpectedError(error, -ENOENT, \"ENOENT\");\n}\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */ function _isExpectedError(error, errno, code) {\n    return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */ function setGracefulCleanup() {\n    _gracefulCleanup = true;\n}\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */ function _getTmpDir(options) {\n    return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));\n}\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */ /**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */ /**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */ /**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */ /**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */ /**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */ /**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */ /**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */ /**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */ /**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */ /**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */ // exporting all the needed methods\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, \"tmpdir\", ({\n    enumerable: true,\n    configurable: false,\n    get: function() {\n        return _getTmpDir();\n    }\n}));\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cy90bXAvbGliL3RtcC5qcz84OGQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVG1wXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTcgS0FSQVNaSSBJc3R2YW4gPGdpdGh1YkBzcGFtLnJhc3ppLmh1PlxuICpcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBfYyA9IHsgZnM6IGZzLmNvbnN0YW50cywgb3M6IG9zLmNvbnN0YW50cyB9O1xuY29uc3QgcmltcmFmID0gcmVxdWlyZSgncmltcmFmJyk7XG5cbi8qXG4gKiBUaGUgd29ya2luZyBpbm5lciB2YXJpYWJsZXMuXG4gKi9cbmNvbnN0XG4gIC8vIHRoZSByYW5kb20gY2hhcmFjdGVycyB0byBjaG9vc2UgZnJvbVxuICBSQU5ET01fQ0hBUlMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxuXG4gIFRFTVBMQVRFX1BBVFRFUk4gPSAvWFhYWFhYLyxcblxuICBERUZBVUxUX1RSSUVTID0gMyxcblxuICBDUkVBVEVfRkxBR1MgPSAoX2MuT19DUkVBVCB8fCBfYy5mcy5PX0NSRUFUKSB8IChfYy5PX0VYQ0wgfHwgX2MuZnMuT19FWENMKSB8IChfYy5PX1JEV1IgfHwgX2MuZnMuT19SRFdSKSxcblxuICAvLyBjb25zdGFudHMgYXJlIG9mZiBvbiB0aGUgd2luZG93cyBwbGF0Zm9ybSBhbmQgd2lsbCBub3QgbWF0Y2ggdGhlIGFjdHVhbCBlcnJubyBjb2Rlc1xuICBJU19XSU4zMiA9IG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicsXG4gIEVCQURGID0gX2MuRUJBREYgfHwgX2Mub3MuZXJybm8uRUJBREYsXG4gIEVOT0VOVCA9IF9jLkVOT0VOVCB8fCBfYy5vcy5lcnJuby5FTk9FTlQsXG5cbiAgRElSX01PREUgPSAwbzcwMCAvKiA0NDggKi8sXG4gIEZJTEVfTU9ERSA9IDBvNjAwIC8qIDM4NCAqLyxcblxuICBFWElUID0gJ2V4aXQnLFxuXG4gIC8vIHRoaXMgd2lsbCBob2xkIHRoZSBvYmplY3RzIG5lZWQgdG8gYmUgcmVtb3ZlZCBvbiBleGl0XG4gIF9yZW1vdmVPYmplY3RzID0gW10sXG5cbiAgLy8gQVBJIGNoYW5nZSBpbiBmcy5ybWRpclN5bmMgbGVhZHMgdG8gZXJyb3Igd2hlbiBwYXNzaW5nIGluIGEgc2Vjb25kIHBhcmFtZXRlciwgZS5nLiB0aGUgY2FsbGJhY2tcbiAgRk5fUk1ESVJfU1lOQyA9IGZzLnJtZGlyU3luYy5iaW5kKGZzKSxcbiAgRk5fUklNUkFGX1NZTkMgPSByaW1yYWYuc3luYztcblxubGV0XG4gIF9ncmFjZWZ1bENsZWFudXAgPSBmYWxzZTtcblxuLyoqXG4gKiBHZXRzIGEgdGVtcG9yYXJ5IGZpbGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfHRtcE5hbWVDYWxsYmFjayl9IG9wdGlvbnMgb3B0aW9ucyBvciBjYWxsYmFja1xuICogQHBhcmFtIHs/dG1wTmFtZUNhbGxiYWNrfSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdG1wTmFtZShvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdFxuICAgIGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spLFxuICAgIG9wdHMgPSBhcmdzWzBdLFxuICAgIGNiID0gYXJnc1sxXTtcblxuICB0cnkge1xuICAgIF9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnMob3B0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjYihlcnIpO1xuICB9XG5cbiAgbGV0IHRyaWVzID0gb3B0cy50cmllcztcbiAgKGZ1bmN0aW9uIF9nZXRVbmlxdWVOYW1lKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuYW1lID0gX2dlbmVyYXRlVG1wTmFtZShvcHRzKTtcblxuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgcGF0aCBleGlzdHMgdGhlbiByZXRyeSBpZiBuZWVkZWRcbiAgICAgIGZzLnN0YXQobmFtZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKHRyaWVzLS0gPiAwKSByZXR1cm4gX2dldFVuaXF1ZU5hbWUoKTtcblxuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgYSB1bmlxdWUgdG1wIGZpbGVuYW1lLCBtYXggdHJpZXMgcmVhY2hlZCAnICsgbmFtZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IobnVsbCwgbmFtZSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KCkpO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgdG1wTmFtZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGdlbmVyYXRlZCByYW5kb20gbmFtZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkIG9yIGNvdWxkIG5vdCBnZW5lcmF0ZSBhIGZpbGVuYW1lXG4gKi9cbmZ1bmN0aW9uIHRtcE5hbWVTeW5jKG9wdGlvbnMpIHtcbiAgY29uc3RcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIF9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnMob3B0cyk7XG5cbiAgbGV0IHRyaWVzID0gb3B0cy50cmllcztcbiAgZG8ge1xuICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpO1xuICAgIHRyeSB7XG4gICAgICBmcy5zdGF0U3luYyhuYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH0gd2hpbGUgKHRyaWVzLS0gPiAwKTtcblxuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgYSB1bmlxdWUgdG1wIGZpbGVuYW1lLCBtYXggdHJpZXMgcmVhY2hlZCcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIG9wZW5zIGEgdGVtcG9yYXJ5IGZpbGUuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xudWxsfHVuZGVmaW5lZHxmaWxlQ2FsbGJhY2spfSBvcHRpb25zIHRoZSBjb25maWcgb3B0aW9ucyBvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gb3IgbnVsbCBvciB1bmRlZmluZWRcbiAqIEBwYXJhbSB7P2ZpbGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZmlsZShvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdFxuICAgIGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spLFxuICAgIG9wdHMgPSBhcmdzWzBdLFxuICAgIGNiID0gYXJnc1sxXTtcblxuICAvLyBnZXRzIGEgdGVtcG9yYXJ5IGZpbGVuYW1lXG4gIHRtcE5hbWUob3B0cywgZnVuY3Rpb24gX3RtcE5hbWVDcmVhdGVkKGVyciwgbmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAvLyBjcmVhdGUgYW5kIG9wZW4gdGhlIGZpbGVcbiAgICBmcy5vcGVuKG5hbWUsIENSRUFURV9GTEFHUywgb3B0cy5tb2RlIHx8IEZJTEVfTU9ERSwgZnVuY3Rpb24gX2ZpbGVDcmVhdGVkKGVyciwgZmQpIHtcbiAgICAgIC8qIGlzdGFuYnUgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBpZiAob3B0cy5kaXNjYXJkRGVzY3JpcHRvcikge1xuICAgICAgICByZXR1cm4gZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIF9kaXNjYXJkQ2FsbGJhY2socG9zc2libGVFcnIpIHtcbiAgICAgICAgICAvLyB0aGUgY2hhbmNlIG9mIGdldHRpbmcgYW4gZXJyb3Igb24gY2xvc2UgaGVyZSBpcyByYXRoZXIgbG93IGFuZCBtaWdodCBvY2N1ciBpbiB0aGUgbW9zdCBlZGdpZXN0IGNhc2VzIG9ubHlcbiAgICAgICAgICByZXR1cm4gY2IocG9zc2libGVFcnIsIG5hbWUsIHVuZGVmaW5lZCwgX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgLTEsIG9wdHMsIGZhbHNlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGV0YWNoRGVzY3JpcHRvciBwYXNzZXMgdGhlIGRlc2NyaXB0b3Igd2hlcmVhcyBkaXNjYXJkRGVzY3JpcHRvciBjbG9zZXMgaXQsIGVpdGhlciB3YXksIHdlIG5vIGxvbmdlciBjYXJlXG4gICAgICAgIC8vIGFib3V0IHRoZSBkZXNjcmlwdG9yXG4gICAgICAgIGNvbnN0IGRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IgPSBvcHRzLmRpc2NhcmREZXNjcmlwdG9yIHx8IG9wdHMuZGV0YWNoRGVzY3JpcHRvcjtcbiAgICAgICAgY2IobnVsbCwgbmFtZSwgZmQsIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIGRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IgPyAtMSA6IGZkLCBvcHRzLCBmYWxzZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGZpbGUuXG4gKlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RmlsZVN5bmNPYmplY3R9IG9iamVjdCBjb25zaXN0cyBvZiBuYW1lLCBmZCBhbmQgcmVtb3ZlQ2FsbGJhY2tcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBjYW5ub3QgY3JlYXRlIGEgZmlsZVxuICovXG5mdW5jdGlvbiBmaWxlU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zKSxcbiAgICBvcHRzID0gYXJnc1swXTtcblxuICBjb25zdCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID0gb3B0cy5kaXNjYXJkRGVzY3JpcHRvciB8fCBvcHRzLmRldGFjaERlc2NyaXB0b3I7XG4gIGNvbnN0IG5hbWUgPSB0bXBOYW1lU3luYyhvcHRzKTtcbiAgdmFyIGZkID0gZnMub3BlblN5bmMobmFtZSwgQ1JFQVRFX0ZMQUdTLCBvcHRzLm1vZGUgfHwgRklMRV9NT0RFKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKG9wdHMuZGlzY2FyZERlc2NyaXB0b3IpIHtcbiAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgIGZkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGZkOiBmZCxcbiAgICByZW1vdmVDYWxsYmFjazogX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA/IC0xIDogZmQsIG9wdHMsIHRydWUpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xkaXJDYWxsYmFjayl9IG9wdGlvbnMgdGhlIG9wdGlvbnMgb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0gez9kaXJDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZGlyKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIC8vIGdldHMgYSB0ZW1wb3JhcnkgZmlsZW5hbWVcbiAgdG1wTmFtZShvcHRzLCBmdW5jdGlvbiBfdG1wTmFtZUNyZWF0ZWQoZXJyLCBuYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgZGlyZWN0b3J5XG4gICAgZnMubWtkaXIobmFtZSwgb3B0cy5tb2RlIHx8IERJUl9NT0RFLCBmdW5jdGlvbiBfZGlyQ3JlYXRlZChlcnIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgY2IobnVsbCwgbmFtZSwgX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCBmYWxzZSkpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGRpci5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtEaXJTeW5jT2JqZWN0fSBvYmplY3QgY29uc2lzdHMgb2YgbmFtZSBhbmQgcmVtb3ZlQ2FsbGJhY2tcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBjYW5ub3QgY3JlYXRlIGEgZGlyZWN0b3J5XG4gKi9cbmZ1bmN0aW9uIGRpclN5bmMob3B0aW9ucykge1xuICBjb25zdFxuICAgIGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucyksXG4gICAgb3B0cyA9IGFyZ3NbMF07XG5cbiAgY29uc3QgbmFtZSA9IHRtcE5hbWVTeW5jKG9wdHMpO1xuICBmcy5ta2RpclN5bmMobmFtZSwgb3B0cy5tb2RlIHx8IERJUl9NT0RFKTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmVtb3ZlQ2FsbGJhY2s6IF9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2sobmFtZSwgb3B0cywgdHJ1ZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGZpbGVzIGFzeW5jaHJvbm91c2x5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmZFBhdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVGaWxlQXN5bmMoZmRQYXRoLCBuZXh0KSB7XG4gIGNvbnN0IF9oYW5kbGVyID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgIV9pc0VOT0VOVChlcnIpKSB7XG4gICAgICAvLyByZXJhaXNlIGFueSB1bmFudGljaXBhdGVkIGVycm9yXG4gICAgICByZXR1cm4gbmV4dChlcnIpO1xuICAgIH1cbiAgICBuZXh0KCk7XG4gIH07XG5cbiAgaWYgKDAgPD0gZmRQYXRoWzBdKVxuICAgIGZzLmNsb3NlKGZkUGF0aFswXSwgZnVuY3Rpb24gKCkge1xuICAgICAgZnMudW5saW5rKGZkUGF0aFsxXSwgX2hhbmRsZXIpO1xuICAgIH0pO1xuICBlbHNlIGZzLnVubGluayhmZFBhdGhbMV0sIF9oYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGZpbGVzIHN5bmNocm9ub3VzbHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZkUGF0aFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZUZpbGVTeW5jKGZkUGF0aCkge1xuICBsZXQgcmV0aHJvd25FeGNlcHRpb24gPSBudWxsO1xuICB0cnkge1xuICAgIGlmICgwIDw9IGZkUGF0aFswXSkgZnMuY2xvc2VTeW5jKGZkUGF0aFswXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyByZXJhaXNlIGFueSB1bmFudGljaXBhdGVkIGVycm9yXG4gICAgaWYgKCFfaXNFQkFERihlKSAmJiAhX2lzRU5PRU5UKGUpKSB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBmcy51bmxpbmtTeW5jKGZkUGF0aFsxXSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAvLyByZXJhaXNlIGFueSB1bmFudGljaXBhdGVkIGVycm9yXG4gICAgICBpZiAoIV9pc0VOT0VOVChlKSkgcmV0aHJvd25FeGNlcHRpb24gPSBlO1xuICAgIH1cbiAgfVxuICBpZiAocmV0aHJvd25FeGNlcHRpb24gIT09IG51bGwpIHtcbiAgICB0aHJvdyByZXRocm93bkV4Y2VwdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIFByZXBhcmVzIHRoZSBjYWxsYmFjayBmb3IgcmVtb3ZhbCBvZiB0aGUgdGVtcG9yYXJ5IGZpbGUuXG4gKlxuICogUmV0dXJucyBlaXRoZXIgYSBzeW5jIGNhbGxiYWNrIG9yIGEgYXN5bmMgY2FsbGJhY2sgZGVwZW5kaW5nIG9uIHdoZXRoZXJcbiAqIGZpbGVTeW5jIG9yIGZpbGUgd2FzIGNhbGxlZCwgd2hpY2ggaXMgZXhwcmVzc2VkIGJ5IHRoZSBzeW5jIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcGF0aCBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1xuICogQHJldHVybnMge2ZpbGVDYWxsYmFjayB8IGZpbGVDYWxsYmFja1N5bmN9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBmZCwgb3B0cywgc3luYykge1xuICBjb25zdCByZW1vdmVDYWxsYmFja1N5bmMgPSBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKF9yZW1vdmVGaWxlU3luYywgW2ZkLCBuYW1lXSwgc3luYyk7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhfcmVtb3ZlRmlsZUFzeW5jLCBbZmQsIG5hbWVdLCBzeW5jLCByZW1vdmVDYWxsYmFja1N5bmMpO1xuXG4gIGlmICghb3B0cy5rZWVwKSBfcmVtb3ZlT2JqZWN0cy51bnNoaWZ0KHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgcmV0dXJuIHN5bmMgPyByZW1vdmVDYWxsYmFja1N5bmMgOiByZW1vdmVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyB0aGUgY2FsbGJhY2sgZm9yIHJlbW92YWwgb2YgdGhlIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gKlxuICogUmV0dXJucyBlaXRoZXIgYSBzeW5jIGNhbGxiYWNrIG9yIGEgYXN5bmMgY2FsbGJhY2sgZGVwZW5kaW5nIG9uIHdoZXRoZXJcbiAqIHRtcEZpbGVTeW5jIG9yIHRtcEZpbGUgd2FzIGNhbGxlZCwgd2hpY2ggaXMgZXhwcmVzc2VkIGJ5IHRoZSBzeW5jIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1xuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2sobmFtZSwgb3B0cywgc3luYykge1xuICBjb25zdCByZW1vdmVGdW5jdGlvbiA9IG9wdHMudW5zYWZlQ2xlYW51cCA/IHJpbXJhZiA6IGZzLnJtZGlyLmJpbmQoZnMpO1xuICBjb25zdCByZW1vdmVGdW5jdGlvblN5bmMgPSBvcHRzLnVuc2FmZUNsZWFudXAgPyBGTl9SSU1SQUZfU1lOQyA6IEZOX1JNRElSX1NZTkM7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrU3luYyA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb25TeW5jLCBuYW1lLCBzeW5jKTtcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKHJlbW92ZUZ1bmN0aW9uLCBuYW1lLCBzeW5jLCByZW1vdmVDYWxsYmFja1N5bmMpO1xuICBpZiAoIW9wdHMua2VlcCkgX3JlbW92ZU9iamVjdHMudW5zaGlmdChyZW1vdmVDYWxsYmFja1N5bmMpO1xuXG4gIHJldHVybiBzeW5jID8gcmVtb3ZlQ2FsbGJhY2tTeW5jIDogcmVtb3ZlQ2FsbGJhY2s7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGd1YXJkZWQgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHJlbW92ZUZ1bmN0aW9uIGNhbGwuXG4gKlxuICogVGhlIGNsZWFudXAgY2FsbGJhY2sgaXMgc2F2ZSB0byBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gKiBTdWJzZXF1ZW50IGludm9jYXRpb25zIHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZW1vdmVGdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVPckRpck5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1xuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2tTeW5jP30gY2xlYW51cENhbGxiYWNrU3luY1xuICogQHJldHVybnMge2NsZWFudXBDYWxsYmFjayB8IGNsZWFudXBDYWxsYmFja1N5bmN9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKHJlbW92ZUZ1bmN0aW9uLCBmaWxlT3JEaXJOYW1lLCBzeW5jLCBjbGVhbnVwQ2FsbGJhY2tTeW5jKSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAvLyBpZiBzeW5jIGlzIHRydWUsIHRoZSBuZXh0IHBhcmFtZXRlciB3aWxsIGJlIGlnbm9yZWRcbiAgcmV0dXJuIGZ1bmN0aW9uIF9jbGVhbnVwQ2FsbGJhY2sobmV4dCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgLy8gcmVtb3ZlIGNsZWFudXBDYWxsYmFjayBmcm9tIGNhY2hlXG4gICAgICBjb25zdCB0b1JlbW92ZSA9IGNsZWFudXBDYWxsYmFja1N5bmMgfHwgX2NsZWFudXBDYWxsYmFjaztcbiAgICAgIGNvbnN0IGluZGV4ID0gX3JlbW92ZU9iamVjdHMuaW5kZXhPZih0b1JlbW92ZSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGluZGV4ID49IDApIF9yZW1vdmVPYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBpZiAoc3luYyB8fCByZW1vdmVGdW5jdGlvbiA9PT0gRk5fUk1ESVJfU1lOQyB8fCByZW1vdmVGdW5jdGlvbiA9PT0gRk5fUklNUkFGX1NZTkMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUZ1bmN0aW9uKGZpbGVPckRpck5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUZ1bmN0aW9uKGZpbGVPckRpck5hbWUsIG5leHQgfHwgZnVuY3Rpb24oKSB7fSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFRoZSBnYXJiYWdlIGNvbGxlY3Rvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2FyYmFnZUNvbGxlY3RvcigpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfZ3JhY2VmdWxDbGVhbnVwKSByZXR1cm47XG5cbiAgLy8gdGhlIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCByZW1vdmVzIGl0c2VsZiBmcm9tIF9yZW1vdmVPYmplY3RzLFxuICAvLyBsb29wIHVudGlsIF9yZW1vdmVPYmplY3RzIGlzIGVtcHR5XG4gIHdoaWxlIChfcmVtb3ZlT2JqZWN0cy5sZW5ndGgpIHtcbiAgICB0cnkge1xuICAgICAgX3JlbW92ZU9iamVjdHNbMF0oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBhbHJlYWR5IHJlbW92ZWQ/XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmFuZG9tIG5hbWUgZ2VuZXJhdG9yIGJhc2VkIG9uIGNyeXB0by5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwOi8vYmxvZy50b21wYXdsYWsub3JnL2hvdy10by1nZW5lcmF0ZS1yYW5kb20tdmFsdWVzLW5vZGVqcy1qYXZhc2NyaXB0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGhvd01hbnlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBnZW5lcmF0ZWQgcmFuZG9tIG5hbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yYW5kb21DaGFycyhob3dNYW55KSB7XG4gIGxldFxuICAgIHZhbHVlID0gW10sXG4gICAgcm5kID0gbnVsbDtcblxuICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBkbyBub3QgZmFpbCBiZWNhdXNlIHdlIHJhbiBvdXQgb2YgZW50cm9weVxuICB0cnkge1xuICAgIHJuZCA9IGNyeXB0by5yYW5kb21CeXRlcyhob3dNYW55KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJuZCA9IGNyeXB0by5wc2V1ZG9SYW5kb21CeXRlcyhob3dNYW55KTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG93TWFueTsgaSsrKSB7XG4gICAgdmFsdWUucHVzaChSQU5ET01fQ0hBUlNbcm5kW2ldICUgUkFORE9NX0NIQVJTLmxlbmd0aF0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIEhlbHBlciB3aGljaCBkZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgcyBpcyBibGFuaywgdGhhdCBpcyB1bmRlZmluZWQsIG9yIGVtcHR5IG9yIG51bGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSB3aGV0aGVyIHRoZSBzdHJpbmcgcyBpcyBibGFuaywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIF9pc0JsYW5rKHMpIHtcbiAgcmV0dXJuIHMgPT09IG51bGwgfHwgX2lzVW5kZWZpbmVkKHMpIHx8ICFzLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgYG9iamAgcGFyYW1ldGVyIGlzIGRlZmluZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgdW5kZWZpbmVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhlbHBzIHRvIGhhdmUgb3B0aW9uYWwgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7KE9wdGlvbnN8bnVsbHx1bmRlZmluZWR8RnVuY3Rpb24pfSBvcHRpb25zXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtBcnJheX0gcGFyc2VkIGFyZ3VtZW50c1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBbe30sIG9wdGlvbnNdO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKF9pc1VuZGVmaW5lZChvcHRpb25zKSkge1xuICAgIHJldHVybiBbe30sIGNhbGxiYWNrXTtcbiAgfVxuXG4gIC8vIGNvcHkgb3B0aW9ucyBzbyB3ZSBkbyBub3QgbGVhayB0aGUgY2hhbmdlcyB3ZSBtYWtlIGludGVybmFsbHlcbiAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvcHRpb25zKSkge1xuICAgIGFjdHVhbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIHJldHVybiBbYWN0dWFsT3B0aW9ucywgY2FsbGJhY2tdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG5ldyB0ZW1wb3JhcnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIG5ldyByYW5kb20gbmFtZSBhY2NvcmRpbmcgdG8gb3B0c1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dlbmVyYXRlVG1wTmFtZShvcHRzKSB7XG5cbiAgY29uc3QgdG1wRGlyID0gb3B0cy50bXBkaXI7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0cy5uYW1lKSlcbiAgICByZXR1cm4gcGF0aC5qb2luKHRtcERpciwgb3B0cy5kaXIsIG9wdHMubmFtZSk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0cy50ZW1wbGF0ZSkpXG4gICAgcmV0dXJuIHBhdGguam9pbih0bXBEaXIsIG9wdHMuZGlyLCBvcHRzLnRlbXBsYXRlKS5yZXBsYWNlKFRFTVBMQVRFX1BBVFRFUk4sIF9yYW5kb21DaGFycyg2KSk7XG5cbiAgLy8gcHJlZml4IGFuZCBwb3N0Zml4XG4gIGNvbnN0IG5hbWUgPSBbXG4gICAgb3B0cy5wcmVmaXggPyBvcHRzLnByZWZpeCA6ICd0bXAnLFxuICAgICctJyxcbiAgICBwcm9jZXNzLnBpZCxcbiAgICAnLScsXG4gICAgX3JhbmRvbUNoYXJzKDEyKSxcbiAgICBvcHRzLnBvc3RmaXggPyAnLScgKyBvcHRzLnBvc3RmaXggOiAnJ1xuICBdLmpvaW4oJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4odG1wRGlyLCBvcHRzLmRpciwgbmFtZSk7XG59XG5cbi8qKlxuICogQXNzZXJ0cyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgb3B0aW9ucyBhcmUgdmFsaWQsIGFsc28gc2FuaXRpemVzIG9wdGlvbnMgYW5kIHByb3ZpZGVzIHNhbmUgZGVmYXVsdHMgZm9yIG1pc3NpbmdcbiAqIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfYXNzZXJ0QW5kU2FuaXRpemVPcHRpb25zKG9wdGlvbnMpIHtcblxuICBvcHRpb25zLnRtcGRpciA9IF9nZXRUbXBEaXIob3B0aW9ucyk7XG5cbiAgY29uc3QgdG1wRGlyID0gb3B0aW9ucy50bXBkaXI7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0aW9ucy5uYW1lKSlcbiAgICBfYXNzZXJ0SXNSZWxhdGl2ZShvcHRpb25zLm5hbWUsICduYW1lJywgdG1wRGlyKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0aW9ucy5kaXIpKVxuICAgIF9hc3NlcnRJc1JlbGF0aXZlKG9wdGlvbnMuZGlyLCAnZGlyJywgdG1wRGlyKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0aW9ucy50ZW1wbGF0ZSkpIHtcbiAgICBfYXNzZXJ0SXNSZWxhdGl2ZShvcHRpb25zLnRlbXBsYXRlLCAndGVtcGxhdGUnLCB0bXBEaXIpO1xuICAgIGlmICghb3B0aW9ucy50ZW1wbGF0ZS5tYXRjaChURU1QTEFURV9QQVRURVJOKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0ZW1wbGF0ZSwgZm91bmQgXCIke29wdGlvbnMudGVtcGxhdGV9XCIuYCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0aW9ucy50cmllcykgJiYgaXNOYU4ob3B0aW9ucy50cmllcykgfHwgb3B0aW9ucy50cmllcyA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRyaWVzLCBmb3VuZCBcIiR7b3B0aW9ucy50cmllc31cIi5gKTtcblxuICAvLyBpZiBhIG5hbWUgd2FzIHNwZWNpZmllZCB3ZSB3aWxsIHRyeSBvbmNlXG4gIG9wdGlvbnMudHJpZXMgPSBfaXNVbmRlZmluZWQob3B0aW9ucy5uYW1lKSA/IG9wdGlvbnMudHJpZXMgfHwgREVGQVVMVF9UUklFUyA6IDE7XG4gIG9wdGlvbnMua2VlcCA9ICEhb3B0aW9ucy5rZWVwO1xuICBvcHRpb25zLmRldGFjaERlc2NyaXB0b3IgPSAhIW9wdGlvbnMuZGV0YWNoRGVzY3JpcHRvcjtcbiAgb3B0aW9ucy5kaXNjYXJkRGVzY3JpcHRvciA9ICEhb3B0aW9ucy5kaXNjYXJkRGVzY3JpcHRvcjtcbiAgb3B0aW9ucy51bnNhZmVDbGVhbnVwID0gISFvcHRpb25zLnVuc2FmZUNsZWFudXA7XG5cbiAgLy8gc2FuaXRpemUgZGlyLCBhbHNvIGtlZXAgKG11bHRpcGxlKSBibGFua3MgaWYgdGhlIHVzZXIsIHB1cnBvcnRlZGx5IHNhbmUsIHJlcXVlc3RzIHVzIHRvXG4gIG9wdGlvbnMuZGlyID0gX2lzVW5kZWZpbmVkKG9wdGlvbnMuZGlyKSA/ICcnIDogcGF0aC5yZWxhdGl2ZSh0bXBEaXIsIF9yZXNvbHZlUGF0aChvcHRpb25zLmRpciwgdG1wRGlyKSk7XG4gIG9wdGlvbnMudGVtcGxhdGUgPSBfaXNVbmRlZmluZWQob3B0aW9ucy50ZW1wbGF0ZSkgPyB1bmRlZmluZWQgOiBwYXRoLnJlbGF0aXZlKHRtcERpciwgX3Jlc29sdmVQYXRoKG9wdGlvbnMudGVtcGxhdGUsIHRtcERpcikpO1xuICAvLyBzYW5pdGl6ZSBmdXJ0aGVyIGlmIHRlbXBsYXRlIGlzIHJlbGF0aXZlIHRvIG9wdGlvbnMuZGlyXG4gIG9wdGlvbnMudGVtcGxhdGUgPSBfaXNCbGFuayhvcHRpb25zLnRlbXBsYXRlKSA/IHVuZGVmaW5lZCA6IHBhdGgucmVsYXRpdmUob3B0aW9ucy5kaXIsIG9wdGlvbnMudGVtcGxhdGUpO1xuXG4gIC8vIGZvciBjb21wbGV0ZW5lc3MnIHNha2Ugb25seSwgYWxzbyBrZWVwIChtdWx0aXBsZSkgYmxhbmtzIGlmIHRoZSB1c2VyLCBwdXJwb3J0ZWRseSBzYW5lLCByZXF1ZXN0cyB1cyB0b1xuICBvcHRpb25zLm5hbWUgPSBfaXNVbmRlZmluZWQob3B0aW9ucy5uYW1lKSA/IHVuZGVmaW5lZCA6IF9zYW5pdGl6ZU5hbWUob3B0aW9ucy5uYW1lKTtcbiAgb3B0aW9ucy5wcmVmaXggPSBfaXNVbmRlZmluZWQob3B0aW9ucy5wcmVmaXgpID8gJycgOiBvcHRpb25zLnByZWZpeDtcbiAgb3B0aW9ucy5wb3N0Zml4ID0gX2lzVW5kZWZpbmVkKG9wdGlvbnMucG9zdGZpeCkgPyAnJyA6IG9wdGlvbnMucG9zdGZpeDtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBzcGVjaWZpZWQgcGF0aCBuYW1lIGluIHJlc3BlY3QgdG8gdG1wRGlyLlxuICpcbiAqIFRoZSBzcGVjaWZpZWQgbmFtZSBtaWdodCBpbmNsdWRlIHJlbGF0aXZlIHBhdGggY29tcG9uZW50cywgZS5nLiAuLi9cbiAqIHNvIHdlIG5lZWQgdG8gcmVzb2x2ZSBpbiBvcmRlciB0byBiZSBzdXJlIHRoYXQgaXMgaXMgbG9jYXRlZCBpbnNpZGUgdG1wRGlyXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqIEBwYXJhbSB0bXBEaXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVBhdGgobmFtZSwgdG1wRGlyKSB7XG4gIGNvbnN0IHNhbml0aXplZE5hbWUgPSBfc2FuaXRpemVOYW1lKG5hbWUpO1xuICBpZiAoc2FuaXRpemVkTmFtZS5zdGFydHNXaXRoKHRtcERpcikpIHtcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKHNhbml0aXplZE5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUocGF0aC5qb2luKHRtcERpciwgc2FuaXRpemVkTmFtZSkpO1xuICB9XG59XG5cbi8qKlxuICogU2FuaXRpemUgdGhlIHNwZWNpZmllZCBwYXRoIG5hbWUgYnkgcmVtb3ZpbmcgYWxsIHF1b3RlIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfc2FuaXRpemVOYW1lKG5hbWUpIHtcbiAgaWYgKF9pc0JsYW5rKG5hbWUpKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvW1wiJ10vZywgJycpO1xufVxuXG4vKipcbiAqIEFzc2VydHMgd2hldGhlciBzcGVjaWZpZWQgbmFtZSBpcyByZWxhdGl2ZSB0byB0aGUgc3BlY2lmaWVkIHRtcERpci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHRtcERpclxuICogQHRocm93cyB7RXJyb3J9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfYXNzZXJ0SXNSZWxhdGl2ZShuYW1lLCBvcHRpb24sIHRtcERpcikge1xuICBpZiAob3B0aW9uID09PSAnbmFtZScpIHtcbiAgICAvLyBhc3NlcnQgdGhhdCBuYW1lIGlzIG5vdCBhYnNvbHV0ZSBhbmQgZG9lcyBub3QgY29udGFpbiBhIHBhdGhcbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKG5hbWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3Qgbm90IGNvbnRhaW4gYW4gYWJzb2x1dGUgcGF0aCwgZm91bmQgXCIke25hbWV9XCIuYCk7XG4gICAgLy8gbXVzdCBub3QgZmFpbCBvbiB2YWxpZCAuPG5hbWU+IG9yIC4uPG5hbWU+IG9yIHNpbWlsYXIgc3VjaCBjb25zdHJ1Y3RzXG4gICAgbGV0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShuYW1lKTtcbiAgICBpZiAoYmFzZW5hbWUgPT09ICcuLicgfHwgYmFzZW5hbWUgPT09ICcuJyB8fCBiYXNlbmFtZSAhPT0gbmFtZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb259IG9wdGlvbiBtdXN0IG5vdCBjb250YWluIGEgcGF0aCwgZm91bmQgXCIke25hbWV9XCIuYCk7XG4gIH1cbiAgZWxzZSB7IC8vIGlmIChvcHRpb24gPT09ICdkaXInIHx8IG9wdGlvbiA9PT0gJ3RlbXBsYXRlJykge1xuICAgIC8vIGFzc2VydCB0aGF0IGRpciBvciB0ZW1wbGF0ZSBhcmUgcmVsYXRpdmUgdG8gdG1wRGlyXG4gICAgaWYgKHBhdGguaXNBYnNvbHV0ZShuYW1lKSAmJiAhbmFtZS5zdGFydHNXaXRoKHRtcERpcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb259IG9wdGlvbiBtdXN0IGJlIHJlbGF0aXZlIHRvIFwiJHt0bXBEaXJ9XCIsIGZvdW5kIFwiJHtuYW1lfVwiLmApO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRQYXRoID0gX3Jlc29sdmVQYXRoKG5hbWUsIHRtcERpcik7XG4gICAgaWYgKCFyZXNvbHZlZFBhdGguc3RhcnRzV2l0aCh0bXBEaXIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3QgYmUgcmVsYXRpdmUgdG8gXCIke3RtcERpcn1cIiwgZm91bmQgXCIke3Jlc29sdmVkUGF0aH1cIi5gKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgdGVzdGluZyBhZ2FpbnN0IEVCQURGIHRvIGNvbXBlbnNhdGUgY2hhbmdlcyBtYWRlIHRvIE5vZGUgNy54IHVuZGVyIFdpbmRvd3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzRUJBREYoZXJyb3IpIHtcbiAgcmV0dXJuIF9pc0V4cGVjdGVkRXJyb3IoZXJyb3IsIC1FQkFERiwgJ0VCQURGJyk7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciB0ZXN0aW5nIGFnYWluc3QgRU5PRU5UIHRvIGNvbXBlbnNhdGUgY2hhbmdlcyBtYWRlIHRvIE5vZGUgNy54IHVuZGVyIFdpbmRvd3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzRU5PRU5UKGVycm9yKSB7XG4gIHJldHVybiBfaXNFeHBlY3RlZEVycm9yKGVycm9yLCAtRU5PRU5ULCAnRU5PRU5UJyk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBleHBlY3RlZCBlcnJvciBjb2RlIG1hdGNoZXMgdGhlIGFjdHVhbCBjb2RlIGFuZCBlcnJubyxcbiAqIHdoaWNoIHdpbGwgZGlmZmVyIGJldHdlZW4gdGhlIHN1cHBvcnRlZCBub2RlIHZlcnNpb25zLlxuICpcbiAqIC0gTm9kZSA+PSA3LjA6XG4gKiAgIGVycm9yLmNvZGUge3N0cmluZ31cbiAqICAgZXJyb3IuZXJybm8ge251bWJlcn0gYW55IG51bWVyaWNhbCB2YWx1ZSB3aWxsIGJlIG5lZ2F0ZWRcbiAqXG4gKiBDQVZFQVRcbiAqXG4gKiBPbiB3aW5kb3dzLCB0aGUgZXJybm8gZm9yIEVCQURGIGlzIC00MDgzIGJ1dCBvcy5jb25zdGFudHMuZXJybm8uRUJBREYgaXMgZGlmZmVyZW50IGFuZCB3ZSBtdXN0IGFzc3VtZSB0aGF0IEVOT0VOVFxuICogaXMgbm8gZGlmZmVyZW50IGhlcmUuXG4gKlxuICogQHBhcmFtIHtTeXN0ZW1FcnJvcn0gZXJyb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJub1xuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc0V4cGVjdGVkRXJyb3IoZXJyb3IsIGVycm5vLCBjb2RlKSB7XG4gIHJldHVybiBJU19XSU4zMiA/IGVycm9yLmNvZGUgPT09IGNvZGUgOiBlcnJvci5jb2RlID09PSBjb2RlICYmIGVycm9yLmVycm5vID09PSBlcnJubztcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBncmFjZWZ1bCBjbGVhbnVwLlxuICpcbiAqIElmIGdyYWNlZnVsIGNsZWFudXAgaXMgc2V0LCB0bXAgd2lsbCByZW1vdmUgYWxsIGNvbnRyb2xsZWQgdGVtcG9yYXJ5IG9iamVjdHMgb24gcHJvY2VzcyBleGl0LCBvdGhlcndpc2UgdGhlXG4gKiB0ZW1wb3Jhcnkgb2JqZWN0cyB3aWxsIHJlbWFpbiBpbiBwbGFjZSwgd2FpdGluZyB0byBiZSBjbGVhbmVkIHVwIG9uIHN5c3RlbSByZXN0YXJ0IG9yIG90aGVyd2lzZSBzY2hlZHVsZWQgdGVtcG9yYXJ5XG4gKiBvYmplY3QgcmVtb3ZhbHMuXG4gKi9cbmZ1bmN0aW9uIHNldEdyYWNlZnVsQ2xlYW51cCgpIHtcbiAgX2dyYWNlZnVsQ2xlYW51cCA9IHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG1wIGRpciBmcm9tIG9zLnRtcGRpcigpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gez9PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG1wIGRpclxuICovXG5mdW5jdGlvbiBfZ2V0VG1wRGlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHBhdGgucmVzb2x2ZShfc2FuaXRpemVOYW1lKG9wdGlvbnMgJiYgb3B0aW9ucy50bXBkaXIgfHwgb3MudG1wZGlyKCkpKTtcbn1cblxuLy8gSW5zdGFsbCBwcm9jZXNzIGV4aXQgbGlzdGVuZXJcbnByb2Nlc3MuYWRkTGlzdGVuZXIoRVhJVCwgX2dhcmJhZ2VDb2xsZWN0b3IpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBrZWVwIHRoZSB0ZW1wb3Jhcnkgb2JqZWN0IChmaWxlIG9yIGRpcikgd2lsbCBub3QgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gdHJpZXMgdGhlIG51bWJlciBvZiB0cmllcyBiZWZvcmUgZ2l2ZSB1cCB0aGUgbmFtZSBnZW5lcmF0aW9uXG4gKiBAcHJvcGVydHkgKD9pbnQpIG1vZGUgdGhlIGFjY2VzcyBtb2RlLCBkZWZhdWx0cyBhcmUgMG83MDAgZm9yIGRpcmVjdG9yaWVzIGFuZCAwbzYwMCBmb3IgZmlsZXNcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdGVtcGxhdGUgdGhlIFwibWtzdGVtcFwiIGxpa2UgZmlsZW5hbWUgdGVtcGxhdGVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbmFtZSBmaXhlZCBuYW1lIHJlbGF0aXZlIHRvIHRtcGRpciBvciB0aGUgc3BlY2lmaWVkIGRpciBvcHRpb25cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gZGlyIHRtcCBkaXJlY3RvcnkgcmVsYXRpdmUgdG8gdGhlIHJvb3QgdG1wIGRpcmVjdG9yeSBpbiB1c2VcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcHJlZml4IHByZWZpeCBmb3IgdGhlIGdlbmVyYXRlZCBuYW1lXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHBvc3RmaXggcG9zdGZpeCBmb3IgdGhlIGdlbmVyYXRlZCBuYW1lXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHRtcGRpciB0aGUgcm9vdCB0bXAgZGlyZWN0b3J5IHdoaWNoIG92ZXJyaWRlcyB0aGUgb3MgdG1wZGlyXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSB1bnNhZmVDbGVhbnVwIHJlY3Vyc2l2ZWx5IHJlbW92ZXMgdGhlIGNyZWF0ZWQgdGVtcG9yYXJ5IGRpcmVjdG9yeSwgZXZlbiB3aGVuIGl0J3Mgbm90IGVtcHR5XG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBkZXRhY2hEZXNjcmlwdG9yIGRldGFjaGVzIHRoZSBmaWxlIGRlc2NyaXB0b3IsIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgY2xvc2luZyB0aGUgZmlsZSwgdG1wIHdpbGwgbm8gbG9uZ2VyIHRyeSBjbG9zaW5nIHRoZSBmaWxlIGR1cmluZyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGRpc2NhcmREZXNjcmlwdG9yIGRpc2NhcmRzIHRoZSBmaWxlIGRlc2NyaXB0b3IgKGNsb3NlcyBmaWxlLCBmZCBpcyAtMSksIHRtcCB3aWxsIG5vIGxvbmdlciB0cnkgY2xvc2luZyB0aGUgZmlsZSBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxlU3luY09iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmZCB0aGUgZmlsZSBkZXNjcmlwdG9yIG9yIC0xIGlmIHRoZSBmZCBoYXMgYmVlbiBkaXNjYXJkZWRcbiAqIEBwcm9wZXJ0eSB7ZmlsZUNhbGxiYWNrfSByZW1vdmVDYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBmaWxlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEaXJTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5XG4gKiBAcHJvcGVydHkge2ZpbGVDYWxsYmFja30gcmVtb3ZlQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgZGlyZWN0b3J5XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgdG1wTmFtZUNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3Igb3IgLTEgaWYgdGhlIGZkIGhhZCBiZWVuIGRpc2NhcmRlZFxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2t9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZUNhbGxiYWNrU3luY1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgdGhlIGZpbGUgZGVzY3JpcHRvciBvciAtMSBpZiB0aGUgZmQgaGFkIGJlZW4gZGlzY2FyZGVkXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja1N5bmN9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZGlyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2t9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZGlyQ2FsbGJhY2tTeW5jXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrU3luY30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHRlbXBvcmFyeSBjcmVhdGVkIGZpbGUgb3IgZGlyZWN0b3J5LlxuICpcbiAqIEBjYWxsYmFjayBjbGVhbnVwQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c2ltcGxlQ2FsbGJhY2t9IFtuZXh0XSBmdW5jdGlvbiB0byBjYWxsIHdoZW5ldmVyIHRoZSB0bXAgb2JqZWN0IG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAqL1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHRlbXBvcmFyeSBjcmVhdGVkIGZpbGUgb3IgZGlyZWN0b3J5LlxuICpcbiAqIEBjYWxsYmFjayBjbGVhbnVwQ2FsbGJhY2tTeW5jXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgZnVuY3Rpb24gY29tcG9zaXRpb24uXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcmFzemkvbm9kZS10bXAvaXNzdWVzLzU3fHJhc3ppL25vZGUtdG1wIzU3fVxuICpcbiAqIEBjYWxsYmFjayBzaW1wbGVDYWxsYmFja1xuICovXG5cbi8vIGV4cG9ydGluZyBhbGwgdGhlIG5lZWRlZCBtZXRob2RzXG5cbi8vIGV2YWx1YXRlIF9nZXRUbXBEaXIoKSBsYXppbHksIG1haW5seSBmb3Igc2ltcGxpZnlpbmcgdGVzdGluZyBidXQgaXQgYWxzbyB3aWxsXG4vLyBhbGxvdyB1c2VycyB0byByZWNvbmZpZ3VyZSB0aGUgdGVtcG9yYXJ5IGRpcmVjdG9yeVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAndG1wZGlyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldFRtcERpcigpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMuZGlyID0gZGlyO1xubW9kdWxlLmV4cG9ydHMuZGlyU3luYyA9IGRpclN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLmZpbGUgPSBmaWxlO1xubW9kdWxlLmV4cG9ydHMuZmlsZVN5bmMgPSBmaWxlU3luYztcblxubW9kdWxlLmV4cG9ydHMudG1wTmFtZSA9IHRtcE5hbWU7XG5tb2R1bGUuZXhwb3J0cy50bXBOYW1lU3luYyA9IHRtcE5hbWVTeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRHcmFjZWZ1bENsZWFudXAgPSBzZXRHcmFjZWZ1bENsZWFudXA7XG4iXSwibmFtZXMiOlsiZnMiLCJyZXF1aXJlIiwib3MiLCJwYXRoIiwiY3J5cHRvIiwiX2MiLCJjb25zdGFudHMiLCJyaW1yYWYiLCJSQU5ET01fQ0hBUlMiLCJURU1QTEFURV9QQVRURVJOIiwiREVGQVVMVF9UUklFUyIsIkNSRUFURV9GTEFHUyIsIk9fQ1JFQVQiLCJPX0VYQ0wiLCJPX1JEV1IiLCJJU19XSU4zMiIsInBsYXRmb3JtIiwiRUJBREYiLCJlcnJubyIsIkVOT0VOVCIsIkRJUl9NT0RFIiwiRklMRV9NT0RFIiwiRVhJVCIsIl9yZW1vdmVPYmplY3RzIiwiRk5fUk1ESVJfU1lOQyIsInJtZGlyU3luYyIsImJpbmQiLCJGTl9SSU1SQUZfU1lOQyIsInN5bmMiLCJfZ3JhY2VmdWxDbGVhbnVwIiwidG1wTmFtZSIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImFyZ3MiLCJfcGFyc2VBcmd1bWVudHMiLCJvcHRzIiwiY2IiLCJfYXNzZXJ0QW5kU2FuaXRpemVPcHRpb25zIiwiZXJyIiwidHJpZXMiLCJfZ2V0VW5pcXVlTmFtZSIsIm5hbWUiLCJfZ2VuZXJhdGVUbXBOYW1lIiwic3RhdCIsIkVycm9yIiwidG1wTmFtZVN5bmMiLCJzdGF0U3luYyIsImUiLCJmaWxlIiwiX3RtcE5hbWVDcmVhdGVkIiwib3BlbiIsIm1vZGUiLCJfZmlsZUNyZWF0ZWQiLCJmZCIsImRpc2NhcmREZXNjcmlwdG9yIiwiY2xvc2UiLCJfZGlzY2FyZENhbGxiYWNrIiwicG9zc2libGVFcnIiLCJ1bmRlZmluZWQiLCJfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayIsImRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IiLCJkZXRhY2hEZXNjcmlwdG9yIiwiZmlsZVN5bmMiLCJvcGVuU3luYyIsImNsb3NlU3luYyIsInJlbW92ZUNhbGxiYWNrIiwiZGlyIiwibWtkaXIiLCJfZGlyQ3JlYXRlZCIsIl9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2siLCJkaXJTeW5jIiwibWtkaXJTeW5jIiwiX3JlbW92ZUZpbGVBc3luYyIsImZkUGF0aCIsIm5leHQiLCJfaGFuZGxlciIsIl9pc0VOT0VOVCIsInVubGluayIsIl9yZW1vdmVGaWxlU3luYyIsInJldGhyb3duRXhjZXB0aW9uIiwiX2lzRUJBREYiLCJ1bmxpbmtTeW5jIiwicmVtb3ZlQ2FsbGJhY2tTeW5jIiwiX3ByZXBhcmVSZW1vdmVDYWxsYmFjayIsImtlZXAiLCJ1bnNoaWZ0IiwicmVtb3ZlRnVuY3Rpb24iLCJ1bnNhZmVDbGVhbnVwIiwicm1kaXIiLCJyZW1vdmVGdW5jdGlvblN5bmMiLCJmaWxlT3JEaXJOYW1lIiwiY2xlYW51cENhbGxiYWNrU3luYyIsImNhbGxlZCIsIl9jbGVhbnVwQ2FsbGJhY2siLCJ0b1JlbW92ZSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsIl9nYXJiYWdlQ29sbGVjdG9yIiwibGVuZ3RoIiwiX3JhbmRvbUNoYXJzIiwiaG93TWFueSIsInZhbHVlIiwicm5kIiwicmFuZG9tQnl0ZXMiLCJwc2V1ZG9SYW5kb21CeXRlcyIsImkiLCJwdXNoIiwiam9pbiIsIl9pc0JsYW5rIiwicyIsIl9pc1VuZGVmaW5lZCIsInRyaW0iLCJvYmoiLCJhY3R1YWxPcHRpb25zIiwia2V5IiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRtcERpciIsInRtcGRpciIsInRlbXBsYXRlIiwicmVwbGFjZSIsInByZWZpeCIsInByb2Nlc3MiLCJwaWQiLCJwb3N0Zml4IiwiX2dldFRtcERpciIsIl9hc3NlcnRJc1JlbGF0aXZlIiwibWF0Y2giLCJpc05hTiIsInJlbGF0aXZlIiwiX3Jlc29sdmVQYXRoIiwiX3Nhbml0aXplTmFtZSIsInNhbml0aXplZE5hbWUiLCJzdGFydHNXaXRoIiwicmVzb2x2ZSIsIm9wdGlvbiIsImlzQWJzb2x1dGUiLCJiYXNlbmFtZSIsInJlc29sdmVkUGF0aCIsImVycm9yIiwiX2lzRXhwZWN0ZWRFcnJvciIsImNvZGUiLCJzZXRHcmFjZWZ1bENsZWFudXAiLCJhZGRMaXN0ZW5lciIsImRlZmluZVByb3BlcnR5IiwibW9kdWxlIiwiZXhwb3J0cyIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tmp/lib/tmp.js\n");

/***/ })

};
;