/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rimraf";
exports.ids = ["vendor-chunks/rimraf"];
exports.modules = {

/***/ "(ssr)/./node_modules/rimraf/rimraf.js":
/*!***************************************!*\
  !*** ./node_modules/rimraf/rimraf.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nlet glob = undefined;\ntry {\n    glob = __webpack_require__(/*! glob */ \"(ssr)/./node_modules/glob/glob.js\");\n} catch (_err) {\n// treat glob as optional.\n}\nconst defaultGlobOpts = {\n    nosort: true,\n    silent: true\n};\n// for EMFILE handling\nlet timeout = 0;\nconst isWindows = process.platform === \"win32\";\nconst defaults = (options)=>{\n    const methods = [\n        \"unlink\",\n        \"chmod\",\n        \"stat\",\n        \"lstat\",\n        \"rmdir\",\n        \"readdir\"\n    ];\n    methods.forEach((m)=>{\n        options[m] = options[m] || fs[m];\n        m = m + \"Sync\";\n        options[m] = options[m] || fs[m];\n    });\n    options.maxBusyTries = options.maxBusyTries || 3;\n    options.emfileWait = options.emfileWait || 1000;\n    if (options.glob === false) {\n        options.disableGlob = true;\n    }\n    if (options.disableGlob !== true && glob === undefined) {\n        throw Error(\"glob dependency not found, set `options.disableGlob = true` if intentional\");\n    }\n    options.disableGlob = options.disableGlob || false;\n    options.glob = options.glob || defaultGlobOpts;\n};\nconst rimraf = (p, options, cb)=>{\n    if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n    }\n    assert(p, \"rimraf: missing path\");\n    assert.equal(typeof p, \"string\", \"rimraf: path should be a string\");\n    assert.equal(typeof cb, \"function\", \"rimraf: callback function required\");\n    assert(options, \"rimraf: invalid options argument provided\");\n    assert.equal(typeof options, \"object\", \"rimraf: options should be object\");\n    defaults(options);\n    let busyTries = 0;\n    let errState = null;\n    let n = 0;\n    const next = (er)=>{\n        errState = errState || er;\n        if (--n === 0) cb(errState);\n    };\n    const afterGlob = (er, results)=>{\n        if (er) return cb(er);\n        n = results.length;\n        if (n === 0) return cb();\n        results.forEach((p)=>{\n            const CB = (er)=>{\n                if (er) {\n                    if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") && busyTries < options.maxBusyTries) {\n                        busyTries++;\n                        // try again, with the same exact callback as this one.\n                        return setTimeout(()=>rimraf_(p, options, CB), busyTries * 100);\n                    }\n                    // this one won't happen if graceful-fs is used.\n                    if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n                        return setTimeout(()=>rimraf_(p, options, CB), timeout++);\n                    }\n                    // already gone\n                    if (er.code === \"ENOENT\") er = null;\n                }\n                timeout = 0;\n                next(er);\n            };\n            rimraf_(p, options, CB);\n        });\n    };\n    if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [\n        p\n    ]);\n    options.lstat(p, (er, stat)=>{\n        if (!er) return afterGlob(null, [\n            p\n        ]);\n        glob(p, options.glob, afterGlob);\n    });\n};\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nconst rimraf_ = (p, options, cb)=>{\n    assert(p);\n    assert(options);\n    assert(typeof cb === \"function\");\n    // sunos lets the root user unlink directories, which is... weird.\n    // so we have to lstat here and make sure it's not a dir.\n    options.lstat(p, (er, st)=>{\n        if (er && er.code === \"ENOENT\") return cb(null);\n        // Windows can EPERM on stat.  Life is suffering.\n        if (er && er.code === \"EPERM\" && isWindows) fixWinEPERM(p, options, er, cb);\n        if (st && st.isDirectory()) return rmdir(p, options, er, cb);\n        options.unlink(p, (er)=>{\n            if (er) {\n                if (er.code === \"ENOENT\") return cb(null);\n                if (er.code === \"EPERM\") return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);\n                if (er.code === \"EISDIR\") return rmdir(p, options, er, cb);\n            }\n            return cb(er);\n        });\n    });\n};\nconst fixWinEPERM = (p, options, er, cb)=>{\n    assert(p);\n    assert(options);\n    assert(typeof cb === \"function\");\n    options.chmod(p, 438, (er2)=>{\n        if (er2) cb(er2.code === \"ENOENT\" ? null : er);\n        else options.stat(p, (er3, stats)=>{\n            if (er3) cb(er3.code === \"ENOENT\" ? null : er);\n            else if (stats.isDirectory()) rmdir(p, options, er, cb);\n            else options.unlink(p, cb);\n        });\n    });\n};\nconst fixWinEPERMSync = (p, options, er)=>{\n    assert(p);\n    assert(options);\n    try {\n        options.chmodSync(p, 438);\n    } catch (er2) {\n        if (er2.code === \"ENOENT\") return;\n        else throw er;\n    }\n    let stats;\n    try {\n        stats = options.statSync(p);\n    } catch (er3) {\n        if (er3.code === \"ENOENT\") return;\n        else throw er;\n    }\n    if (stats.isDirectory()) rmdirSync(p, options, er);\n    else options.unlinkSync(p);\n};\nconst rmdir = (p, options, originalEr, cb)=>{\n    assert(p);\n    assert(options);\n    assert(typeof cb === \"function\");\n    // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n    // if we guessed wrong, and it's not a directory, then\n    // raise the original error.\n    options.rmdir(p, (er)=>{\n        if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")) rmkids(p, options, cb);\n        else if (er && er.code === \"ENOTDIR\") cb(originalEr);\n        else cb(er);\n    });\n};\nconst rmkids = (p, options, cb)=>{\n    assert(p);\n    assert(options);\n    assert(typeof cb === \"function\");\n    options.readdir(p, (er, files)=>{\n        if (er) return cb(er);\n        let n = files.length;\n        if (n === 0) return options.rmdir(p, cb);\n        let errState;\n        files.forEach((f)=>{\n            rimraf(path.join(p, f), options, (er)=>{\n                if (errState) return;\n                if (er) return cb(errState = er);\n                if (--n === 0) options.rmdir(p, cb);\n            });\n        });\n    });\n};\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nconst rimrafSync = (p, options)=>{\n    options = options || {};\n    defaults(options);\n    assert(p, \"rimraf: missing path\");\n    assert.equal(typeof p, \"string\", \"rimraf: path should be a string\");\n    assert(options, \"rimraf: missing options\");\n    assert.equal(typeof options, \"object\", \"rimraf: options should be object\");\n    let results;\n    if (options.disableGlob || !glob.hasMagic(p)) {\n        results = [\n            p\n        ];\n    } else {\n        try {\n            options.lstatSync(p);\n            results = [\n                p\n            ];\n        } catch (er) {\n            results = glob.sync(p, options.glob);\n        }\n    }\n    if (!results.length) return;\n    for(let i = 0; i < results.length; i++){\n        const p = results[i];\n        let st;\n        try {\n            st = options.lstatSync(p);\n        } catch (er) {\n            if (er.code === \"ENOENT\") return;\n            // Windows can EPERM on stat.  Life is suffering.\n            if (er.code === \"EPERM\" && isWindows) fixWinEPERMSync(p, options, er);\n        }\n        try {\n            // sunos lets the root user unlink directories, which is... weird.\n            if (st && st.isDirectory()) rmdirSync(p, options, null);\n            else options.unlinkSync(p);\n        } catch (er) {\n            if (er.code === \"ENOENT\") return;\n            if (er.code === \"EPERM\") return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);\n            if (er.code !== \"EISDIR\") throw er;\n            rmdirSync(p, options, er);\n        }\n    }\n};\nconst rmdirSync = (p, options, originalEr)=>{\n    assert(p);\n    assert(options);\n    try {\n        options.rmdirSync(p);\n    } catch (er) {\n        if (er.code === \"ENOENT\") return;\n        if (er.code === \"ENOTDIR\") throw originalEr;\n        if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\") rmkidsSync(p, options);\n    }\n};\nconst rmkidsSync = (p, options)=>{\n    assert(p);\n    assert(options);\n    options.readdirSync(p).forEach((f)=>rimrafSync(path.join(p, f), options));\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const retries = isWindows ? 100 : 1;\n    let i = 0;\n    do {\n        let threw = true;\n        try {\n            const ret = options.rmdirSync(p, options);\n            threw = false;\n            return ret;\n        } finally{\n            if (++i < retries && threw) continue;\n        }\n    }while (true);\n};\nmodule.exports = rimraf;\nrimraf.sync = rimrafSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmltcmFmL3JpbXJhZi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUMvQixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNRSxLQUFLRixtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLElBQUlHLE9BQU9DO0FBQ1gsSUFBSTtJQUNGRCxPQUFPSCxtQkFBT0EsQ0FBQywrQ0FBTTtBQUN2QixFQUFFLE9BQU9LLE1BQU07QUFDYiwwQkFBMEI7QUFDNUI7QUFFQSxNQUFNQyxrQkFBa0I7SUFDdEJDLFFBQVE7SUFDUkMsUUFBUTtBQUNWO0FBRUEsc0JBQXNCO0FBQ3RCLElBQUlDLFVBQVU7QUFFZCxNQUFNQyxZQUFhQyxRQUFRQyxRQUFRLEtBQUs7QUFFeEMsTUFBTUMsV0FBV0MsQ0FBQUE7SUFDZixNQUFNQyxVQUFVO1FBQ2Q7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDREEsUUFBUUMsT0FBTyxDQUFDQyxDQUFBQTtRQUNkSCxPQUFPLENBQUNHLEVBQUUsR0FBR0gsT0FBTyxDQUFDRyxFQUFFLElBQUlmLEVBQUUsQ0FBQ2UsRUFBRTtRQUNoQ0EsSUFBSUEsSUFBSTtRQUNSSCxPQUFPLENBQUNHLEVBQUUsR0FBR0gsT0FBTyxDQUFDRyxFQUFFLElBQUlmLEVBQUUsQ0FBQ2UsRUFBRTtJQUNsQztJQUVBSCxRQUFRSSxZQUFZLEdBQUdKLFFBQVFJLFlBQVksSUFBSTtJQUMvQ0osUUFBUUssVUFBVSxHQUFHTCxRQUFRSyxVQUFVLElBQUk7SUFDM0MsSUFBSUwsUUFBUVgsSUFBSSxLQUFLLE9BQU87UUFDMUJXLFFBQVFNLFdBQVcsR0FBRztJQUN4QjtJQUNBLElBQUlOLFFBQVFNLFdBQVcsS0FBSyxRQUFRakIsU0FBU0MsV0FBVztRQUN0RCxNQUFNaUIsTUFBTTtJQUNkO0lBQ0FQLFFBQVFNLFdBQVcsR0FBR04sUUFBUU0sV0FBVyxJQUFJO0lBQzdDTixRQUFRWCxJQUFJLEdBQUdXLFFBQVFYLElBQUksSUFBSUc7QUFDakM7QUFFQSxNQUFNZ0IsU0FBUyxDQUFDQyxHQUFHVCxTQUFTVTtJQUMxQixJQUFJLE9BQU9WLFlBQVksWUFBWTtRQUNqQ1UsS0FBS1Y7UUFDTEEsVUFBVSxDQUFDO0lBQ2I7SUFFQWYsT0FBT3dCLEdBQUc7SUFDVnhCLE9BQU8wQixLQUFLLENBQUMsT0FBT0YsR0FBRyxVQUFVO0lBQ2pDeEIsT0FBTzBCLEtBQUssQ0FBQyxPQUFPRCxJQUFJLFlBQVk7SUFDcEN6QixPQUFPZSxTQUFTO0lBQ2hCZixPQUFPMEIsS0FBSyxDQUFDLE9BQU9YLFNBQVMsVUFBVTtJQUV2Q0QsU0FBU0M7SUFFVCxJQUFJWSxZQUFZO0lBQ2hCLElBQUlDLFdBQVc7SUFDZixJQUFJQyxJQUFJO0lBRVIsTUFBTUMsT0FBTyxDQUFDQztRQUNaSCxXQUFXQSxZQUFZRztRQUN2QixJQUFJLEVBQUVGLE1BQU0sR0FDVkosR0FBR0c7SUFDUDtJQUVBLE1BQU1JLFlBQVksQ0FBQ0QsSUFBSUU7UUFDckIsSUFBSUYsSUFDRixPQUFPTixHQUFHTTtRQUVaRixJQUFJSSxRQUFRQyxNQUFNO1FBQ2xCLElBQUlMLE1BQU0sR0FDUixPQUFPSjtRQUVUUSxRQUFRaEIsT0FBTyxDQUFDTyxDQUFBQTtZQUNkLE1BQU1XLEtBQUssQ0FBQ0o7Z0JBQ1YsSUFBSUEsSUFBSTtvQkFDTixJQUFJLENBQUNBLEdBQUdLLElBQUksS0FBSyxXQUFXTCxHQUFHSyxJQUFJLEtBQUssZUFBZUwsR0FBR0ssSUFBSSxLQUFLLE9BQU0sS0FDckVULFlBQVlaLFFBQVFJLFlBQVksRUFBRTt3QkFDcENRO3dCQUNBLHVEQUF1RDt3QkFDdkQsT0FBT1UsV0FBVyxJQUFNQyxRQUFRZCxHQUFHVCxTQUFTb0IsS0FBS1IsWUFBWTtvQkFDL0Q7b0JBRUEsZ0RBQWdEO29CQUNoRCxJQUFJSSxHQUFHSyxJQUFJLEtBQUssWUFBWTFCLFVBQVVLLFFBQVFLLFVBQVUsRUFBRTt3QkFDeEQsT0FBT2lCLFdBQVcsSUFBTUMsUUFBUWQsR0FBR1QsU0FBU29CLEtBQUt6QjtvQkFDbkQ7b0JBRUEsZUFBZTtvQkFDZixJQUFJcUIsR0FBR0ssSUFBSSxLQUFLLFVBQVVMLEtBQUs7Z0JBQ2pDO2dCQUVBckIsVUFBVTtnQkFDVm9CLEtBQUtDO1lBQ1A7WUFDQU8sUUFBUWQsR0FBR1QsU0FBU29CO1FBQ3RCO0lBQ0Y7SUFFQSxJQUFJcEIsUUFBUU0sV0FBVyxJQUFJLENBQUNqQixLQUFLbUMsUUFBUSxDQUFDZixJQUN4QyxPQUFPUSxVQUFVLE1BQU07UUFBQ1I7S0FBRTtJQUU1QlQsUUFBUXlCLEtBQUssQ0FBQ2hCLEdBQUcsQ0FBQ08sSUFBSVU7UUFDcEIsSUFBSSxDQUFDVixJQUNILE9BQU9DLFVBQVUsTUFBTTtZQUFDUjtTQUFFO1FBRTVCcEIsS0FBS29CLEdBQUdULFFBQVFYLElBQUksRUFBRTRCO0lBQ3hCO0FBRUY7QUFFQSwyQkFBMkI7QUFDM0IsOEVBQThFO0FBQzlFLDBFQUEwRTtBQUMxRSxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHdFQUF3RTtBQUN4RSxvRUFBb0U7QUFDcEUscUJBQXFCO0FBQ3JCLEVBQUU7QUFDRix1RUFBdUU7QUFDdkUsd0RBQXdEO0FBQ3hELE1BQU1NLFVBQVUsQ0FBQ2QsR0FBR1QsU0FBU1U7SUFDM0J6QixPQUFPd0I7SUFDUHhCLE9BQU9lO0lBQ1BmLE9BQU8sT0FBT3lCLE9BQU87SUFFckIsa0VBQWtFO0lBQ2xFLHlEQUF5RDtJQUN6RFYsUUFBUXlCLEtBQUssQ0FBQ2hCLEdBQUcsQ0FBQ08sSUFBSVc7UUFDcEIsSUFBSVgsTUFBTUEsR0FBR0ssSUFBSSxLQUFLLFVBQ3BCLE9BQU9YLEdBQUc7UUFFWixpREFBaUQ7UUFDakQsSUFBSU0sTUFBTUEsR0FBR0ssSUFBSSxLQUFLLFdBQVd6QixXQUMvQmdDLFlBQVluQixHQUFHVCxTQUFTZ0IsSUFBSU47UUFFOUIsSUFBSWlCLE1BQU1BLEdBQUdFLFdBQVcsSUFDdEIsT0FBT0MsTUFBTXJCLEdBQUdULFNBQVNnQixJQUFJTjtRQUUvQlYsUUFBUStCLE1BQU0sQ0FBQ3RCLEdBQUdPLENBQUFBO1lBQ2hCLElBQUlBLElBQUk7Z0JBQ04sSUFBSUEsR0FBR0ssSUFBSSxLQUFLLFVBQ2QsT0FBT1gsR0FBRztnQkFDWixJQUFJTSxHQUFHSyxJQUFJLEtBQUssU0FDZCxPQUFPLFlBQ0hPLFlBQVluQixHQUFHVCxTQUFTZ0IsSUFBSU4sTUFDNUJvQixNQUFNckIsR0FBR1QsU0FBU2dCLElBQUlOO2dCQUM1QixJQUFJTSxHQUFHSyxJQUFJLEtBQUssVUFDZCxPQUFPUyxNQUFNckIsR0FBR1QsU0FBU2dCLElBQUlOO1lBQ2pDO1lBQ0EsT0FBT0EsR0FBR007UUFDWjtJQUNGO0FBQ0Y7QUFFQSxNQUFNWSxjQUFjLENBQUNuQixHQUFHVCxTQUFTZ0IsSUFBSU47SUFDbkN6QixPQUFPd0I7SUFDUHhCLE9BQU9lO0lBQ1BmLE9BQU8sT0FBT3lCLE9BQU87SUFFckJWLFFBQVFnQyxLQUFLLENBQUN2QixHQUFHLEtBQU93QixDQUFBQTtRQUN0QixJQUFJQSxLQUNGdkIsR0FBR3VCLElBQUlaLElBQUksS0FBSyxXQUFXLE9BQU9MO2FBRWxDaEIsUUFBUTBCLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQ3lCLEtBQUtDO1lBQ3BCLElBQUlELEtBQ0Z4QixHQUFHd0IsSUFBSWIsSUFBSSxLQUFLLFdBQVcsT0FBT0w7aUJBQy9CLElBQUltQixNQUFNTixXQUFXLElBQ3hCQyxNQUFNckIsR0FBR1QsU0FBU2dCLElBQUlOO2lCQUV0QlYsUUFBUStCLE1BQU0sQ0FBQ3RCLEdBQUdDO1FBQ3RCO0lBQ0o7QUFDRjtBQUVBLE1BQU0wQixrQkFBa0IsQ0FBQzNCLEdBQUdULFNBQVNnQjtJQUNuQy9CLE9BQU93QjtJQUNQeEIsT0FBT2U7SUFFUCxJQUFJO1FBQ0ZBLFFBQVFxQyxTQUFTLENBQUM1QixHQUFHO0lBQ3ZCLEVBQUUsT0FBT3dCLEtBQUs7UUFDWixJQUFJQSxJQUFJWixJQUFJLEtBQUssVUFDZjthQUVBLE1BQU1MO0lBQ1Y7SUFFQSxJQUFJbUI7SUFDSixJQUFJO1FBQ0ZBLFFBQVFuQyxRQUFRc0MsUUFBUSxDQUFDN0I7SUFDM0IsRUFBRSxPQUFPeUIsS0FBSztRQUNaLElBQUlBLElBQUliLElBQUksS0FBSyxVQUNmO2FBRUEsTUFBTUw7SUFDVjtJQUVBLElBQUltQixNQUFNTixXQUFXLElBQ25CVSxVQUFVOUIsR0FBR1QsU0FBU2dCO1NBRXRCaEIsUUFBUXdDLFVBQVUsQ0FBQy9CO0FBQ3ZCO0FBRUEsTUFBTXFCLFFBQVEsQ0FBQ3JCLEdBQUdULFNBQVN5QyxZQUFZL0I7SUFDckN6QixPQUFPd0I7SUFDUHhCLE9BQU9lO0lBQ1BmLE9BQU8sT0FBT3lCLE9BQU87SUFFckIsc0VBQXNFO0lBQ3RFLHNEQUFzRDtJQUN0RCw0QkFBNEI7SUFDNUJWLFFBQVE4QixLQUFLLENBQUNyQixHQUFHTyxDQUFBQTtRQUNmLElBQUlBLE1BQU9BLENBQUFBLEdBQUdLLElBQUksS0FBSyxlQUFlTCxHQUFHSyxJQUFJLEtBQUssWUFBWUwsR0FBR0ssSUFBSSxLQUFLLE9BQU0sR0FDOUVxQixPQUFPakMsR0FBR1QsU0FBU1U7YUFDaEIsSUFBSU0sTUFBTUEsR0FBR0ssSUFBSSxLQUFLLFdBQ3pCWCxHQUFHK0I7YUFFSC9CLEdBQUdNO0lBQ1A7QUFDRjtBQUVBLE1BQU0wQixTQUFTLENBQUNqQyxHQUFHVCxTQUFTVTtJQUMxQnpCLE9BQU93QjtJQUNQeEIsT0FBT2U7SUFDUGYsT0FBTyxPQUFPeUIsT0FBTztJQUVyQlYsUUFBUTJDLE9BQU8sQ0FBQ2xDLEdBQUcsQ0FBQ08sSUFBSTRCO1FBQ3RCLElBQUk1QixJQUNGLE9BQU9OLEdBQUdNO1FBQ1osSUFBSUYsSUFBSThCLE1BQU16QixNQUFNO1FBQ3BCLElBQUlMLE1BQU0sR0FDUixPQUFPZCxRQUFROEIsS0FBSyxDQUFDckIsR0FBR0M7UUFDMUIsSUFBSUc7UUFDSitCLE1BQU0xQyxPQUFPLENBQUMyQyxDQUFBQTtZQUNackMsT0FBT3JCLEtBQUsyRCxJQUFJLENBQUNyQyxHQUFHb0MsSUFBSTdDLFNBQVNnQixDQUFBQTtnQkFDL0IsSUFBSUgsVUFDRjtnQkFDRixJQUFJRyxJQUNGLE9BQU9OLEdBQUdHLFdBQVdHO2dCQUN2QixJQUFJLEVBQUVGLE1BQU0sR0FDVmQsUUFBUThCLEtBQUssQ0FBQ3JCLEdBQUdDO1lBQ3JCO1FBQ0Y7SUFDRjtBQUNGO0FBRUEseURBQXlEO0FBQ3pELHVEQUF1RDtBQUN2RCx3QkFBd0I7QUFDeEIsTUFBTXFDLGFBQWEsQ0FBQ3RDLEdBQUdUO0lBQ3JCQSxVQUFVQSxXQUFXLENBQUM7SUFDdEJELFNBQVNDO0lBRVRmLE9BQU93QixHQUFHO0lBQ1Z4QixPQUFPMEIsS0FBSyxDQUFDLE9BQU9GLEdBQUcsVUFBVTtJQUNqQ3hCLE9BQU9lLFNBQVM7SUFDaEJmLE9BQU8wQixLQUFLLENBQUMsT0FBT1gsU0FBUyxVQUFVO0lBRXZDLElBQUlrQjtJQUVKLElBQUlsQixRQUFRTSxXQUFXLElBQUksQ0FBQ2pCLEtBQUttQyxRQUFRLENBQUNmLElBQUk7UUFDNUNTLFVBQVU7WUFBQ1Q7U0FBRTtJQUNmLE9BQU87UUFDTCxJQUFJO1lBQ0ZULFFBQVFnRCxTQUFTLENBQUN2QztZQUNsQlMsVUFBVTtnQkFBQ1Q7YUFBRTtRQUNmLEVBQUUsT0FBT08sSUFBSTtZQUNYRSxVQUFVN0IsS0FBSzRELElBQUksQ0FBQ3hDLEdBQUdULFFBQVFYLElBQUk7UUFDckM7SUFDRjtJQUVBLElBQUksQ0FBQzZCLFFBQVFDLE1BQU0sRUFDakI7SUFFRixJQUFLLElBQUkrQixJQUFJLEdBQUdBLElBQUloQyxRQUFRQyxNQUFNLEVBQUUrQixJQUFLO1FBQ3ZDLE1BQU16QyxJQUFJUyxPQUFPLENBQUNnQyxFQUFFO1FBRXBCLElBQUl2QjtRQUNKLElBQUk7WUFDRkEsS0FBSzNCLFFBQVFnRCxTQUFTLENBQUN2QztRQUN6QixFQUFFLE9BQU9PLElBQUk7WUFDWCxJQUFJQSxHQUFHSyxJQUFJLEtBQUssVUFDZDtZQUVGLGlEQUFpRDtZQUNqRCxJQUFJTCxHQUFHSyxJQUFJLEtBQUssV0FBV3pCLFdBQ3pCd0MsZ0JBQWdCM0IsR0FBR1QsU0FBU2dCO1FBQ2hDO1FBRUEsSUFBSTtZQUNGLGtFQUFrRTtZQUNsRSxJQUFJVyxNQUFNQSxHQUFHRSxXQUFXLElBQ3RCVSxVQUFVOUIsR0FBR1QsU0FBUztpQkFFdEJBLFFBQVF3QyxVQUFVLENBQUMvQjtRQUN2QixFQUFFLE9BQU9PLElBQUk7WUFDWCxJQUFJQSxHQUFHSyxJQUFJLEtBQUssVUFDZDtZQUNGLElBQUlMLEdBQUdLLElBQUksS0FBSyxTQUNkLE9BQU96QixZQUFZd0MsZ0JBQWdCM0IsR0FBR1QsU0FBU2dCLE1BQU11QixVQUFVOUIsR0FBR1QsU0FBU2dCO1lBQzdFLElBQUlBLEdBQUdLLElBQUksS0FBSyxVQUNkLE1BQU1MO1lBRVJ1QixVQUFVOUIsR0FBR1QsU0FBU2dCO1FBQ3hCO0lBQ0Y7QUFDRjtBQUVBLE1BQU11QixZQUFZLENBQUM5QixHQUFHVCxTQUFTeUM7SUFDN0J4RCxPQUFPd0I7SUFDUHhCLE9BQU9lO0lBRVAsSUFBSTtRQUNGQSxRQUFRdUMsU0FBUyxDQUFDOUI7SUFDcEIsRUFBRSxPQUFPTyxJQUFJO1FBQ1gsSUFBSUEsR0FBR0ssSUFBSSxLQUFLLFVBQ2Q7UUFDRixJQUFJTCxHQUFHSyxJQUFJLEtBQUssV0FDZCxNQUFNb0I7UUFDUixJQUFJekIsR0FBR0ssSUFBSSxLQUFLLGVBQWVMLEdBQUdLLElBQUksS0FBSyxZQUFZTCxHQUFHSyxJQUFJLEtBQUssU0FDakU4QixXQUFXMUMsR0FBR1Q7SUFDbEI7QUFDRjtBQUVBLE1BQU1tRCxhQUFhLENBQUMxQyxHQUFHVDtJQUNyQmYsT0FBT3dCO0lBQ1B4QixPQUFPZTtJQUNQQSxRQUFRb0QsV0FBVyxDQUFDM0MsR0FBR1AsT0FBTyxDQUFDMkMsQ0FBQUEsSUFBS0UsV0FBVzVELEtBQUsyRCxJQUFJLENBQUNyQyxHQUFHb0MsSUFBSTdDO0lBRWhFLCtEQUErRDtJQUMvRCxpRUFBaUU7SUFDakUsbUVBQW1FO0lBQ25FLCtEQUErRDtJQUMvRCxpRUFBaUU7SUFDakUsNkRBQTZEO0lBQzdELE1BQU1xRCxVQUFVekQsWUFBWSxNQUFNO0lBQ2xDLElBQUlzRCxJQUFJO0lBQ1IsR0FBRztRQUNELElBQUlJLFFBQVE7UUFDWixJQUFJO1lBQ0YsTUFBTUMsTUFBTXZELFFBQVF1QyxTQUFTLENBQUM5QixHQUFHVDtZQUNqQ3NELFFBQVE7WUFDUixPQUFPQztRQUNULFNBQVU7WUFDUixJQUFJLEVBQUVMLElBQUlHLFdBQVdDLE9BQ25CO1FBQ0o7SUFDRixRQUFTLE1BQUs7QUFDaEI7QUFFQUUsT0FBT0MsT0FBTyxHQUFHakQ7QUFDakJBLE9BQU95QyxJQUFJLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2QtdGltZXNoZWV0LWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL3JpbXJhZi9yaW1yYWYuanM/MmE0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIilcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpXG5sZXQgZ2xvYiA9IHVuZGVmaW5lZFxudHJ5IHtcbiAgZ2xvYiA9IHJlcXVpcmUoXCJnbG9iXCIpXG59IGNhdGNoIChfZXJyKSB7XG4gIC8vIHRyZWF0IGdsb2IgYXMgb3B0aW9uYWwuXG59XG5cbmNvbnN0IGRlZmF1bHRHbG9iT3B0cyA9IHtcbiAgbm9zb3J0OiB0cnVlLFxuICBzaWxlbnQ6IHRydWVcbn1cblxuLy8gZm9yIEVNRklMRSBoYW5kbGluZ1xubGV0IHRpbWVvdXQgPSAwXG5cbmNvbnN0IGlzV2luZG93cyA9IChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpXG5cbmNvbnN0IGRlZmF1bHRzID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IG1ldGhvZHMgPSBbXG4gICAgJ3VubGluaycsXG4gICAgJ2NobW9kJyxcbiAgICAnc3RhdCcsXG4gICAgJ2xzdGF0JyxcbiAgICAncm1kaXInLFxuICAgICdyZWFkZGlyJ1xuICBdXG4gIG1ldGhvZHMuZm9yRWFjaChtID0+IHtcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICAgIG0gPSBtICsgJ1N5bmMnXG4gICAgb3B0aW9uc1ttXSA9IG9wdGlvbnNbbV0gfHwgZnNbbV1cbiAgfSlcblxuICBvcHRpb25zLm1heEJ1c3lUcmllcyA9IG9wdGlvbnMubWF4QnVzeVRyaWVzIHx8IDNcbiAgb3B0aW9ucy5lbWZpbGVXYWl0ID0gb3B0aW9ucy5lbWZpbGVXYWl0IHx8IDEwMDBcbiAgaWYgKG9wdGlvbnMuZ2xvYiA9PT0gZmFsc2UpIHtcbiAgICBvcHRpb25zLmRpc2FibGVHbG9iID0gdHJ1ZVxuICB9XG4gIGlmIChvcHRpb25zLmRpc2FibGVHbG9iICE9PSB0cnVlICYmIGdsb2IgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IEVycm9yKCdnbG9iIGRlcGVuZGVuY3kgbm90IGZvdW5kLCBzZXQgYG9wdGlvbnMuZGlzYWJsZUdsb2IgPSB0cnVlYCBpZiBpbnRlbnRpb25hbCcpXG4gIH1cbiAgb3B0aW9ucy5kaXNhYmxlR2xvYiA9IG9wdGlvbnMuZGlzYWJsZUdsb2IgfHwgZmFsc2VcbiAgb3B0aW9ucy5nbG9iID0gb3B0aW9ucy5nbG9iIHx8IGRlZmF1bHRHbG9iT3B0c1xufVxuXG5jb25zdCByaW1yYWYgPSAocCwgb3B0aW9ucywgY2IpID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAncmltcmFmOiBjYWxsYmFjayBmdW5jdGlvbiByZXF1aXJlZCcpXG4gIGFzc2VydChvcHRpb25zLCAncmltcmFmOiBpbnZhbGlkIG9wdGlvbnMgYXJndW1lbnQgcHJvdmlkZWQnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIG9wdGlvbnMsICdvYmplY3QnLCAncmltcmFmOiBvcHRpb25zIHNob3VsZCBiZSBvYmplY3QnKVxuXG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgbGV0IGJ1c3lUcmllcyA9IDBcbiAgbGV0IGVyclN0YXRlID0gbnVsbFxuICBsZXQgbiA9IDBcblxuICBjb25zdCBuZXh0ID0gKGVyKSA9PiB7XG4gICAgZXJyU3RhdGUgPSBlcnJTdGF0ZSB8fCBlclxuICAgIGlmICgtLW4gPT09IDApXG4gICAgICBjYihlcnJTdGF0ZSlcbiAgfVxuXG4gIGNvbnN0IGFmdGVyR2xvYiA9IChlciwgcmVzdWx0cykgPT4ge1xuICAgIGlmIChlcilcbiAgICAgIHJldHVybiBjYihlcilcblxuICAgIG4gPSByZXN1bHRzLmxlbmd0aFxuICAgIGlmIChuID09PSAwKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIHJlc3VsdHMuZm9yRWFjaChwID0+IHtcbiAgICAgIGNvbnN0IENCID0gKGVyKSA9PiB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgIGlmICgoZXIuY29kZSA9PT0gXCJFQlVTWVwiIHx8IGVyLmNvZGUgPT09IFwiRU5PVEVNUFRZXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKSAmJlxuICAgICAgICAgICAgICBidXN5VHJpZXMgPCBvcHRpb25zLm1heEJ1c3lUcmllcykge1xuICAgICAgICAgICAgYnVzeVRyaWVzICsrXG4gICAgICAgICAgICAvLyB0cnkgYWdhaW4sIHdpdGggdGhlIHNhbWUgZXhhY3QgY2FsbGJhY2sgYXMgdGhpcyBvbmUuXG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiByaW1yYWZfKHAsIG9wdGlvbnMsIENCKSwgYnVzeVRyaWVzICogMTAwKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRoaXMgb25lIHdvbid0IGhhcHBlbiBpZiBncmFjZWZ1bC1mcyBpcyB1c2VkLlxuICAgICAgICAgIGlmIChlci5jb2RlID09PSBcIkVNRklMRVwiICYmIHRpbWVvdXQgPCBvcHRpb25zLmVtZmlsZVdhaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHJpbXJhZl8ocCwgb3B0aW9ucywgQ0IpLCB0aW1lb3V0ICsrKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFscmVhZHkgZ29uZVxuICAgICAgICAgIGlmIChlci5jb2RlID09PSBcIkVOT0VOVFwiKSBlciA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWVvdXQgPSAwXG4gICAgICAgIG5leHQoZXIpXG4gICAgICB9XG4gICAgICByaW1yYWZfKHAsIG9wdGlvbnMsIENCKVxuICAgIH0pXG4gIH1cblxuICBpZiAob3B0aW9ucy5kaXNhYmxlR2xvYiB8fCAhZ2xvYi5oYXNNYWdpYyhwKSlcbiAgICByZXR1cm4gYWZ0ZXJHbG9iKG51bGwsIFtwXSlcblxuICBvcHRpb25zLmxzdGF0KHAsIChlciwgc3RhdCkgPT4ge1xuICAgIGlmICghZXIpXG4gICAgICByZXR1cm4gYWZ0ZXJHbG9iKG51bGwsIFtwXSlcblxuICAgIGdsb2IocCwgb3B0aW9ucy5nbG9iLCBhZnRlckdsb2IpXG4gIH0pXG5cbn1cblxuLy8gVHdvIHBvc3NpYmxlIHN0cmF0ZWdpZXMuXG4vLyAxLiBBc3N1bWUgaXQncyBhIGZpbGUuICB1bmxpbmsgaXQsIHRoZW4gZG8gdGhlIGRpciBzdHVmZiBvbiBFUEVSTSBvciBFSVNESVJcbi8vIDIuIEFzc3VtZSBpdCdzIGEgZGlyZWN0b3J5LiAgcmVhZGRpciwgdGhlbiBkbyB0aGUgZmlsZSBzdHVmZiBvbiBFTk9URElSXG4vL1xuLy8gQm90aCByZXN1bHQgaW4gYW4gZXh0cmEgc3lzY2FsbCB3aGVuIHlvdSBndWVzcyB3cm9uZy4gIEhvd2V2ZXIsIHRoZXJlXG4vLyBhcmUgbGlrZWx5IGZhciBtb3JlIG5vcm1hbCBmaWxlcyBpbiB0aGUgd29ybGQgdGhhbiBkaXJlY3Rvcmllcy4gIFRoaXNcbi8vIGlzIGJhc2VkIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgYSB0aGUgYXZlcmFnZSBudW1iZXIgb2YgZmlsZXMgcGVyXG4vLyBkaXJlY3RvcnkgaXMgPj0gMS5cbi8vXG4vLyBJZiBhbnlvbmUgZXZlciBjb21wbGFpbnMgYWJvdXQgdGhpcywgdGhlbiBJIGd1ZXNzIHRoZSBzdHJhdGVneSBjb3VsZFxuLy8gYmUgbWFkZSBjb25maWd1cmFibGUgc29tZWhvdy4gIEJ1dCB1bnRpbCB0aGVuLCBZQUdOSS5cbmNvbnN0IHJpbXJhZl8gPSAocCwgb3B0aW9ucywgY2IpID0+IHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAvLyBzbyB3ZSBoYXZlIHRvIGxzdGF0IGhlcmUgYW5kIG1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpci5cbiAgb3B0aW9ucy5sc3RhdChwLCAoZXIsIHN0KSA9PiB7XG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICByZXR1cm4gY2IobnVsbClcblxuICAgIC8vIFdpbmRvd3MgY2FuIEVQRVJNIG9uIHN0YXQuICBMaWZlIGlzIHN1ZmZlcmluZy5cbiAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gXCJFUEVSTVwiICYmIGlzV2luZG93cylcbiAgICAgIGZpeFdpbkVQRVJNKHAsIG9wdGlvbnMsIGVyLCBjYilcblxuICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKVxuICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcblxuICAgIG9wdGlvbnMudW5saW5rKHAsIGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgICByZXR1cm4gKGlzV2luZG93cylcbiAgICAgICAgICAgID8gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICAgICAgOiBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIGlmIChlci5jb2RlID09PSBcIkVJU0RJUlwiKVxuICAgICAgICAgIHJldHVybiBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgfSlcbiAgfSlcbn1cblxuY29uc3QgZml4V2luRVBFUk0gPSAocCwgb3B0aW9ucywgZXIsIGNiKSA9PiB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBvcHRpb25zLmNobW9kKHAsIDBvNjY2LCBlcjIgPT4ge1xuICAgIGlmIChlcjIpXG4gICAgICBjYihlcjIuY29kZSA9PT0gXCJFTk9FTlRcIiA/IG51bGwgOiBlcilcbiAgICBlbHNlXG4gICAgICBvcHRpb25zLnN0YXQocCwgKGVyMywgc3RhdHMpID0+IHtcbiAgICAgICAgaWYgKGVyMylcbiAgICAgICAgICBjYihlcjMuY29kZSA9PT0gXCJFTk9FTlRcIiA/IG51bGwgOiBlcilcbiAgICAgICAgZWxzZSBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgICBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvcHRpb25zLnVubGluayhwLCBjYilcbiAgICAgIH0pXG4gIH0pXG59XG5cbmNvbnN0IGZpeFdpbkVQRVJNU3luYyA9IChwLCBvcHRpb25zLCBlcikgPT4ge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLmNobW9kU3luYyhwLCAwbzY2NilcbiAgfSBjYXRjaCAoZXIyKSB7XG4gICAgaWYgKGVyMi5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgcmV0dXJuXG4gICAgZWxzZVxuICAgICAgdGhyb3cgZXJcbiAgfVxuXG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gb3B0aW9ucy5zdGF0U3luYyhwKVxuICB9IGNhdGNoIChlcjMpIHtcbiAgICBpZiAoZXIzLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICByZXR1cm5cbiAgICBlbHNlXG4gICAgICB0aHJvdyBlclxuICB9XG5cbiAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpXG4gICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICBlbHNlXG4gICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG59XG5cbmNvbnN0IHJtZGlyID0gKHAsIG9wdGlvbnMsIG9yaWdpbmFsRXIsIGNiKSA9PiB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyB0cnkgdG8gcm1kaXIgZmlyc3QsIGFuZCBvbmx5IHJlYWRkaXIgb24gRU5PVEVNUFRZIG9yIEVFWElTVCAoU3VuT1MpXG4gIC8vIGlmIHdlIGd1ZXNzZWQgd3JvbmcsIGFuZCBpdCdzIG5vdCBhIGRpcmVjdG9yeSwgdGhlblxuICAvLyByYWlzZSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gIG9wdGlvbnMucm1kaXIocCwgZXIgPT4ge1xuICAgIGlmIChlciAmJiAoZXIuY29kZSA9PT0gXCJFTk9URU1QVFlcIiB8fCBlci5jb2RlID09PSBcIkVFWElTVFwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIikpXG4gICAgICBybWtpZHMocCwgb3B0aW9ucywgY2IpXG4gICAgZWxzZSBpZiAoZXIgJiYgZXIuY29kZSA9PT0gXCJFTk9URElSXCIpXG4gICAgICBjYihvcmlnaW5hbEVyKVxuICAgIGVsc2VcbiAgICAgIGNiKGVyKVxuICB9KVxufVxuXG5jb25zdCBybWtpZHMgPSAocCwgb3B0aW9ucywgY2IpID0+IHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIG9wdGlvbnMucmVhZGRpcihwLCAoZXIsIGZpbGVzKSA9PiB7XG4gICAgaWYgKGVyKVxuICAgICAgcmV0dXJuIGNiKGVyKVxuICAgIGxldCBuID0gZmlsZXMubGVuZ3RoXG4gICAgaWYgKG4gPT09IDApXG4gICAgICByZXR1cm4gb3B0aW9ucy5ybWRpcihwLCBjYilcbiAgICBsZXQgZXJyU3RhdGVcbiAgICBmaWxlcy5mb3JFYWNoKGYgPT4ge1xuICAgICAgcmltcmFmKHBhdGguam9pbihwLCBmKSwgb3B0aW9ucywgZXIgPT4ge1xuICAgICAgICBpZiAoZXJyU3RhdGUpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICByZXR1cm4gY2IoZXJyU3RhdGUgPSBlcilcbiAgICAgICAgaWYgKC0tbiA9PT0gMClcbiAgICAgICAgICBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyB0aGlzIGxvb2tzIHNpbXBsZXIsIGFuZCBpcyBzdHJpY3RseSAqZmFzdGVyKiwgYnV0IHdpbGxcbi8vIHRpZSB1cCB0aGUgSmF2YVNjcmlwdCB0aHJlYWQgYW5kIGZhaWwgb24gZXhjZXNzaXZlbHlcbi8vIGRlZXAgZGlyZWN0b3J5IHRyZWVzLlxuY29uc3QgcmltcmFmU3luYyA9IChwLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IG1pc3Npbmcgb3B0aW9ucycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgbGV0IHJlc3VsdHNcblxuICBpZiAob3B0aW9ucy5kaXNhYmxlR2xvYiB8fCAhZ2xvYi5oYXNNYWdpYyhwKSkge1xuICAgIHJlc3VsdHMgPSBbcF1cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucy5sc3RhdFN5bmMocClcbiAgICAgIHJlc3VsdHMgPSBbcF1cbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmVzdWx0cyA9IGdsb2Iuc3luYyhwLCBvcHRpb25zLmdsb2IpXG4gICAgfVxuICB9XG5cbiAgaWYgKCFyZXN1bHRzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwID0gcmVzdWx0c1tpXVxuXG4gICAgbGV0IHN0XG4gICAgdHJ5IHtcbiAgICAgIHN0ID0gb3B0aW9ucy5sc3RhdFN5bmMocClcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICAgIHJldHVyblxuXG4gICAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFUEVSTVwiICYmIGlzV2luZG93cylcbiAgICAgICAgZml4V2luRVBFUk1TeW5jKHAsIG9wdGlvbnMsIGVyKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKVxuICAgICAgICBybWRpclN5bmMocCwgb3B0aW9ucywgbnVsbClcbiAgICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICByZXR1cm5cbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgIHJldHVybiBpc1dpbmRvd3MgPyBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpIDogcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICAgICAgaWYgKGVyLmNvZGUgIT09IFwiRUlTRElSXCIpXG4gICAgICAgIHRocm93IGVyXG5cbiAgICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgcm1kaXJTeW5jID0gKHAsIG9wdGlvbnMsIG9yaWdpbmFsRXIpID0+IHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuXG4gIHRyeSB7XG4gICAgb3B0aW9ucy5ybWRpclN5bmMocClcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgIHJldHVyblxuICAgIGlmIChlci5jb2RlID09PSBcIkVOT1RESVJcIilcbiAgICAgIHRocm93IG9yaWdpbmFsRXJcbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9URU1QVFlcIiB8fCBlci5jb2RlID09PSBcIkVFWElTVFwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgIHJta2lkc1N5bmMocCwgb3B0aW9ucylcbiAgfVxufVxuXG5jb25zdCBybWtpZHNTeW5jID0gKHAsIG9wdGlvbnMpID0+IHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBvcHRpb25zLnJlYWRkaXJTeW5jKHApLmZvckVhY2goZiA9PiByaW1yYWZTeW5jKHBhdGguam9pbihwLCBmKSwgb3B0aW9ucykpXG5cbiAgLy8gV2Ugb25seSBlbmQgdXAgaGVyZSBvbmNlIHdlIGdvdCBFTk9URU1QVFkgYXQgbGVhc3Qgb25jZSwgYW5kXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHdlIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgcmVtb3ZlZCBhbGwgdGhlIGtpZHMuXG4gIC8vIFNvLCB3ZSBrbm93IHRoYXQgaXQgd29uJ3QgYmUgRU5PRU5UIG9yIEVOT1RESVIgb3IgYW55dGhpbmcgZWxzZS5cbiAgLy8gdHJ5IHJlYWxseSBoYXJkIHRvIGRlbGV0ZSBzdHVmZiBvbiB3aW5kb3dzLCBiZWNhdXNlIGl0IGhhcyBhXG4gIC8vIFBST0ZPVU5ETFkgYW5ub3lpbmcgaGFiaXQgb2Ygbm90IGNsb3NpbmcgaGFuZGxlcyBwcm9tcHRseSB3aGVuXG4gIC8vIGZpbGVzIGFyZSBkZWxldGVkLCByZXN1bHRpbmcgaW4gc3B1cmlvdXMgRU5PVEVNUFRZIGVycm9ycy5cbiAgY29uc3QgcmV0cmllcyA9IGlzV2luZG93cyA/IDEwMCA6IDFcbiAgbGV0IGkgPSAwXG4gIGRvIHtcbiAgICBsZXQgdGhyZXcgPSB0cnVlXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJldCA9IG9wdGlvbnMucm1kaXJTeW5jKHAsIG9wdGlvbnMpXG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICgrK2kgPCByZXRyaWVzICYmIHRocmV3KVxuICAgICAgICBjb250aW51ZVxuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByaW1yYWZcbnJpbXJhZi5zeW5jID0gcmltcmFmU3luY1xuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJwYXRoIiwiZnMiLCJnbG9iIiwidW5kZWZpbmVkIiwiX2VyciIsImRlZmF1bHRHbG9iT3B0cyIsIm5vc29ydCIsInNpbGVudCIsInRpbWVvdXQiLCJpc1dpbmRvd3MiLCJwcm9jZXNzIiwicGxhdGZvcm0iLCJkZWZhdWx0cyIsIm9wdGlvbnMiLCJtZXRob2RzIiwiZm9yRWFjaCIsIm0iLCJtYXhCdXN5VHJpZXMiLCJlbWZpbGVXYWl0IiwiZGlzYWJsZUdsb2IiLCJFcnJvciIsInJpbXJhZiIsInAiLCJjYiIsImVxdWFsIiwiYnVzeVRyaWVzIiwiZXJyU3RhdGUiLCJuIiwibmV4dCIsImVyIiwiYWZ0ZXJHbG9iIiwicmVzdWx0cyIsImxlbmd0aCIsIkNCIiwiY29kZSIsInNldFRpbWVvdXQiLCJyaW1yYWZfIiwiaGFzTWFnaWMiLCJsc3RhdCIsInN0YXQiLCJzdCIsImZpeFdpbkVQRVJNIiwiaXNEaXJlY3RvcnkiLCJybWRpciIsInVubGluayIsImNobW9kIiwiZXIyIiwiZXIzIiwic3RhdHMiLCJmaXhXaW5FUEVSTVN5bmMiLCJjaG1vZFN5bmMiLCJzdGF0U3luYyIsInJtZGlyU3luYyIsInVubGlua1N5bmMiLCJvcmlnaW5hbEVyIiwicm1raWRzIiwicmVhZGRpciIsImZpbGVzIiwiZiIsImpvaW4iLCJyaW1yYWZTeW5jIiwibHN0YXRTeW5jIiwic3luYyIsImkiLCJybWtpZHNTeW5jIiwicmVhZGRpclN5bmMiLCJyZXRyaWVzIiwidGhyZXciLCJyZXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rimraf/rimraf.js\n");

/***/ })

};
;