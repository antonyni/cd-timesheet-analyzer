/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/big-integer";
exports.ids = ["vendor-chunks/big-integer"];
exports.modules = {

/***/ "(ssr)/./node_modules/big-integer/BigInteger.js":
/*!************************************************!*\
  !*** ./node_modules/big-integer/BigInteger.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = function(undefined) {\n    \"use strict\";\n    var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    var supportsNativeBigInt = typeof BigInt === \"function\";\n    function Integer(v, radix, alphabet, caseSensitive) {\n        if (typeof v === \"undefined\") return Integer[0];\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\n        return parseValue(v);\n    }\n    function BigInteger(value, sign) {\n        this.value = value;\n        this.sign = sign;\n        this.isSmall = false;\n    }\n    BigInteger.prototype = Object.create(Integer.prototype);\n    function SmallInteger(value) {\n        this.value = value;\n        this.sign = value < 0;\n        this.isSmall = true;\n    }\n    SmallInteger.prototype = Object.create(Integer.prototype);\n    function NativeBigInt(value) {\n        this.value = value;\n    }\n    NativeBigInt.prototype = Object.create(Integer.prototype);\n    function isPrecise(n) {\n        return -MAX_INT < n && n < MAX_INT;\n    }\n    function smallToArray(n) {\n        if (n < 1e7) return [\n            n\n        ];\n        if (n < 1e14) return [\n            n % 1e7,\n            Math.floor(n / 1e7)\n        ];\n        return [\n            n % 1e7,\n            Math.floor(n / 1e7) % 1e7,\n            Math.floor(n / 1e14)\n        ];\n    }\n    function arrayToSmall(arr) {\n        trim(arr);\n        var length = arr.length;\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\n            switch(length){\n                case 0:\n                    return 0;\n                case 1:\n                    return arr[0];\n                case 2:\n                    return arr[0] + arr[1] * BASE;\n                default:\n                    return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\n            }\n        }\n        return arr;\n    }\n    function trim(v) {\n        var i = v.length;\n        while(v[--i] === 0);\n        v.length = i + 1;\n    }\n    function createArray(length) {\n        var x = new Array(length);\n        var i = -1;\n        while(++i < length){\n            x[i] = 0;\n        }\n        return x;\n    }\n    function truncate(n) {\n        if (n > 0) return Math.floor(n);\n        return Math.ceil(n);\n    }\n    function add(a, b) {\n        var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i;\n        for(i = 0; i < l_b; i++){\n            sum = a[i] + b[i] + carry;\n            carry = sum >= base ? 1 : 0;\n            r[i] = sum - carry * base;\n        }\n        while(i < l_a){\n            sum = a[i] + carry;\n            carry = sum === base ? 1 : 0;\n            r[i++] = sum - carry * base;\n        }\n        if (carry > 0) r.push(carry);\n        return r;\n    }\n    function addAny(a, b) {\n        if (a.length >= b.length) return add(a, b);\n        return add(b, a);\n    }\n    function addSmall(a, carry) {\n        var l = a.length, r = new Array(l), base = BASE, sum, i;\n        for(i = 0; i < l; i++){\n            sum = a[i] - base + carry;\n            carry = Math.floor(sum / base);\n            r[i] = sum - carry * base;\n            carry += 1;\n        }\n        while(carry > 0){\n            r[i++] = carry % base;\n            carry = Math.floor(carry / base);\n        }\n        return r;\n    }\n    BigInteger.prototype.add = function(v) {\n        var n = parseValue(v);\n        if (this.sign !== n.sign) {\n            return this.subtract(n.negate());\n        }\n        var a = this.value, b = n.value;\n        if (n.isSmall) {\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\n        }\n        return new BigInteger(addAny(a, b), this.sign);\n    };\n    BigInteger.prototype.plus = BigInteger.prototype.add;\n    SmallInteger.prototype.add = function(v) {\n        var n = parseValue(v);\n        var a = this.value;\n        if (a < 0 !== n.sign) {\n            return this.subtract(n.negate());\n        }\n        var b = n.value;\n        if (n.isSmall) {\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\n            b = smallToArray(Math.abs(b));\n        }\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\n    };\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\n    NativeBigInt.prototype.add = function(v) {\n        return new NativeBigInt(this.value + parseValue(v).value);\n    };\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\n    function subtract(a, b) {\n        var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i, difference;\n        for(i = 0; i < b_l; i++){\n            difference = a[i] - borrow - b[i];\n            if (difference < 0) {\n                difference += base;\n                borrow = 1;\n            } else borrow = 0;\n            r[i] = difference;\n        }\n        for(i = b_l; i < a_l; i++){\n            difference = a[i] - borrow;\n            if (difference < 0) difference += base;\n            else {\n                r[i++] = difference;\n                break;\n            }\n            r[i] = difference;\n        }\n        for(; i < a_l; i++){\n            r[i] = a[i];\n        }\n        trim(r);\n        return r;\n    }\n    function subtractAny(a, b, sign) {\n        var value;\n        if (compareAbs(a, b) >= 0) {\n            value = subtract(a, b);\n        } else {\n            value = subtract(b, a);\n            sign = !sign;\n        }\n        value = arrayToSmall(value);\n        if (typeof value === \"number\") {\n            if (sign) value = -value;\n            return new SmallInteger(value);\n        }\n        return new BigInteger(value, sign);\n    }\n    function subtractSmall(a, b, sign) {\n        var l = a.length, r = new Array(l), carry = -b, base = BASE, i, difference;\n        for(i = 0; i < l; i++){\n            difference = a[i] + carry;\n            carry = Math.floor(difference / base);\n            difference %= base;\n            r[i] = difference < 0 ? difference + base : difference;\n        }\n        r = arrayToSmall(r);\n        if (typeof r === \"number\") {\n            if (sign) r = -r;\n            return new SmallInteger(r);\n        }\n        return new BigInteger(r, sign);\n    }\n    BigInteger.prototype.subtract = function(v) {\n        var n = parseValue(v);\n        if (this.sign !== n.sign) {\n            return this.add(n.negate());\n        }\n        var a = this.value, b = n.value;\n        if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);\n        return subtractAny(a, b, this.sign);\n    };\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\n    SmallInteger.prototype.subtract = function(v) {\n        var n = parseValue(v);\n        var a = this.value;\n        if (a < 0 !== n.sign) {\n            return this.add(n.negate());\n        }\n        var b = n.value;\n        if (n.isSmall) {\n            return new SmallInteger(a - b);\n        }\n        return subtractSmall(b, Math.abs(a), a >= 0);\n    };\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\n    NativeBigInt.prototype.subtract = function(v) {\n        return new NativeBigInt(this.value - parseValue(v).value);\n    };\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\n    BigInteger.prototype.negate = function() {\n        return new BigInteger(this.value, !this.sign);\n    };\n    SmallInteger.prototype.negate = function() {\n        var sign = this.sign;\n        var small = new SmallInteger(-this.value);\n        small.sign = !sign;\n        return small;\n    };\n    NativeBigInt.prototype.negate = function() {\n        return new NativeBigInt(-this.value);\n    };\n    BigInteger.prototype.abs = function() {\n        return new BigInteger(this.value, false);\n    };\n    SmallInteger.prototype.abs = function() {\n        return new SmallInteger(Math.abs(this.value));\n    };\n    NativeBigInt.prototype.abs = function() {\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\n    };\n    function multiplyLong(a, b) {\n        var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product, carry, i, a_i, b_j;\n        for(i = 0; i < a_l; ++i){\n            a_i = a[i];\n            for(var j = 0; j < b_l; ++j){\n                b_j = b[j];\n                product = a_i * b_j + r[i + j];\n                carry = Math.floor(product / base);\n                r[i + j] = product - carry * base;\n                r[i + j + 1] += carry;\n            }\n        }\n        trim(r);\n        return r;\n    }\n    function multiplySmall(a, b) {\n        var l = a.length, r = new Array(l), base = BASE, carry = 0, product, i;\n        for(i = 0; i < l; i++){\n            product = a[i] * b + carry;\n            carry = Math.floor(product / base);\n            r[i] = product - carry * base;\n        }\n        while(carry > 0){\n            r[i++] = carry % base;\n            carry = Math.floor(carry / base);\n        }\n        return r;\n    }\n    function shiftLeft(x, n) {\n        var r = [];\n        while(n-- > 0)r.push(0);\n        return r.concat(x);\n    }\n    function multiplyKaratsuba(x, y) {\n        var n = Math.max(x.length, y.length);\n        if (n <= 30) return multiplyLong(x, y);\n        n = Math.ceil(n / 2);\n        var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);\n        var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\n        trim(product);\n        return product;\n    }\n    // The following function is derived from a surface fit of a graph plotting the performance difference\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\n    function useKaratsuba(l1, l2) {\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\n    }\n    BigInteger.prototype.multiply = function(v) {\n        var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;\n        if (n.isSmall) {\n            if (b === 0) return Integer[0];\n            if (b === 1) return this;\n            if (b === -1) return this.negate();\n            abs = Math.abs(b);\n            if (abs < BASE) {\n                return new BigInteger(multiplySmall(a, abs), sign);\n            }\n            b = smallToArray(abs);\n        }\n        if (useKaratsuba(a.length, b.length)) return new BigInteger(multiplyKaratsuba(a, b), sign);\n        return new BigInteger(multiplyLong(a, b), sign);\n    };\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\n    function multiplySmallAndArray(a, b, sign) {\n        if (a < BASE) {\n            return new BigInteger(multiplySmall(b, a), sign);\n        }\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\n    }\n    SmallInteger.prototype._multiplyBySmall = function(a) {\n        if (isPrecise(a.value * this.value)) {\n            return new SmallInteger(a.value * this.value);\n        }\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\n    };\n    BigInteger.prototype._multiplyBySmall = function(a) {\n        if (a.value === 0) return Integer[0];\n        if (a.value === 1) return this;\n        if (a.value === -1) return this.negate();\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\n    };\n    SmallInteger.prototype.multiply = function(v) {\n        return parseValue(v)._multiplyBySmall(this);\n    };\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\n    NativeBigInt.prototype.multiply = function(v) {\n        return new NativeBigInt(this.value * parseValue(v).value);\n    };\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\n    function square(a) {\n        //console.assert(2 * BASE * BASE < MAX_INT);\n        var l = a.length, r = createArray(l + l), base = BASE, product, carry, i, a_i, a_j;\n        for(i = 0; i < l; i++){\n            a_i = a[i];\n            carry = 0 - a_i * a_i;\n            for(var j = i; j < l; j++){\n                a_j = a[j];\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\n                carry = Math.floor(product / base);\n                r[i + j] = product - carry * base;\n            }\n            r[i + l] = carry;\n        }\n        trim(r);\n        return r;\n    }\n    BigInteger.prototype.square = function() {\n        return new BigInteger(square(this.value), false);\n    };\n    SmallInteger.prototype.square = function() {\n        var value = this.value * this.value;\n        if (isPrecise(value)) return new SmallInteger(value);\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\n    };\n    NativeBigInt.prototype.square = function(v) {\n        return new NativeBigInt(this.value * this.value);\n    };\n    function divMod1(a, b) {\n        var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], // normalization\n        lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i, l, q;\n        if (remainder.length <= a_l) remainder.push(0);\n        divisor.push(0);\n        divisorMostSignificantDigit = divisor[b_l - 1];\n        for(shift = a_l - b_l; shift >= 0; shift--){\n            quotientDigit = base - 1;\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\n            }\n            // quotientDigit <= base - 1\n            carry = 0;\n            borrow = 0;\n            l = divisor.length;\n            for(i = 0; i < l; i++){\n                carry += quotientDigit * divisor[i];\n                q = Math.floor(carry / base);\n                borrow += remainder[shift + i] - (carry - q * base);\n                carry = q;\n                if (borrow < 0) {\n                    remainder[shift + i] = borrow + base;\n                    borrow = -1;\n                } else {\n                    remainder[shift + i] = borrow;\n                    borrow = 0;\n                }\n            }\n            while(borrow !== 0){\n                quotientDigit -= 1;\n                carry = 0;\n                for(i = 0; i < l; i++){\n                    carry += remainder[shift + i] - base + divisor[i];\n                    if (carry < 0) {\n                        remainder[shift + i] = carry + base;\n                        carry = 0;\n                    } else {\n                        remainder[shift + i] = carry;\n                        carry = 1;\n                    }\n                }\n                borrow += carry;\n            }\n            result[shift] = quotientDigit;\n        }\n        // denormalization\n        remainder = divModSmall(remainder, lambda)[0];\n        return [\n            arrayToSmall(result),\n            arrayToSmall(remainder)\n        ];\n    }\n    function divMod2(a, b) {\n        // Performs faster than divMod1 on larger input sizes.\n        var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;\n        while(a_l){\n            part.unshift(a[--a_l]);\n            trim(part);\n            if (compareAbs(part, b) < 0) {\n                result.push(0);\n                continue;\n            }\n            xlen = part.length;\n            highx = part[xlen - 1] * base + part[xlen - 2];\n            highy = b[b_l - 1] * base + b[b_l - 2];\n            if (xlen > b_l) {\n                highx = (highx + 1) * base;\n            }\n            guess = Math.ceil(highx / highy);\n            do {\n                check = multiplySmall(b, guess);\n                if (compareAbs(check, part) <= 0) break;\n                guess--;\n            }while (guess);\n            result.push(guess);\n            part = subtract(part, check);\n        }\n        result.reverse();\n        return [\n            arrayToSmall(result),\n            arrayToSmall(part)\n        ];\n    }\n    function divModSmall(value, lambda) {\n        var length = value.length, quotient = createArray(length), base = BASE, i, q, remainder, divisor;\n        remainder = 0;\n        for(i = length - 1; i >= 0; --i){\n            divisor = remainder * base + value[i];\n            q = truncate(divisor / lambda);\n            remainder = divisor - q * lambda;\n            quotient[i] = q | 0;\n        }\n        return [\n            quotient,\n            remainder | 0\n        ];\n    }\n    function divModAny(self, v) {\n        var value, n = parseValue(v);\n        if (supportsNativeBigInt) {\n            return [\n                new NativeBigInt(self.value / n.value),\n                new NativeBigInt(self.value % n.value)\n            ];\n        }\n        var a = self.value, b = n.value;\n        var quotient;\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\n        if (self.isSmall) {\n            if (n.isSmall) {\n                return [\n                    new SmallInteger(truncate(a / b)),\n                    new SmallInteger(a % b)\n                ];\n            }\n            return [\n                Integer[0],\n                self\n            ];\n        }\n        if (n.isSmall) {\n            if (b === 1) return [\n                self,\n                Integer[0]\n            ];\n            if (b == -1) return [\n                self.negate(),\n                Integer[0]\n            ];\n            var abs = Math.abs(b);\n            if (abs < BASE) {\n                value = divModSmall(a, abs);\n                quotient = arrayToSmall(value[0]);\n                var remainder = value[1];\n                if (self.sign) remainder = -remainder;\n                if (typeof quotient === \"number\") {\n                    if (self.sign !== n.sign) quotient = -quotient;\n                    return [\n                        new SmallInteger(quotient),\n                        new SmallInteger(remainder)\n                    ];\n                }\n                return [\n                    new BigInteger(quotient, self.sign !== n.sign),\n                    new SmallInteger(remainder)\n                ];\n            }\n            b = smallToArray(abs);\n        }\n        var comparison = compareAbs(a, b);\n        if (comparison === -1) return [\n            Integer[0],\n            self\n        ];\n        if (comparison === 0) return [\n            Integer[self.sign === n.sign ? 1 : -1],\n            Integer[0]\n        ];\n        // divMod1 is faster on smaller input sizes\n        if (a.length + b.length <= 200) value = divMod1(a, b);\n        else value = divMod2(a, b);\n        quotient = value[0];\n        var qSign = self.sign !== n.sign, mod = value[1], mSign = self.sign;\n        if (typeof quotient === \"number\") {\n            if (qSign) quotient = -quotient;\n            quotient = new SmallInteger(quotient);\n        } else quotient = new BigInteger(quotient, qSign);\n        if (typeof mod === \"number\") {\n            if (mSign) mod = -mod;\n            mod = new SmallInteger(mod);\n        } else mod = new BigInteger(mod, mSign);\n        return [\n            quotient,\n            mod\n        ];\n    }\n    BigInteger.prototype.divmod = function(v) {\n        var result = divModAny(this, v);\n        return {\n            quotient: result[0],\n            remainder: result[1]\n        };\n    };\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\n    BigInteger.prototype.divide = function(v) {\n        return divModAny(this, v)[0];\n    };\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {\n        return new NativeBigInt(this.value / parseValue(v).value);\n    };\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\n    BigInteger.prototype.mod = function(v) {\n        return divModAny(this, v)[1];\n    };\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {\n        return new NativeBigInt(this.value % parseValue(v).value);\n    };\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\n    BigInteger.prototype.pow = function(v) {\n        var n = parseValue(v), a = this.value, b = n.value, value, x, y;\n        if (b === 0) return Integer[1];\n        if (a === 0) return Integer[0];\n        if (a === 1) return Integer[1];\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\n        if (n.sign) {\n            return Integer[0];\n        }\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\n        if (this.isSmall) {\n            if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));\n        }\n        x = this;\n        y = Integer[1];\n        while(true){\n            if (b & 1 === 1) {\n                y = y.times(x);\n                --b;\n            }\n            if (b === 0) break;\n            b /= 2;\n            x = x.square();\n        }\n        return y;\n    };\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\n    NativeBigInt.prototype.pow = function(v) {\n        var n = parseValue(v);\n        var a = this.value, b = n.value;\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\n        if (b === _0) return Integer[1];\n        if (a === _0) return Integer[0];\n        if (a === _1) return Integer[1];\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\n        if (n.isNegative()) return new NativeBigInt(_0);\n        var x = this;\n        var y = Integer[1];\n        while(true){\n            if ((b & _1) === _1) {\n                y = y.times(x);\n                --b;\n            }\n            if (b === _0) break;\n            b /= _2;\n            x = x.square();\n        }\n        return y;\n    };\n    BigInteger.prototype.modPow = function(exp, mod) {\n        exp = parseValue(exp);\n        mod = parseValue(mod);\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\n        var r = Integer[1], base = this.mod(mod);\n        if (exp.isNegative()) {\n            exp = exp.multiply(Integer[-1]);\n            base = base.modInv(mod);\n        }\n        while(exp.isPositive()){\n            if (base.isZero()) return Integer[0];\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\n            exp = exp.divide(2);\n            base = base.square().mod(mod);\n        }\n        return r;\n    };\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\n    function compareAbs(a, b) {\n        if (a.length !== b.length) {\n            return a.length > b.length ? 1 : -1;\n        }\n        for(var i = a.length - 1; i >= 0; i--){\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\n        }\n        return 0;\n    }\n    BigInteger.prototype.compareAbs = function(v) {\n        var n = parseValue(v), a = this.value, b = n.value;\n        if (n.isSmall) return 1;\n        return compareAbs(a, b);\n    };\n    SmallInteger.prototype.compareAbs = function(v) {\n        var n = parseValue(v), a = Math.abs(this.value), b = n.value;\n        if (n.isSmall) {\n            b = Math.abs(b);\n            return a === b ? 0 : a > b ? 1 : -1;\n        }\n        return -1;\n    };\n    NativeBigInt.prototype.compareAbs = function(v) {\n        var a = this.value;\n        var b = parseValue(v).value;\n        a = a >= 0 ? a : -a;\n        b = b >= 0 ? b : -b;\n        return a === b ? 0 : a > b ? 1 : -1;\n    };\n    BigInteger.prototype.compare = function(v) {\n        // See discussion about comparison with Infinity:\n        // https://github.com/peterolson/BigInteger.js/issues/61\n        if (v === Infinity) {\n            return -1;\n        }\n        if (v === -Infinity) {\n            return 1;\n        }\n        var n = parseValue(v), a = this.value, b = n.value;\n        if (this.sign !== n.sign) {\n            return n.sign ? 1 : -1;\n        }\n        if (n.isSmall) {\n            return this.sign ? -1 : 1;\n        }\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\n    };\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\n    SmallInteger.prototype.compare = function(v) {\n        if (v === Infinity) {\n            return -1;\n        }\n        if (v === -Infinity) {\n            return 1;\n        }\n        var n = parseValue(v), a = this.value, b = n.value;\n        if (n.isSmall) {\n            return a == b ? 0 : a > b ? 1 : -1;\n        }\n        if (a < 0 !== n.sign) {\n            return a < 0 ? -1 : 1;\n        }\n        return a < 0 ? 1 : -1;\n    };\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\n    NativeBigInt.prototype.compare = function(v) {\n        if (v === Infinity) {\n            return -1;\n        }\n        if (v === -Infinity) {\n            return 1;\n        }\n        var a = this.value;\n        var b = parseValue(v).value;\n        return a === b ? 0 : a > b ? 1 : -1;\n    };\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\n    BigInteger.prototype.equals = function(v) {\n        return this.compare(v) === 0;\n    };\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\n    BigInteger.prototype.notEquals = function(v) {\n        return this.compare(v) !== 0;\n    };\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\n    BigInteger.prototype.greater = function(v) {\n        return this.compare(v) > 0;\n    };\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\n    BigInteger.prototype.lesser = function(v) {\n        return this.compare(v) < 0;\n    };\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\n    BigInteger.prototype.greaterOrEquals = function(v) {\n        return this.compare(v) >= 0;\n    };\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\n    BigInteger.prototype.lesserOrEquals = function(v) {\n        return this.compare(v) <= 0;\n    };\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\n    BigInteger.prototype.isEven = function() {\n        return (this.value[0] & 1) === 0;\n    };\n    SmallInteger.prototype.isEven = function() {\n        return (this.value & 1) === 0;\n    };\n    NativeBigInt.prototype.isEven = function() {\n        return (this.value & BigInt(1)) === BigInt(0);\n    };\n    BigInteger.prototype.isOdd = function() {\n        return (this.value[0] & 1) === 1;\n    };\n    SmallInteger.prototype.isOdd = function() {\n        return (this.value & 1) === 1;\n    };\n    NativeBigInt.prototype.isOdd = function() {\n        return (this.value & BigInt(1)) === BigInt(1);\n    };\n    BigInteger.prototype.isPositive = function() {\n        return !this.sign;\n    };\n    SmallInteger.prototype.isPositive = function() {\n        return this.value > 0;\n    };\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\n    BigInteger.prototype.isNegative = function() {\n        return this.sign;\n    };\n    SmallInteger.prototype.isNegative = function() {\n        return this.value < 0;\n    };\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\n    BigInteger.prototype.isUnit = function() {\n        return false;\n    };\n    SmallInteger.prototype.isUnit = function() {\n        return Math.abs(this.value) === 1;\n    };\n    NativeBigInt.prototype.isUnit = function() {\n        return this.abs().value === BigInt(1);\n    };\n    BigInteger.prototype.isZero = function() {\n        return false;\n    };\n    SmallInteger.prototype.isZero = function() {\n        return this.value === 0;\n    };\n    NativeBigInt.prototype.isZero = function() {\n        return this.value === BigInt(0);\n    };\n    BigInteger.prototype.isDivisibleBy = function(v) {\n        var n = parseValue(v);\n        if (n.isZero()) return false;\n        if (n.isUnit()) return true;\n        if (n.compareAbs(2) === 0) return this.isEven();\n        return this.mod(n).isZero();\n    };\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\n    function isBasicPrime(v) {\n        var n = v.abs();\n        if (n.isUnit()) return false;\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\n        if (n.lesser(49)) return true;\n    // we don't know if it's prime: let the other functions figure it out\n    }\n    function millerRabinTest(n, a) {\n        var nPrev = n.prev(), b = nPrev, r = 0, d, t, i, x;\n        while(b.isEven())b = b.divide(2), r++;\n        next: for(i = 0; i < a.length; i++){\n            if (n.lesser(a[i])) continue;\n            x = bigInt(a[i]).modPow(b, n);\n            if (x.isUnit() || x.equals(nPrev)) continue;\n            for(d = r - 1; d != 0; d--){\n                x = x.square().mod(n);\n                if (x.isUnit()) return false;\n                if (x.equals(nPrev)) continue next;\n            }\n            return false;\n        }\n        return true;\n    }\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\n    BigInteger.prototype.isPrime = function(strict) {\n        var isPrime = isBasicPrime(this);\n        if (isPrime !== undefined) return isPrime;\n        var n = this.abs();\n        var bits = n.bitLength();\n        if (bits <= 64) return millerRabinTest(n, [\n            2,\n            3,\n            5,\n            7,\n            11,\n            13,\n            17,\n            19,\n            23,\n            29,\n            31,\n            37\n        ]);\n        var logN = Math.log(2) * bits.toJSNumber();\n        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);\n        for(var a = [], i = 0; i < t; i++){\n            a.push(bigInt(i + 2));\n        }\n        return millerRabinTest(n, a);\n    };\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\n    BigInteger.prototype.isProbablePrime = function(iterations, rng) {\n        var isPrime = isBasicPrime(this);\n        if (isPrime !== undefined) return isPrime;\n        var n = this.abs();\n        var t = iterations === undefined ? 5 : iterations;\n        for(var a = [], i = 0; i < t; i++){\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\n        }\n        return millerRabinTest(n, a);\n    };\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\n    BigInteger.prototype.modInv = function(n) {\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\n        while(!newR.isZero()){\n            q = r.divide(newR);\n            lastT = t;\n            lastR = r;\n            t = newT;\n            r = newR;\n            newT = lastT.subtract(q.multiply(newT));\n            newR = lastR.subtract(q.multiply(newR));\n        }\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\n        if (t.compare(0) === -1) {\n            t = t.add(n);\n        }\n        if (this.isNegative()) {\n            return t.negate();\n        }\n        return t;\n    };\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\n    BigInteger.prototype.next = function() {\n        var value = this.value;\n        if (this.sign) {\n            return subtractSmall(value, 1, this.sign);\n        }\n        return new BigInteger(addSmall(value, 1), this.sign);\n    };\n    SmallInteger.prototype.next = function() {\n        var value = this.value;\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\n        return new BigInteger(MAX_INT_ARR, false);\n    };\n    NativeBigInt.prototype.next = function() {\n        return new NativeBigInt(this.value + BigInt(1));\n    };\n    BigInteger.prototype.prev = function() {\n        var value = this.value;\n        if (this.sign) {\n            return new BigInteger(addSmall(value, 1), true);\n        }\n        return subtractSmall(value, 1, this.sign);\n    };\n    SmallInteger.prototype.prev = function() {\n        var value = this.value;\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\n        return new BigInteger(MAX_INT_ARR, true);\n    };\n    NativeBigInt.prototype.prev = function() {\n        return new NativeBigInt(this.value - BigInt(1));\n    };\n    var powersOfTwo = [\n        1\n    ];\n    while(2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\n    function shift_isSmall(n) {\n        return Math.abs(n) <= BASE;\n    }\n    BigInteger.prototype.shiftLeft = function(v) {\n        var n = parseValue(v).toJSNumber();\n        if (!shift_isSmall(n)) {\n            throw new Error(String(n) + \" is too large for shifting.\");\n        }\n        if (n < 0) return this.shiftRight(-n);\n        var result = this;\n        if (result.isZero()) return result;\n        while(n >= powers2Length){\n            result = result.multiply(highestPower2);\n            n -= powers2Length - 1;\n        }\n        return result.multiply(powersOfTwo[n]);\n    };\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\n    BigInteger.prototype.shiftRight = function(v) {\n        var remQuo;\n        var n = parseValue(v).toJSNumber();\n        if (!shift_isSmall(n)) {\n            throw new Error(String(n) + \" is too large for shifting.\");\n        }\n        if (n < 0) return this.shiftLeft(-n);\n        var result = this;\n        while(n >= powers2Length){\n            if (result.isZero() || result.isNegative() && result.isUnit()) return result;\n            remQuo = divModAny(result, highestPower2);\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n            n -= powers2Length - 1;\n        }\n        remQuo = divModAny(result, powersOfTwo[n]);\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\n    };\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\n    function bitwise(x, y, fn) {\n        y = parseValue(y);\n        var xSign = x.isNegative(), ySign = y.isNegative();\n        var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;\n        var xDigit = 0, yDigit = 0;\n        var xDivMod = null, yDivMod = null;\n        var result = [];\n        while(!xRem.isZero() || !yRem.isZero()){\n            xDivMod = divModAny(xRem, highestPower2);\n            xDigit = xDivMod[1].toJSNumber();\n            if (xSign) {\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\n            }\n            yDivMod = divModAny(yRem, highestPower2);\n            yDigit = yDivMod[1].toJSNumber();\n            if (ySign) {\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\n            }\n            xRem = xDivMod[0];\n            yRem = yDivMod[0];\n            result.push(fn(xDigit, yDigit));\n        }\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\n        for(var i = result.length - 1; i >= 0; i -= 1){\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\n        }\n        return sum;\n    }\n    BigInteger.prototype.not = function() {\n        return this.negate().prev();\n    };\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\n    BigInteger.prototype.and = function(n) {\n        return bitwise(this, n, function(a, b) {\n            return a & b;\n        });\n    };\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\n    BigInteger.prototype.or = function(n) {\n        return bitwise(this, n, function(a, b) {\n            return a | b;\n        });\n    };\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\n    BigInteger.prototype.xor = function(n) {\n        return bitwise(this, n, function(a, b) {\n            return a ^ b;\n        });\n    };\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\n    function roughLOB(n) {\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\n        var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;\n        return x & -x;\n    }\n    function integerLogarithm(value, base) {\n        if (base.compareTo(value) <= 0) {\n            var tmp = integerLogarithm(value, base.square(base));\n            var p = tmp.p;\n            var e = tmp.e;\n            var t = p.multiply(base);\n            return t.compareTo(value) <= 0 ? {\n                p: t,\n                e: e * 2 + 1\n            } : {\n                p: p,\n                e: e * 2\n            };\n        }\n        return {\n            p: bigInt(1),\n            e: 0\n        };\n    }\n    BigInteger.prototype.bitLength = function() {\n        var n = this;\n        if (n.compareTo(bigInt(0)) < 0) {\n            n = n.negate().subtract(bigInt(1));\n        }\n        if (n.compareTo(bigInt(0)) === 0) {\n            return bigInt(0);\n        }\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\n    };\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\n    function max(a, b) {\n        a = parseValue(a);\n        b = parseValue(b);\n        return a.greater(b) ? a : b;\n    }\n    function min(a, b) {\n        a = parseValue(a);\n        b = parseValue(b);\n        return a.lesser(b) ? a : b;\n    }\n    function gcd(a, b) {\n        a = parseValue(a).abs();\n        b = parseValue(b).abs();\n        if (a.equals(b)) return a;\n        if (a.isZero()) return b;\n        if (b.isZero()) return a;\n        var c = Integer[1], d, t;\n        while(a.isEven() && b.isEven()){\n            d = min(roughLOB(a), roughLOB(b));\n            a = a.divide(d);\n            b = b.divide(d);\n            c = c.multiply(d);\n        }\n        while(a.isEven()){\n            a = a.divide(roughLOB(a));\n        }\n        do {\n            while(b.isEven()){\n                b = b.divide(roughLOB(b));\n            }\n            if (a.greater(b)) {\n                t = b;\n                b = a;\n                a = t;\n            }\n            b = b.subtract(a);\n        }while (!b.isZero());\n        return c.isUnit() ? a : a.multiply(c);\n    }\n    function lcm(a, b) {\n        a = parseValue(a).abs();\n        b = parseValue(b).abs();\n        return a.divide(gcd(a, b)).multiply(b);\n    }\n    function randBetween(a, b, rng) {\n        a = parseValue(a);\n        b = parseValue(b);\n        var usedRNG = rng || Math.random;\n        var low = min(a, b), high = max(a, b);\n        var range = high.subtract(low).add(1);\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\n        var digits = toBase(range, BASE).value;\n        var result = [], restricted = true;\n        for(var i = 0; i < digits.length; i++){\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\n            var digit = truncate(usedRNG() * top);\n            result.push(digit);\n            if (digit < digits[i]) restricted = false;\n        }\n        return low.add(Integer.fromArray(result, BASE, false));\n    }\n    var parseBase = function(text, base, alphabet, caseSensitive) {\n        alphabet = alphabet || DEFAULT_ALPHABET;\n        text = String(text);\n        if (!caseSensitive) {\n            text = text.toLowerCase();\n            alphabet = alphabet.toLowerCase();\n        }\n        var length = text.length;\n        var i;\n        var absBase = Math.abs(base);\n        var alphabetValues = {};\n        for(i = 0; i < alphabet.length; i++){\n            alphabetValues[alphabet[i]] = i;\n        }\n        for(i = 0; i < length; i++){\n            var c = text[i];\n            if (c === \"-\") continue;\n            if (c in alphabetValues) {\n                if (alphabetValues[c] >= absBase) {\n                    if (c === \"1\" && absBase === 1) continue;\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\n                }\n            }\n        }\n        base = parseValue(base);\n        var digits = [];\n        var isNegative = text[0] === \"-\";\n        for(i = isNegative ? 1 : 0; i < text.length; i++){\n            var c = text[i];\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\n            else if (c === \"<\") {\n                var start = i;\n                do {\n                    i++;\n                }while (text[i] !== \">\" && i < text.length);\n                digits.push(parseValue(text.slice(start + 1, i)));\n            } else throw new Error(c + \" is not a valid character\");\n        }\n        return parseBaseFromArray(digits, base, isNegative);\n    };\n    function parseBaseFromArray(digits, base, isNegative) {\n        var val = Integer[0], pow = Integer[1], i;\n        for(i = digits.length - 1; i >= 0; i--){\n            val = val.add(digits[i].times(pow));\n            pow = pow.times(base);\n        }\n        return isNegative ? val.negate() : val;\n    }\n    function stringify(digit, alphabet) {\n        alphabet = alphabet || DEFAULT_ALPHABET;\n        if (digit < alphabet.length) {\n            return alphabet[digit];\n        }\n        return \"<\" + digit + \">\";\n    }\n    function toBase(n, base) {\n        base = bigInt(base);\n        if (base.isZero()) {\n            if (n.isZero()) return {\n                value: [\n                    0\n                ],\n                isNegative: false\n            };\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\n        }\n        if (base.equals(-1)) {\n            if (n.isZero()) return {\n                value: [\n                    0\n                ],\n                isNegative: false\n            };\n            if (n.isNegative()) return {\n                value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [\n                    1,\n                    0\n                ])),\n                isNegative: false\n            };\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [\n                0,\n                1\n            ]);\n            arr.unshift([\n                1\n            ]);\n            return {\n                value: [].concat.apply([], arr),\n                isNegative: false\n            };\n        }\n        var neg = false;\n        if (n.isNegative() && base.isPositive()) {\n            neg = true;\n            n = n.abs();\n        }\n        if (base.isUnit()) {\n            if (n.isZero()) return {\n                value: [\n                    0\n                ],\n                isNegative: false\n            };\n            return {\n                value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),\n                isNegative: neg\n            };\n        }\n        var out = [];\n        var left = n, divmod;\n        while(left.isNegative() || left.compareAbs(base) >= 0){\n            divmod = left.divmod(base);\n            left = divmod.quotient;\n            var digit = divmod.remainder;\n            if (digit.isNegative()) {\n                digit = base.minus(digit).abs();\n                left = left.next();\n            }\n            out.push(digit.toJSNumber());\n        }\n        out.push(left.toJSNumber());\n        return {\n            value: out.reverse(),\n            isNegative: neg\n        };\n    }\n    function toBaseString(n, base, alphabet) {\n        var arr = toBase(n, base);\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function(x) {\n            return stringify(x, alphabet);\n        }).join(\"\");\n    }\n    BigInteger.prototype.toArray = function(radix) {\n        return toBase(this, radix);\n    };\n    SmallInteger.prototype.toArray = function(radix) {\n        return toBase(this, radix);\n    };\n    NativeBigInt.prototype.toArray = function(radix) {\n        return toBase(this, radix);\n    };\n    BigInteger.prototype.toString = function(radix, alphabet) {\n        if (radix === undefined) radix = 10;\n        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\n        while(--l >= 0){\n            digit = String(v[l]);\n            str += zeros.slice(digit.length) + digit;\n        }\n        var sign = this.sign ? \"-\" : \"\";\n        return sign + str;\n    };\n    SmallInteger.prototype.toString = function(radix, alphabet) {\n        if (radix === undefined) radix = 10;\n        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);\n        return String(this.value);\n    };\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {\n        return this.toString();\n    };\n    BigInteger.prototype.valueOf = function() {\n        return parseInt(this.toString(), 10);\n    };\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\n    SmallInteger.prototype.valueOf = function() {\n        return this.value;\n    };\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {\n        return parseInt(this.toString(), 10);\n    };\n    function parseStringValue(v) {\n        if (isPrecise(+v)) {\n            var x = +v;\n            if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\n            throw new Error(\"Invalid integer: \" + v);\n        }\n        var sign = v[0] === \"-\";\n        if (sign) v = v.slice(1);\n        var split = v.split(/e/i);\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\n        if (split.length === 2) {\n            var exp = split[1];\n            if (exp[0] === \"+\") exp = exp.slice(1);\n            exp = +exp;\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\n            var text = split[0];\n            var decimalPlace = text.indexOf(\".\");\n            if (decimalPlace >= 0) {\n                exp -= text.length - decimalPlace - 1;\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\n            }\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\n            text += new Array(exp + 1).join(\"0\");\n            v = text;\n        }\n        var isValid = /^([0-9][0-9]*)$/.test(v);\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\n        if (supportsNativeBigInt) {\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\n        }\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\n        while(max > 0){\n            r.push(+v.slice(min, max));\n            min -= l;\n            if (min < 0) min = 0;\n            max -= l;\n        }\n        trim(r);\n        return new BigInteger(r, sign);\n    }\n    function parseNumberValue(v) {\n        if (supportsNativeBigInt) {\n            return new NativeBigInt(BigInt(v));\n        }\n        if (isPrecise(v)) {\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\n            return new SmallInteger(v);\n        }\n        return parseStringValue(v.toString());\n    }\n    function parseValue(v) {\n        if (typeof v === \"number\") {\n            return parseNumberValue(v);\n        }\n        if (typeof v === \"string\") {\n            return parseStringValue(v);\n        }\n        if (typeof v === \"bigint\") {\n            return new NativeBigInt(v);\n        }\n        return v;\n    }\n    // Pre-define numbers in range [-999,999]\n    for(var i = 0; i < 1000; i++){\n        Integer[i] = parseValue(i);\n        if (i > 0) Integer[-i] = parseValue(-i);\n    }\n    // Backwards compatibility\n    Integer.one = Integer[1];\n    Integer.zero = Integer[0];\n    Integer.minusOne = Integer[-1];\n    Integer.max = max;\n    Integer.min = min;\n    Integer.gcd = gcd;\n    Integer.lcm = lcm;\n    Integer.isInstance = function(x) {\n        return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;\n    };\n    Integer.randBetween = randBetween;\n    Integer.fromArray = function(digits, base, isNegative) {\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\n    };\n    return Integer;\n}();\n// Node.js check\nif ( true && module.hasOwnProperty(\"exports\")) {\n    module.exports = bigInt;\n}\n//amd check\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return bigInt;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmlnLWludGVnZXIvQmlnSW50ZWdlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsc0NBQUlBLFNBQVMsU0FBV0MsU0FBUztJQUM3QjtJQUVBLElBQUlDLE9BQU8sS0FDUEMsV0FBVyxHQUNYQyxVQUFVLGtCQUNWQyxjQUFjQyxhQUFhRixVQUMzQkcsbUJBQW1CO0lBRXZCLElBQUlDLHVCQUF1QixPQUFPQyxXQUFXO0lBRTdDLFNBQVNDLFFBQVFDLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLGFBQWE7UUFDOUMsSUFBSSxPQUFPSCxNQUFNLGFBQWEsT0FBT0QsT0FBTyxDQUFDLEVBQUU7UUFDL0MsSUFBSSxPQUFPRSxVQUFVLGFBQWEsT0FBTyxDQUFDQSxVQUFVLE1BQU0sQ0FBQ0MsV0FBV0UsV0FBV0osS0FBS0ssVUFBVUwsR0FBR0MsT0FBT0MsVUFBVUM7UUFDcEgsT0FBT0MsV0FBV0o7SUFDdEI7SUFFQSxTQUFTTSxXQUFXQyxLQUFLLEVBQUVDLElBQUk7UUFDM0IsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDbkI7SUFDQUgsV0FBV0ksU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNiLFFBQVFXLFNBQVM7SUFFdEQsU0FBU0csYUFBYU4sS0FBSztRQUN2QixJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLElBQUksR0FBR0QsUUFBUTtRQUNwQixJQUFJLENBQUNFLE9BQU8sR0FBRztJQUNuQjtJQUNBSSxhQUFhSCxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ2IsUUFBUVcsU0FBUztJQUV4RCxTQUFTSSxhQUFhUCxLQUFLO1FBQ3ZCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBTyxhQUFhSixTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ2IsUUFBUVcsU0FBUztJQUV4RCxTQUFTSyxV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LEdBQUcxUDtBQUNyQjtBQUVBLFdBQVc7QUFDWCxJQUFJLElBQTBDLEVBQUU7SUFDNUMyUCxtQ0FBUTtRQUNKLE9BQU8zUDtJQUNYLENBQUM7QUFBQSxrR0FBQztBQUNOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2QtdGltZXNoZWV0LWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2JpZy1pbnRlZ2VyL0JpZ0ludGVnZXIuanM/ZDZjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmlnSW50ID0gKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBCQVNFID0gMWU3LFxyXG4gICAgICAgIExPR19CQVNFID0gNyxcclxuICAgICAgICBNQVhfSU5UID0gOTAwNzE5OTI1NDc0MDk5MixcclxuICAgICAgICBNQVhfSU5UX0FSUiA9IHNtYWxsVG9BcnJheShNQVhfSU5UKSxcclxuICAgICAgICBERUZBVUxUX0FMUEhBQkVUID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcclxuXHJcbiAgICB2YXIgc3VwcG9ydHNOYXRpdmVCaWdJbnQgPSB0eXBlb2YgQmlnSW50ID09PSBcImZ1bmN0aW9uXCI7XHJcblxyXG4gICAgZnVuY3Rpb24gSW50ZWdlcih2LCByYWRpeCwgYWxwaGFiZXQsIGNhc2VTZW5zaXRpdmUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmFkaXggIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiArcmFkaXggPT09IDEwICYmICFhbHBoYWJldCA/IHBhcnNlVmFsdWUodikgOiBwYXJzZUJhc2UodiwgcmFkaXgsIGFscGhhYmV0LCBjYXNlU2Vuc2l0aXZlKTtcclxuICAgICAgICByZXR1cm4gcGFyc2VWYWx1ZSh2KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBCaWdJbnRlZ2VyKHZhbHVlLCBzaWduKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2lnbiA9IHNpZ247XHJcbiAgICAgICAgdGhpcy5pc1NtYWxsID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFNtYWxsSW50ZWdlcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnNpZ24gPSB2YWx1ZSA8IDA7XHJcbiAgICAgICAgdGhpcy5pc1NtYWxsID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEludGVnZXIucHJvdG90eXBlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBOYXRpdmVCaWdJbnQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlZ2VyLnByb3RvdHlwZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNQcmVjaXNlKG4pIHtcclxuICAgICAgICByZXR1cm4gLU1BWF9JTlQgPCBuICYmIG4gPCBNQVhfSU5UO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNtYWxsVG9BcnJheShuKSB7IC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zIGRvZXNuJ3QgcmVmZXJlbmNlIEJBU0UsIG5lZWQgdG8gY2hhbmdlIHRoaXMgZnVuY3Rpb24gaWYgQkFTRSBjaGFuZ2VzXHJcbiAgICAgICAgaWYgKG4gPCAxZTcpXHJcbiAgICAgICAgICAgIHJldHVybiBbbl07XHJcbiAgICAgICAgaWYgKG4gPCAxZTE0KVxyXG4gICAgICAgICAgICByZXR1cm4gW24gJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlNyldO1xyXG4gICAgICAgIHJldHVybiBbbiAlIDFlNywgTWF0aC5mbG9vcihuIC8gMWU3KSAlIDFlNywgTWF0aC5mbG9vcihuIC8gMWUxNCldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFycmF5VG9TbWFsbChhcnIpIHsgLy8gSWYgQkFTRSBjaGFuZ2VzIHRoaXMgZnVuY3Rpb24gbWF5IG5lZWQgdG8gY2hhbmdlXHJcbiAgICAgICAgdHJpbShhcnIpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xyXG4gICAgICAgIGlmIChsZW5ndGggPCA0ICYmIGNvbXBhcmVBYnMoYXJyLCBNQVhfSU5UX0FSUikgPCAwKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gYXJyWzBdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gYXJyWzBdICsgYXJyWzFdICogQkFTRTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBhcnJbMF0gKyAoYXJyWzFdICsgYXJyWzJdICogQkFTRSkgKiBCQVNFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJpbSh2KSB7XHJcbiAgICAgICAgdmFyIGkgPSB2Lmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAodlstLWldID09PSAwKTtcclxuICAgICAgICB2Lmxlbmd0aCA9IGkgKyAxO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFycmF5KGxlbmd0aCkgeyAvLyBmdW5jdGlvbiBzaGFtZWxlc3NseSBzdG9sZW4gZnJvbSBZYWZmbGUncyBsaWJyYXJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9ZYWZmbGUvQmlnSW50ZWdlclxyXG4gICAgICAgIHZhciB4ID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgdmFyIGkgPSAtMTtcclxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHhbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShuKSB7XHJcbiAgICAgICAgaWYgKG4gPiAwKSByZXR1cm4gTWF0aC5mbG9vcihuKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG4pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZChhLCBiKSB7IC8vIGFzc3VtZXMgYSBhbmQgYiBhcmUgYXJyYXlzIHdpdGggYS5sZW5ndGggPj0gYi5sZW5ndGhcclxuICAgICAgICB2YXIgbF9hID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGxfYiA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGxfYSksXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHN1bSwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbF9iOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtID0gYVtpXSArIGJbaV0gKyBjYXJyeTtcclxuICAgICAgICAgICAgY2FycnkgPSBzdW0gPj0gYmFzZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICByW2ldID0gc3VtIC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaSA8IGxfYSkge1xyXG4gICAgICAgICAgICBzdW0gPSBhW2ldICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gc3VtID09PSBiYXNlID8gMSA6IDA7XHJcbiAgICAgICAgICAgIHJbaSsrXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgci5wdXNoKGNhcnJ5KTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRBbnkoYSwgYikge1xyXG4gICAgICAgIGlmIChhLmxlbmd0aCA+PSBiLmxlbmd0aCkgcmV0dXJuIGFkZChhLCBiKTtcclxuICAgICAgICByZXR1cm4gYWRkKGIsIGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFNtYWxsKGEsIGNhcnJ5KSB7IC8vIGFzc3VtZXMgYSBpcyBhcnJheSwgY2FycnkgaXMgbnVtYmVyIHdpdGggMCA8PSBjYXJyeSA8IE1BWF9JTlRcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgc3VtLCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtID0gYVtpXSAtIGJhc2UgKyBjYXJyeTtcclxuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHN1bSAvIGJhc2UpO1xyXG4gICAgICAgICAgICByW2ldID0gc3VtIC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgICAgICBjYXJyeSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XHJcbiAgICAgICAgICAgIHJbaSsrXSA9IGNhcnJ5ICUgYmFzZTtcclxuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24gIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChuLm5lZ2F0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbChhLCBNYXRoLmFicyhiKSksIHRoaXMuc2lnbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRBbnkoYSwgYiksIHRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucGx1cyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZDtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAoYSA8IDAgIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChuLm5lZ2F0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgaWYgKGlzUHJlY2lzZShhICsgYikpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKGEgKyBiKTtcclxuICAgICAgICAgICAgYiA9IHNtYWxsVG9BcnJheShNYXRoLmFicyhiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbChiLCBNYXRoLmFicyhhKSksIGEgPCAwKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnBsdXMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmFkZDtcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSArIHBhcnNlVmFsdWUodikudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5wbHVzID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEgPj0gYlxyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkoYV9sKSxcclxuICAgICAgICAgICAgYm9ycm93ID0gMCxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGksIGRpZmZlcmVuY2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93IC0gYltpXTtcclxuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlICs9IGJhc2U7XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IGJfbDsgaSA8IGFfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93O1xyXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA8IDApIGRpZmZlcmVuY2UgKz0gYmFzZTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByW2krK10gPSBkaWZmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoOyBpIDwgYV9sOyBpKyspIHtcclxuICAgICAgICAgICAgcltpXSA9IGFbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3RBbnkoYSwgYiwgc2lnbikge1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICBpZiAoY29tcGFyZUFicyhhLCBiKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gc3VidHJhY3QoYSwgYik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBzdWJ0cmFjdChiLCBhKTtcclxuICAgICAgICAgICAgc2lnbiA9ICFzaWduO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZSA9IGFycmF5VG9TbWFsbCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAoc2lnbikgdmFsdWUgPSAtdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHZhbHVlLCBzaWduKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdFNtYWxsKGEsIGIsIHNpZ24pIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBiIGlzIG51bWJlciB3aXRoIDAgPD0gYiA8IE1BWF9JTlRcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxyXG4gICAgICAgICAgICBjYXJyeSA9IC1iLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgaSwgZGlmZmVyZW5jZTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihkaWZmZXJlbmNlIC8gYmFzZSk7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgJT0gYmFzZTtcclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2UgPCAwID8gZGlmZmVyZW5jZSArIGJhc2UgOiBkaWZmZXJlbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByID0gYXJyYXlUb1NtYWxsKHIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgciA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAoc2lnbikgciA9IC1yO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihyKTtcclxuICAgICAgICB9IHJldHVybiBuZXcgQmlnSW50ZWdlcihyLCBzaWduKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24gIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbClcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwoYSwgTWF0aC5hYnMoYiksIHRoaXMuc2lnbik7XHJcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0QW55KGEsIGIsIHRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWludXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmIChhIDwgMCAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChuLm5lZ2F0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYSAtIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbChiLCBNYXRoLmFicyhhKSwgYSA+PSAwKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm1pbnVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlIC0gcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm1pbnVzID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMudmFsdWUsICF0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzaWduID0gdGhpcy5zaWduO1xyXG4gICAgICAgIHZhciBzbWFsbCA9IG5ldyBTbWFsbEludGVnZXIoLXRoaXMudmFsdWUpO1xyXG4gICAgICAgIHNtYWxsLnNpZ24gPSAhc2lnbjtcclxuICAgICAgICByZXR1cm4gc21hbGw7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQoLXRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKE1hdGguYWJzKHRoaXMudmFsdWUpKTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlID49IDAgPyB0aGlzLnZhbHVlIDogLXRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUxvbmcoYSwgYikge1xyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIGwgPSBhX2wgKyBiX2wsXHJcbiAgICAgICAgICAgIHIgPSBjcmVhdGVBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHByb2R1Y3QsIGNhcnJ5LCBpLCBhX2ksIGJfajtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYV9sOyArK2kpIHtcclxuICAgICAgICAgICAgYV9pID0gYVtpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiX2w7ICsraikge1xyXG4gICAgICAgICAgICAgICAgYl9qID0gYltqXTtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3QgPSBhX2kgKiBiX2ogKyByW2kgKyBqXTtcclxuICAgICAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqICsgMV0gKz0gY2Fycnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpbShyKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseVNtYWxsKGEsIGIpIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBiIGlzIG51bWJlciB3aXRoIHxifCA8IEJBU0VcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgICBwcm9kdWN0LCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgcHJvZHVjdCA9IGFbaV0gKiBiICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XHJcbiAgICAgICAgICAgIHJbaV0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XHJcbiAgICAgICAgICAgIHJbaSsrXSA9IGNhcnJ5ICUgYmFzZTtcclxuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNoaWZ0TGVmdCh4LCBuKSB7XHJcbiAgICAgICAgdmFyIHIgPSBbXTtcclxuICAgICAgICB3aGlsZSAobi0tID4gMCkgci5wdXNoKDApO1xyXG4gICAgICAgIHJldHVybiByLmNvbmNhdCh4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUthcmF0c3ViYSh4LCB5KSB7XHJcbiAgICAgICAgdmFyIG4gPSBNYXRoLm1heCh4Lmxlbmd0aCwgeS5sZW5ndGgpO1xyXG5cclxuICAgICAgICBpZiAobiA8PSAzMCkgcmV0dXJuIG11bHRpcGx5TG9uZyh4LCB5KTtcclxuICAgICAgICBuID0gTWF0aC5jZWlsKG4gLyAyKTtcclxuXHJcbiAgICAgICAgdmFyIGIgPSB4LnNsaWNlKG4pLFxyXG4gICAgICAgICAgICBhID0geC5zbGljZSgwLCBuKSxcclxuICAgICAgICAgICAgZCA9IHkuc2xpY2UobiksXHJcbiAgICAgICAgICAgIGMgPSB5LnNsaWNlKDAsIG4pO1xyXG5cclxuICAgICAgICB2YXIgYWMgPSBtdWx0aXBseUthcmF0c3ViYShhLCBjKSxcclxuICAgICAgICAgICAgYmQgPSBtdWx0aXBseUthcmF0c3ViYShiLCBkKSxcclxuICAgICAgICAgICAgYWJjZCA9IG11bHRpcGx5S2FyYXRzdWJhKGFkZEFueShhLCBiKSwgYWRkQW55KGMsIGQpKTtcclxuXHJcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBhZGRBbnkoYWRkQW55KGFjLCBzaGlmdExlZnQoc3VidHJhY3Qoc3VidHJhY3QoYWJjZCwgYWMpLCBiZCksIG4pKSwgc2hpZnRMZWZ0KGJkLCAyICogbikpO1xyXG4gICAgICAgIHRyaW0ocHJvZHVjdCk7XHJcbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gYSBzdXJmYWNlIGZpdCBvZiBhIGdyYXBoIHBsb3R0aW5nIHRoZSBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlXHJcbiAgICAvLyBiZXR3ZWVuIGxvbmcgbXVsdGlwbGljYXRpb24gYW5kIGthcmF0c3ViYSBtdWx0aXBsaWNhdGlvbiB2ZXJzdXMgdGhlIGxlbmd0aHMgb2YgdGhlIHR3byBhcnJheXMuXHJcbiAgICBmdW5jdGlvbiB1c2VLYXJhdHN1YmEobDEsIGwyKSB7XHJcbiAgICAgICAgcmV0dXJuIC0wLjAxMiAqIGwxIC0gMC4wMTIgKiBsMiArIDAuMDAwMDE1ICogbDEgKiBsMiA+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlLFxyXG4gICAgICAgICAgICBzaWduID0gdGhpcy5zaWduICE9PSBuLnNpZ24sXHJcbiAgICAgICAgICAgIGFicztcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICAgICAgaWYgKGIgPT09IDEpIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gLTEpIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyhiKTtcclxuICAgICAgICAgICAgaWYgKGFicyA8IEJBU0UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseVNtYWxsKGEsIGFicyksIHNpZ24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoYWJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZUthcmF0c3ViYShhLmxlbmd0aCwgYi5sZW5ndGgpKSAvLyBLYXJhdHN1YmEgaXMgb25seSBmYXN0ZXIgZm9yIGNlcnRhaW4gYXJyYXkgc2l6ZXNcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5S2FyYXRzdWJhKGEsIGIpLCBzaWduKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGEsIGIpLCBzaWduKTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudGltZXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoYSwgYiwgc2lnbikgeyAvLyBhID49IDBcclxuICAgICAgICBpZiAoYSA8IEJBU0UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5U21hbGwoYiwgYSksIHNpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGIsIHNtYWxsVG9BcnJheShhKSksIHNpZ24pO1xyXG4gICAgfVxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5fbXVsdGlwbHlCeVNtYWxsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBpZiAoaXNQcmVjaXNlKGEudmFsdWUgKiB0aGlzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhLnZhbHVlICogdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoTWF0aC5hYnMoYS52YWx1ZSksIHNtYWxsVG9BcnJheShNYXRoLmFicyh0aGlzLnZhbHVlKSksIHRoaXMuc2lnbiAhPT0gYS5zaWduKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5fbXVsdGlwbHlCeVNtYWxsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICBpZiAoYS52YWx1ZSA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgaWYgKGEudmFsdWUgPT09IDEpIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGlmIChhLnZhbHVlID09PSAtMSkgcmV0dXJuIHRoaXMubmVnYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGx5U21hbGxBbmRBcnJheShNYXRoLmFicyhhLnZhbHVlKSwgdGhpcy52YWx1ZSwgdGhpcy5zaWduICE9PSBhLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHYpLl9tdWx0aXBseUJ5U21hbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50aW1lcyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAqIHBhcnNlVmFsdWUodikudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS50aW1lcyA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgZnVuY3Rpb24gc3F1YXJlKGEpIHtcclxuICAgICAgICAvL2NvbnNvbGUuYXNzZXJ0KDIgKiBCQVNFICogQkFTRSA8IE1BWF9JTlQpO1xyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBjcmVhdGVBcnJheShsICsgbCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBwcm9kdWN0LCBjYXJyeSwgaSwgYV9pLCBhX2o7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBhX2kgPSBhW2ldO1xyXG4gICAgICAgICAgICBjYXJyeSA9IDAgLSBhX2kgKiBhX2k7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBhX2ogPSBhW2pdO1xyXG4gICAgICAgICAgICAgICAgcHJvZHVjdCA9IDIgKiAoYV9pICogYV9qKSArIHJbaSArIGpdICsgY2Fycnk7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcltpICsgal0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbaSArIGxdID0gY2Fycnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUodGhpcy52YWx1ZSksIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSAqIHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGlzUHJlY2lzZSh2YWx1ZSkpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoc3F1YXJlKHNtYWxsVG9BcnJheShNYXRoLmFicyh0aGlzLnZhbHVlKSkpLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICogdGhpcy52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kMShhLCBiKSB7IC8vIExlZnQgb3ZlciBmcm9tIHByZXZpb3VzIHZlcnNpb24uIFBlcmZvcm1zIGZhc3RlciB0aGFuIGRpdk1vZDIgb24gc21hbGxlciBpbnB1dCBzaXplcy5cclxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlQXJyYXkoYi5sZW5ndGgpLFxyXG4gICAgICAgICAgICBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQgPSBiW2JfbCAtIDFdLFxyXG4gICAgICAgICAgICAvLyBub3JtYWxpemF0aW9uXHJcbiAgICAgICAgICAgIGxhbWJkYSA9IE1hdGguY2VpbChiYXNlIC8gKDIgKiBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpKSxcclxuICAgICAgICAgICAgcmVtYWluZGVyID0gbXVsdGlwbHlTbWFsbChhLCBsYW1iZGEpLFxyXG4gICAgICAgICAgICBkaXZpc29yID0gbXVsdGlwbHlTbWFsbChiLCBsYW1iZGEpLFxyXG4gICAgICAgICAgICBxdW90aWVudERpZ2l0LCBzaGlmdCwgY2FycnksIGJvcnJvdywgaSwgbCwgcTtcclxuICAgICAgICBpZiAocmVtYWluZGVyLmxlbmd0aCA8PSBhX2wpIHJlbWFpbmRlci5wdXNoKDApO1xyXG4gICAgICAgIGRpdmlzb3IucHVzaCgwKTtcclxuICAgICAgICBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQgPSBkaXZpc29yW2JfbCAtIDFdO1xyXG4gICAgICAgIGZvciAoc2hpZnQgPSBhX2wgLSBiX2w7IHNoaWZ0ID49IDA7IHNoaWZ0LS0pIHtcclxuICAgICAgICAgICAgcXVvdGllbnREaWdpdCA9IGJhc2UgLSAxO1xyXG4gICAgICAgICAgICBpZiAocmVtYWluZGVyW3NoaWZ0ICsgYl9sXSAhPT0gZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KSB7XHJcbiAgICAgICAgICAgICAgICBxdW90aWVudERpZ2l0ID0gTWF0aC5mbG9vcigocmVtYWluZGVyW3NoaWZ0ICsgYl9sXSAqIGJhc2UgKyByZW1haW5kZXJbc2hpZnQgKyBiX2wgLSAxXSkgLyBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHF1b3RpZW50RGlnaXQgPD0gYmFzZSAtIDFcclxuICAgICAgICAgICAgY2FycnkgPSAwO1xyXG4gICAgICAgICAgICBib3Jyb3cgPSAwO1xyXG4gICAgICAgICAgICBsID0gZGl2aXNvci5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNhcnJ5ICs9IHF1b3RpZW50RGlnaXQgKiBkaXZpc29yW2ldO1xyXG4gICAgICAgICAgICAgICAgcSA9IE1hdGguZmxvb3IoY2FycnkgLyBiYXNlKTtcclxuICAgICAgICAgICAgICAgIGJvcnJvdyArPSByZW1haW5kZXJbc2hpZnQgKyBpXSAtIChjYXJyeSAtIHEgKiBiYXNlKTtcclxuICAgICAgICAgICAgICAgIGNhcnJ5ID0gcTtcclxuICAgICAgICAgICAgICAgIGlmIChib3Jyb3cgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBib3Jyb3cgKyBiYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcnJvdyA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGJvcnJvdztcclxuICAgICAgICAgICAgICAgICAgICBib3Jyb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChib3Jyb3cgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHF1b3RpZW50RGlnaXQgLT0gMTtcclxuICAgICAgICAgICAgICAgIGNhcnJ5ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXJyeSArPSByZW1haW5kZXJbc2hpZnQgKyBpXSAtIGJhc2UgKyBkaXZpc29yW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXJyeSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBjYXJyeSArIGJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGNhcnJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm9ycm93ICs9IGNhcnJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdFtzaGlmdF0gPSBxdW90aWVudERpZ2l0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZW5vcm1hbGl6YXRpb25cclxuICAgICAgICByZW1haW5kZXIgPSBkaXZNb2RTbWFsbChyZW1haW5kZXIsIGxhbWJkYSlbMF07XHJcbiAgICAgICAgcmV0dXJuIFthcnJheVRvU21hbGwocmVzdWx0KSwgYXJyYXlUb1NtYWxsKHJlbWFpbmRlcildO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpdk1vZDIoYSwgYikgeyAvLyBJbXBsZW1lbnRhdGlvbiBpZGVhIHNoYW1lbGVzc2x5IHN0b2xlbiBmcm9tIFNpbGVudCBNYXR0J3MgbGlicmFyeSBodHRwOi8vc2lsZW50bWF0dC5jb20vYmlnaW50ZWdlci9cclxuICAgICAgICAvLyBQZXJmb3JtcyBmYXN0ZXIgdGhhbiBkaXZNb2QxIG9uIGxhcmdlciBpbnB1dCBzaXplcy5cclxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcclxuICAgICAgICAgICAgcGFydCA9IFtdLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgZ3Vlc3MsIHhsZW4sIGhpZ2h4LCBoaWdoeSwgY2hlY2s7XHJcbiAgICAgICAgd2hpbGUgKGFfbCkge1xyXG4gICAgICAgICAgICBwYXJ0LnVuc2hpZnQoYVstLWFfbF0pO1xyXG4gICAgICAgICAgICB0cmltKHBhcnQpO1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyZUFicyhwYXJ0LCBiKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKDApO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeGxlbiA9IHBhcnQubGVuZ3RoO1xyXG4gICAgICAgICAgICBoaWdoeCA9IHBhcnRbeGxlbiAtIDFdICogYmFzZSArIHBhcnRbeGxlbiAtIDJdO1xyXG4gICAgICAgICAgICBoaWdoeSA9IGJbYl9sIC0gMV0gKiBiYXNlICsgYltiX2wgLSAyXTtcclxuICAgICAgICAgICAgaWYgKHhsZW4gPiBiX2wpIHtcclxuICAgICAgICAgICAgICAgIGhpZ2h4ID0gKGhpZ2h4ICsgMSkgKiBiYXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGd1ZXNzID0gTWF0aC5jZWlsKGhpZ2h4IC8gaGlnaHkpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBjaGVjayA9IG11bHRpcGx5U21hbGwoYiwgZ3Vlc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVBYnMoY2hlY2ssIHBhcnQpIDw9IDApIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZ3Vlc3MtLTtcclxuICAgICAgICAgICAgfSB3aGlsZSAoZ3Vlc3MpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChndWVzcyk7XHJcbiAgICAgICAgICAgIHBhcnQgPSBzdWJ0cmFjdChwYXJ0LCBjaGVjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgcmV0dXJuIFthcnJheVRvU21hbGwocmVzdWx0KSwgYXJyYXlUb1NtYWxsKHBhcnQpXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXZNb2RTbWFsbCh2YWx1ZSwgbGFtYmRhKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCxcclxuICAgICAgICAgICAgcXVvdGllbnQgPSBjcmVhdGVBcnJheShsZW5ndGgpLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgaSwgcSwgcmVtYWluZGVyLCBkaXZpc29yO1xyXG4gICAgICAgIHJlbWFpbmRlciA9IDA7XHJcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgZGl2aXNvciA9IHJlbWFpbmRlciAqIGJhc2UgKyB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgcSA9IHRydW5jYXRlKGRpdmlzb3IgLyBsYW1iZGEpO1xyXG4gICAgICAgICAgICByZW1haW5kZXIgPSBkaXZpc29yIC0gcSAqIGxhbWJkYTtcclxuICAgICAgICAgICAgcXVvdGllbnRbaV0gPSBxIHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtxdW90aWVudCwgcmVtYWluZGVyIHwgMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kQW55KHNlbGYsIHYpIHtcclxuICAgICAgICB2YXIgdmFsdWUsIG4gPSBwYXJzZVZhbHVlKHYpO1xyXG4gICAgICAgIGlmIChzdXBwb3J0c05hdGl2ZUJpZ0ludCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW25ldyBOYXRpdmVCaWdJbnQoc2VsZi52YWx1ZSAvIG4udmFsdWUpLCBuZXcgTmF0aXZlQmlnSW50KHNlbGYudmFsdWUgJSBuLnZhbHVlKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gc2VsZi52YWx1ZSwgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgdmFyIHF1b3RpZW50O1xyXG4gICAgICAgIGlmIChiID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGl2aWRlIGJ5IHplcm9cIik7XHJcbiAgICAgICAgaWYgKHNlbGYuaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBTbWFsbEludGVnZXIodHJ1bmNhdGUoYSAvIGIpKSwgbmV3IFNtYWxsSW50ZWdlcihhICUgYildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbSW50ZWdlclswXSwgc2VsZl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgaWYgKGIgPT09IDEpIHJldHVybiBbc2VsZiwgSW50ZWdlclswXV07XHJcbiAgICAgICAgICAgIGlmIChiID09IC0xKSByZXR1cm4gW3NlbGYubmVnYXRlKCksIEludGVnZXJbMF1dO1xyXG4gICAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMoYik7XHJcbiAgICAgICAgICAgIGlmIChhYnMgPCBCQVNFKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRpdk1vZFNtYWxsKGEsIGFicyk7XHJcbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IGFycmF5VG9TbWFsbCh2YWx1ZVswXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gdmFsdWVbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaWduKSByZW1haW5kZXIgPSAtcmVtYWluZGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxdW90aWVudCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNpZ24gIT09IG4uc2lnbikgcXVvdGllbnQgPSAtcXVvdGllbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgU21hbGxJbnRlZ2VyKHF1b3RpZW50KSwgbmV3IFNtYWxsSW50ZWdlcihyZW1haW5kZXIpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IEJpZ0ludGVnZXIocXVvdGllbnQsIHNlbGYuc2lnbiAhPT0gbi5zaWduKSwgbmV3IFNtYWxsSW50ZWdlcihyZW1haW5kZXIpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gc21hbGxUb0FycmF5KGFicyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb21wYXJpc29uID0gY29tcGFyZUFicyhhLCBiKTtcclxuICAgICAgICBpZiAoY29tcGFyaXNvbiA9PT0gLTEpIHJldHVybiBbSW50ZWdlclswXSwgc2VsZl07XHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gPT09IDApIHJldHVybiBbSW50ZWdlcltzZWxmLnNpZ24gPT09IG4uc2lnbiA/IDEgOiAtMV0sIEludGVnZXJbMF1dO1xyXG5cclxuICAgICAgICAvLyBkaXZNb2QxIGlzIGZhc3RlciBvbiBzbWFsbGVyIGlucHV0IHNpemVzXHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICsgYi5sZW5ndGggPD0gMjAwKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IGRpdk1vZDEoYSwgYik7XHJcbiAgICAgICAgZWxzZSB2YWx1ZSA9IGRpdk1vZDIoYSwgYik7XHJcblxyXG4gICAgICAgIHF1b3RpZW50ID0gdmFsdWVbMF07XHJcbiAgICAgICAgdmFyIHFTaWduID0gc2VsZi5zaWduICE9PSBuLnNpZ24sXHJcbiAgICAgICAgICAgIG1vZCA9IHZhbHVlWzFdLFxyXG4gICAgICAgICAgICBtU2lnbiA9IHNlbGYuc2lnbjtcclxuICAgICAgICBpZiAodHlwZW9mIHF1b3RpZW50ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChxU2lnbikgcXVvdGllbnQgPSAtcXVvdGllbnQ7XHJcbiAgICAgICAgICAgIHF1b3RpZW50ID0gbmV3IFNtYWxsSW50ZWdlcihxdW90aWVudCk7XHJcbiAgICAgICAgfSBlbHNlIHF1b3RpZW50ID0gbmV3IEJpZ0ludGVnZXIocXVvdGllbnQsIHFTaWduKTtcclxuICAgICAgICBpZiAodHlwZW9mIG1vZCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAobVNpZ24pIG1vZCA9IC1tb2Q7XHJcbiAgICAgICAgICAgIG1vZCA9IG5ldyBTbWFsbEludGVnZXIobW9kKTtcclxuICAgICAgICB9IGVsc2UgbW9kID0gbmV3IEJpZ0ludGVnZXIobW9kLCBtU2lnbik7XHJcbiAgICAgICAgcmV0dXJuIFtxdW90aWVudCwgbW9kXTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBkaXZNb2RBbnkodGhpcywgdik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcXVvdGllbnQ6IHJlc3VsdFswXSxcclxuICAgICAgICAgICAgcmVtYWluZGVyOiByZXN1bHRbMV1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZGl2bW9kID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2Q7XHJcblxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpdk1vZEFueSh0aGlzLCB2KVswXTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm92ZXIgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAvIHBhcnNlVmFsdWUodikudmFsdWUpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUub3ZlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gQmlnSW50ZWdlci5wcm90b3R5cGUub3ZlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBkaXZNb2RBbnkodGhpcywgdilbMV07XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tb2QgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnJlbWFpbmRlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAlIHBhcnNlVmFsdWUodikudmFsdWUpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2Q7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxyXG4gICAgICAgICAgICBiID0gbi52YWx1ZSxcclxuICAgICAgICAgICAgdmFsdWUsIHgsIHk7XHJcbiAgICAgICAgaWYgKGIgPT09IDApIHJldHVybiBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIGlmIChhID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICBpZiAoYSA9PT0gMSkgcmV0dXJuIEludGVnZXJbMV07XHJcbiAgICAgICAgaWYgKGEgPT09IC0xKSByZXR1cm4gbi5pc0V2ZW4oKSA/IEludGVnZXJbMV0gOiBJbnRlZ2VyWy0xXTtcclxuICAgICAgICBpZiAobi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW4uaXNTbWFsbCkgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGV4cG9uZW50IFwiICsgbi50b1N0cmluZygpICsgXCIgaXMgdG9vIGxhcmdlLlwiKTtcclxuICAgICAgICBpZiAodGhpcy5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UodmFsdWUgPSBNYXRoLnBvdyhhLCBiKSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih0cnVuY2F0ZSh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB4ID0gdGhpcztcclxuICAgICAgICB5ID0gSW50ZWdlclsxXTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoYiAmIDEgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgICAgICAgLS1iO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgYiAvPSAyO1xyXG4gICAgICAgICAgICB4ID0geC5zcXVhcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3c7XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIHZhciBfMCA9IEJpZ0ludCgwKSwgXzEgPSBCaWdJbnQoMSksIF8yID0gQmlnSW50KDIpO1xyXG4gICAgICAgIGlmIChiID09PSBfMCkgcmV0dXJuIEludGVnZXJbMV07XHJcbiAgICAgICAgaWYgKGEgPT09IF8wKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICBpZiAoYSA9PT0gXzEpIHJldHVybiBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIGlmIChhID09PSBCaWdJbnQoLTEpKSByZXR1cm4gbi5pc0V2ZW4oKSA/IEludGVnZXJbMV0gOiBJbnRlZ2VyWy0xXTtcclxuICAgICAgICBpZiAobi5pc05lZ2F0aXZlKCkpIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KF8wKTtcclxuICAgICAgICB2YXIgeCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHkgPSBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICgoYiAmIF8xKSA9PT0gXzEpIHtcclxuICAgICAgICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgICAgICAgLS1iO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiID09PSBfMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIGIgLz0gXzI7XHJcbiAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBmdW5jdGlvbiAoZXhwLCBtb2QpIHtcclxuICAgICAgICBleHAgPSBwYXJzZVZhbHVlKGV4cCk7XHJcbiAgICAgICAgbW9kID0gcGFyc2VWYWx1ZShtb2QpO1xyXG4gICAgICAgIGlmIChtb2QuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0YWtlIG1vZFBvdyB3aXRoIG1vZHVsdXMgMFwiKTtcclxuICAgICAgICB2YXIgciA9IEludGVnZXJbMV0sXHJcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLm1vZChtb2QpO1xyXG4gICAgICAgIGlmIChleHAuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGV4cCA9IGV4cC5tdWx0aXBseShJbnRlZ2VyWy0xXSk7XHJcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLm1vZEludihtb2QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoZXhwLmlzUG9zaXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZS5pc1plcm8oKSkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgICAgIGlmIChleHAuaXNPZGQoKSkgciA9IHIubXVsdGlwbHkoYmFzZSkubW9kKG1vZCk7XHJcbiAgICAgICAgICAgIGV4cCA9IGV4cC5kaXZpZGUoMik7XHJcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnNxdWFyZSgpLm1vZChtb2QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm1vZFBvdyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBYnMoYSwgYikge1xyXG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHJldHVybiAxO1xyXG4gICAgICAgIHJldHVybiBjb21wYXJlQWJzKGEsIGIpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gTWF0aC5hYnModGhpcy52YWx1ZSksXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgYiA9IE1hdGguYWJzKGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIHZhciBiID0gcGFyc2VWYWx1ZSh2KS52YWx1ZTtcclxuICAgICAgICBhID0gYSA+PSAwID8gYSA6IC1hO1xyXG4gICAgICAgIGIgPSBiID49IDAgPyBiIDogLWI7XHJcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gYWJvdXQgY29tcGFyaXNvbiB3aXRoIEluZmluaXR5OlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRlcm9sc29uL0JpZ0ludGVnZXIuanMvaXNzdWVzLzYxXHJcbiAgICAgICAgaWYgKHYgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYgPT09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24gIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbi5zaWduID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ24gPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wYXJlQWJzKGEsIGIpICogKHRoaXMuc2lnbiA/IC0xIDogMSk7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh2ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxyXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhID09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhIDwgMCAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEgPCAwID8gMSA6IC0xO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHYgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYgPT09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIHZhciBiID0gcGFyc2VWYWx1ZSh2KS52YWx1ZTtcclxuICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcclxuICAgIH1cclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZVRvID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA9PT0gMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmVxID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5lcXVhbHMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmVxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscztcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgIT09IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5uZXEgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5vdEVxdWFscyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmVxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA+IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ndCA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZ3JlYXRlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3QgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmdyZWF0ZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ndCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXI7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpIDwgMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmx0ID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5sZXNzZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmx0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3NlcjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPj0gMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmdlcSA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5nZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmdlcSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscztcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA8PSAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubGVxID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5sZXNzZXJPckVxdWFscyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmxlcSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWVbMF0gJiAxKSA9PT0gMDtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiAxKSA9PT0gMDtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiBCaWdJbnQoMSkpID09PSBCaWdJbnQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlWzBdICYgMSkgPT09IDE7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiAxKSA9PT0gMTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIEJpZ0ludCgxKSkgPT09IEJpZ0ludCgxKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5zaWduO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA+IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbjtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPCAwO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnZhbHVlKSA9PT0gMTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hYnMoKS52YWx1ZSA9PT0gQmlnSW50KDEpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IEJpZ0ludCgwKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgaWYgKG4uaXNaZXJvKCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAobi5pc1VuaXQoKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKG4uY29tcGFyZUFicygyKSA9PT0gMCkgcmV0dXJuIHRoaXMuaXNFdmVuKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kKG4pLmlzWmVybygpO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNEaXZpc2libGVCeSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnk7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNCYXNpY1ByaW1lKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHYuYWJzKCk7XHJcbiAgICAgICAgaWYgKG4uaXNVbml0KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAobi5lcXVhbHMoMikgfHwgbi5lcXVhbHMoMykgfHwgbi5lcXVhbHMoNSkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChuLmlzRXZlbigpIHx8IG4uaXNEaXZpc2libGVCeSgzKSB8fCBuLmlzRGl2aXNpYmxlQnkoNSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAobi5sZXNzZXIoNDkpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgcHJpbWU6IGxldCB0aGUgb3RoZXIgZnVuY3Rpb25zIGZpZ3VyZSBpdCBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtaWxsZXJSYWJpblRlc3QobiwgYSkge1xyXG4gICAgICAgIHZhciBuUHJldiA9IG4ucHJldigpLFxyXG4gICAgICAgICAgICBiID0gblByZXYsXHJcbiAgICAgICAgICAgIHIgPSAwLFxyXG4gICAgICAgICAgICBkLCB0LCBpLCB4O1xyXG4gICAgICAgIHdoaWxlIChiLmlzRXZlbigpKSBiID0gYi5kaXZpZGUoMiksIHIrKztcclxuICAgICAgICBuZXh0OiBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobi5sZXNzZXIoYVtpXSkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB4ID0gYmlnSW50KGFbaV0pLm1vZFBvdyhiLCBuKTtcclxuICAgICAgICAgICAgaWYgKHguaXNVbml0KCkgfHwgeC5lcXVhbHMoblByZXYpKSBjb250aW51ZTtcclxuICAgICAgICAgICAgZm9yIChkID0gciAtIDE7IGQgIT0gMDsgZC0tKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0geC5zcXVhcmUoKS5tb2Qobik7XHJcbiAgICAgICAgICAgICAgICBpZiAoeC5pc1VuaXQoKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHguZXF1YWxzKG5QcmV2KSkgY29udGludWUgbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBcInN0cmljdFwiIHRvIHRydWUgdG8gZm9yY2UgR1JILXN1cHBvcnRlZCBsb3dlciBib3VuZCBvZiAyKmxvZyhOKV4yXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lID0gZnVuY3Rpb24gKHN0cmljdCkge1xyXG4gICAgICAgIHZhciBpc1ByaW1lID0gaXNCYXNpY1ByaW1lKHRoaXMpO1xyXG4gICAgICAgIGlmIChpc1ByaW1lICE9PSB1bmRlZmluZWQpIHJldHVybiBpc1ByaW1lO1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5hYnMoKTtcclxuICAgICAgICB2YXIgYml0cyA9IG4uYml0TGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGJpdHMgPD0gNjQpXHJcbiAgICAgICAgICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgWzIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjksIDMxLCAzN10pO1xyXG4gICAgICAgIHZhciBsb2dOID0gTWF0aC5sb2coMikgKiBiaXRzLnRvSlNOdW1iZXIoKTtcclxuICAgICAgICB2YXIgdCA9IE1hdGguY2VpbCgoc3RyaWN0ID09PSB0cnVlKSA/ICgyICogTWF0aC5wb3cobG9nTiwgMikpIDogbG9nTik7XHJcbiAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBpID0gMDsgaSA8IHQ7IGkrKykge1xyXG4gICAgICAgICAgICBhLnB1c2goYmlnSW50KGkgKyAyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgYSk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1ByaW1lID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBmdW5jdGlvbiAoaXRlcmF0aW9ucywgcm5nKSB7XHJcbiAgICAgICAgdmFyIGlzUHJpbWUgPSBpc0Jhc2ljUHJpbWUodGhpcyk7XHJcbiAgICAgICAgaWYgKGlzUHJpbWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzUHJpbWU7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLmFicygpO1xyXG4gICAgICAgIHZhciB0ID0gaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkID8gNSA6IGl0ZXJhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBpID0gMDsgaSA8IHQ7IGkrKykge1xyXG4gICAgICAgICAgICBhLnB1c2goYmlnSW50LnJhbmRCZXR3ZWVuKDIsIG4ubWludXMoMiksIHJuZykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWlsbGVyUmFiaW5UZXN0KG4sIGEpO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWU7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB2YXIgdCA9IGJpZ0ludC56ZXJvLCBuZXdUID0gYmlnSW50Lm9uZSwgciA9IHBhcnNlVmFsdWUobiksIG5ld1IgPSB0aGlzLmFicygpLCBxLCBsYXN0VCwgbGFzdFI7XHJcbiAgICAgICAgd2hpbGUgKCFuZXdSLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIHEgPSByLmRpdmlkZShuZXdSKTtcclxuICAgICAgICAgICAgbGFzdFQgPSB0O1xyXG4gICAgICAgICAgICBsYXN0UiA9IHI7XHJcbiAgICAgICAgICAgIHQgPSBuZXdUO1xyXG4gICAgICAgICAgICByID0gbmV3UjtcclxuICAgICAgICAgICAgbmV3VCA9IGxhc3RULnN1YnRyYWN0KHEubXVsdGlwbHkobmV3VCkpO1xyXG4gICAgICAgICAgICBuZXdSID0gbGFzdFIuc3VidHJhY3QocS5tdWx0aXBseShuZXdSKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghci5pc1VuaXQoKSkgdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSArIFwiIGFuZCBcIiArIG4udG9TdHJpbmcoKSArIFwiIGFyZSBub3QgY28tcHJpbWVcIik7XHJcbiAgICAgICAgaWYgKHQuY29tcGFyZSgwKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdCA9IHQuYWRkKG4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHQubmVnYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm1vZEludiA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kSW52ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKHZhbHVlLCAxLCB0aGlzLnNpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwodmFsdWUsIDEpLCB0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSArIDEgPCBNQVhfSU5UKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSArIDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihNQVhfSU5UX0FSUiwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICsgQmlnSW50KDEpKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwodmFsdWUsIDEpLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwodmFsdWUsIDEsIHRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlIC0gMSA+IC1NQVhfSU5UKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSAtIDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihNQVhfSU5UX0FSUiwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgLSBCaWdJbnQoMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwb3dlcnNPZlR3byA9IFsxXTtcclxuICAgIHdoaWxlICgyICogcG93ZXJzT2ZUd29bcG93ZXJzT2ZUd28ubGVuZ3RoIC0gMV0gPD0gQkFTRSkgcG93ZXJzT2ZUd28ucHVzaCgyICogcG93ZXJzT2ZUd29bcG93ZXJzT2ZUd28ubGVuZ3RoIC0gMV0pO1xyXG4gICAgdmFyIHBvd2VyczJMZW5ndGggPSBwb3dlcnNPZlR3by5sZW5ndGgsIGhpZ2hlc3RQb3dlcjIgPSBwb3dlcnNPZlR3b1twb3dlcnMyTGVuZ3RoIC0gMV07XHJcblxyXG4gICAgZnVuY3Rpb24gc2hpZnRfaXNTbWFsbChuKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKG4pIDw9IEJBU0U7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodikudG9KU051bWJlcigpO1xyXG4gICAgICAgIGlmICghc2hpZnRfaXNTbWFsbChuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pICsgXCIgaXMgdG9vIGxhcmdlIGZvciBzaGlmdGluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuIDwgMCkgcmV0dXJuIHRoaXMuc2hpZnRSaWdodCgtbik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5pc1plcm8oKSkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB3aGlsZSAobiA+PSBwb3dlcnMyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgbiAtPSBwb3dlcnMyTGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tdWx0aXBseShwb3dlcnNPZlR3b1tuXSk7XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zaGlmdExlZnQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgcmVtUXVvO1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgaWYgKCFzaGlmdF9pc1NtYWxsKG4pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihTdHJpbmcobikgKyBcIiBpcyB0b28gbGFyZ2UgZm9yIHNoaWZ0aW5nLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4gPCAwKSByZXR1cm4gdGhpcy5zaGlmdExlZnQoLW4pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChuID49IHBvd2VyczJMZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5pc1plcm8oKSB8fCAocmVzdWx0LmlzTmVnYXRpdmUoKSAmJiByZXN1bHQuaXNVbml0KCkpKSByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICByZW1RdW8gPSBkaXZNb2RBbnkocmVzdWx0LCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XHJcbiAgICAgICAgICAgIG4gLT0gcG93ZXJzMkxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbVF1byA9IGRpdk1vZEFueShyZXN1bHQsIHBvd2Vyc09mVHdvW25dKTtcclxuICAgICAgICByZXR1cm4gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XHJcbiAgICB9O1xyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbiAgICBmdW5jdGlvbiBiaXR3aXNlKHgsIHksIGZuKSB7XHJcbiAgICAgICAgeSA9IHBhcnNlVmFsdWUoeSk7XHJcbiAgICAgICAgdmFyIHhTaWduID0geC5pc05lZ2F0aXZlKCksIHlTaWduID0geS5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgdmFyIHhSZW0gPSB4U2lnbiA/IHgubm90KCkgOiB4LFxyXG4gICAgICAgICAgICB5UmVtID0geVNpZ24gPyB5Lm5vdCgpIDogeTtcclxuICAgICAgICB2YXIgeERpZ2l0ID0gMCwgeURpZ2l0ID0gMDtcclxuICAgICAgICB2YXIgeERpdk1vZCA9IG51bGwsIHlEaXZNb2QgPSBudWxsO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICB3aGlsZSAoIXhSZW0uaXNaZXJvKCkgfHwgIXlSZW0uaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgeERpdk1vZCA9IGRpdk1vZEFueSh4UmVtLCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgeERpZ2l0ID0geERpdk1vZFsxXS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmICh4U2lnbikge1xyXG4gICAgICAgICAgICAgICAgeERpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB4RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeURpdk1vZCA9IGRpdk1vZEFueSh5UmVtLCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgeURpZ2l0ID0geURpdk1vZFsxXS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmICh5U2lnbikge1xyXG4gICAgICAgICAgICAgICAgeURpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB5RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeFJlbSA9IHhEaXZNb2RbMF07XHJcbiAgICAgICAgICAgIHlSZW0gPSB5RGl2TW9kWzBdO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChmbih4RGlnaXQsIHlEaWdpdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3VtID0gZm4oeFNpZ24gPyAxIDogMCwgeVNpZ24gPyAxIDogMCkgIT09IDAgPyBiaWdJbnQoLTEpIDogYmlnSW50KDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgc3VtID0gc3VtLm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpLmFkZChiaWdJbnQocmVzdWx0W2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLnByZXYoKTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5vdCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubm90ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubm90O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgcmV0dXJuIGJpdHdpc2UodGhpcywgbiwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgJiBiOyB9KTtcclxuICAgIH07XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmFuZCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYW5kID0gQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICByZXR1cm4gYml0d2lzZSh0aGlzLCBuLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSB8IGI7IH0pO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUub3IgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm9yID0gQmlnSW50ZWdlci5wcm90b3R5cGUub3I7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICByZXR1cm4gYml0d2lzZSh0aGlzLCBuLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSBeIGI7IH0pO1xyXG4gICAgfTtcclxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUueG9yID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3I7XHJcblxyXG4gICAgdmFyIExPQk1BU0tfSSA9IDEgPDwgMzAsIExPQk1BU0tfQkkgPSAoQkFTRSAmIC1CQVNFKSAqIChCQVNFICYgLUJBU0UpIHwgTE9CTUFTS19JO1xyXG4gICAgZnVuY3Rpb24gcm91Z2hMT0IobikgeyAvLyBnZXQgbG93ZXN0T25lQml0IChyb3VnaClcclxuICAgICAgICAvLyBTbWFsbEludGVnZXI6IHJldHVybiBNaW4obG93ZXN0T25lQml0KG4pLCAxIDw8IDMwKVxyXG4gICAgICAgIC8vIEJpZ0ludGVnZXI6IHJldHVybiBNaW4obG93ZXN0T25lQml0KG4pLCAxIDw8IDE0KSBbQkFTRT0xZTddXHJcbiAgICAgICAgdmFyIHYgPSBuLnZhbHVlLFxyXG4gICAgICAgICAgICB4ID0gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyB2IHwgTE9CTUFTS19JIDpcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB2ID09PSBcImJpZ2ludFwiID8gdiB8IEJpZ0ludChMT0JNQVNLX0kpIDpcclxuICAgICAgICAgICAgICAgICAgICB2WzBdICsgdlsxXSAqIEJBU0UgfCBMT0JNQVNLX0JJO1xyXG4gICAgICAgIHJldHVybiB4ICYgLXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW50ZWdlckxvZ2FyaXRobSh2YWx1ZSwgYmFzZSkge1xyXG4gICAgICAgIGlmIChiYXNlLmNvbXBhcmVUbyh2YWx1ZSkgPD0gMCkge1xyXG4gICAgICAgICAgICB2YXIgdG1wID0gaW50ZWdlckxvZ2FyaXRobSh2YWx1ZSwgYmFzZS5zcXVhcmUoYmFzZSkpO1xyXG4gICAgICAgICAgICB2YXIgcCA9IHRtcC5wO1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRtcC5lO1xyXG4gICAgICAgICAgICB2YXIgdCA9IHAubXVsdGlwbHkoYmFzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0LmNvbXBhcmVUbyh2YWx1ZSkgPD0gMCA/IHsgcDogdCwgZTogZSAqIDIgKyAxIH0gOiB7IHA6IHAsIGU6IGUgKiAyIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHA6IGJpZ0ludCgxKSwgZTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKG4uY29tcGFyZVRvKGJpZ0ludCgwKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLm5lZ2F0ZSgpLnN1YnRyYWN0KGJpZ0ludCgxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmNvbXBhcmVUbyhiaWdJbnQoMCkpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaWdJbnQoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiaWdJbnQoaW50ZWdlckxvZ2FyaXRobShuLCBiaWdJbnQoMikpLmUpLmFkZChiaWdJbnQoMSkpO1xyXG4gICAgfVxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5iaXRMZW5ndGggPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aDtcclxuXHJcbiAgICBmdW5jdGlvbiBtYXgoYSwgYikge1xyXG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpO1xyXG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpO1xyXG4gICAgICAgIHJldHVybiBhLmdyZWF0ZXIoYikgPyBhIDogYjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1pbihhLCBiKSB7XHJcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSk7XHJcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYik7XHJcbiAgICAgICAgcmV0dXJuIGEubGVzc2VyKGIpID8gYSA6IGI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnY2QoYSwgYikge1xyXG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpLmFicygpO1xyXG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpLmFicygpO1xyXG4gICAgICAgIGlmIChhLmVxdWFscyhiKSkgcmV0dXJuIGE7XHJcbiAgICAgICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBiO1xyXG4gICAgICAgIGlmIChiLmlzWmVybygpKSByZXR1cm4gYTtcclxuICAgICAgICB2YXIgYyA9IEludGVnZXJbMV0sIGQsIHQ7XHJcbiAgICAgICAgd2hpbGUgKGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKSkge1xyXG4gICAgICAgICAgICBkID0gbWluKHJvdWdoTE9CKGEpLCByb3VnaExPQihiKSk7XHJcbiAgICAgICAgICAgIGEgPSBhLmRpdmlkZShkKTtcclxuICAgICAgICAgICAgYiA9IGIuZGl2aWRlKGQpO1xyXG4gICAgICAgICAgICBjID0gYy5tdWx0aXBseShkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgYSA9IGEuZGl2aWRlKHJvdWdoTE9CKGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGIuZGl2aWRlKHJvdWdoTE9CKGIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYS5ncmVhdGVyKGIpKSB7XHJcbiAgICAgICAgICAgICAgICB0ID0gYjsgYiA9IGE7IGEgPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBiLnN1YnRyYWN0KGEpO1xyXG4gICAgICAgIH0gd2hpbGUgKCFiLmlzWmVybygpKTtcclxuICAgICAgICByZXR1cm4gYy5pc1VuaXQoKSA/IGEgOiBhLm11bHRpcGx5KGMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGNtKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcclxuICAgICAgICByZXR1cm4gYS5kaXZpZGUoZ2NkKGEsIGIpKS5tdWx0aXBseShiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmRCZXR3ZWVuKGEsIGIsIHJuZykge1xyXG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpO1xyXG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpO1xyXG4gICAgICAgIHZhciB1c2VkUk5HID0gcm5nIHx8IE1hdGgucmFuZG9tO1xyXG4gICAgICAgIHZhciBsb3cgPSBtaW4oYSwgYiksIGhpZ2ggPSBtYXgoYSwgYik7XHJcbiAgICAgICAgdmFyIHJhbmdlID0gaGlnaC5zdWJ0cmFjdChsb3cpLmFkZCgxKTtcclxuICAgICAgICBpZiAocmFuZ2UuaXNTbWFsbCkgcmV0dXJuIGxvdy5hZGQoTWF0aC5mbG9vcih1c2VkUk5HKCkgKiByYW5nZSkpO1xyXG4gICAgICAgIHZhciBkaWdpdHMgPSB0b0Jhc2UocmFuZ2UsIEJBU0UpLnZhbHVlO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgcmVzdHJpY3RlZCA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHRvcCA9IHJlc3RyaWN0ZWQgPyBkaWdpdHNbaV0gKyAoaSArIDEgPCBkaWdpdHMubGVuZ3RoID8gZGlnaXRzW2kgKyAxXSAvIEJBU0UgOiAwKSA6IEJBU0U7XHJcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IHRydW5jYXRlKHVzZWRSTkcoKSAqIHRvcCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRpZ2l0KTtcclxuICAgICAgICAgICAgaWYgKGRpZ2l0IDwgZGlnaXRzW2ldKSByZXN0cmljdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb3cuYWRkKEludGVnZXIuZnJvbUFycmF5KHJlc3VsdCwgQkFTRSwgZmFsc2UpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFyc2VCYXNlID0gZnVuY3Rpb24gKHRleHQsIGJhc2UsIGFscGhhYmV0LCBjYXNlU2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgYWxwaGFiZXQgPSBhbHBoYWJldCB8fCBERUZBVUxUX0FMUEhBQkVUO1xyXG4gICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XHJcbiAgICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGFscGhhYmV0ID0gYWxwaGFiZXQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBhYnNCYXNlID0gTWF0aC5hYnMoYmFzZSk7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0VmFsdWVzID0ge307XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFscGhhYmV0VmFsdWVzW2FscGhhYmV0W2ldXSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRleHRbaV07XHJcbiAgICAgICAgICAgIGlmIChjID09PSBcIi1cIikgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChjIGluIGFscGhhYmV0VmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGFiZXRWYWx1ZXNbY10gPj0gYWJzQmFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIjFcIiAmJiBhYnNCYXNlID09PSAxKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYyArIFwiIGlzIG5vdCBhIHZhbGlkIGRpZ2l0IGluIGJhc2UgXCIgKyBiYXNlICsgXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJhc2UgPSBwYXJzZVZhbHVlKGJhc2UpO1xyXG4gICAgICAgIHZhciBkaWdpdHMgPSBbXTtcclxuICAgICAgICB2YXIgaXNOZWdhdGl2ZSA9IHRleHRbMF0gPT09IFwiLVwiO1xyXG4gICAgICAgIGZvciAoaSA9IGlzTmVnYXRpdmUgPyAxIDogMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0W2ldO1xyXG4gICAgICAgICAgICBpZiAoYyBpbiBhbHBoYWJldFZhbHVlcykgZGlnaXRzLnB1c2gocGFyc2VWYWx1ZShhbHBoYWJldFZhbHVlc1tjXSkpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIjxcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaTtcclxuICAgICAgICAgICAgICAgIGRvIHsgaSsrOyB9IHdoaWxlICh0ZXh0W2ldICE9PSBcIj5cIiAmJiBpIDwgdGV4dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZGlnaXRzLnB1c2gocGFyc2VWYWx1ZSh0ZXh0LnNsaWNlKHN0YXJ0ICsgMSwgaSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihjICsgXCIgaXMgbm90IGEgdmFsaWQgY2hhcmFjdGVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMsIGJhc2UsIGlzTmVnYXRpdmUpIHtcclxuICAgICAgICB2YXIgdmFsID0gSW50ZWdlclswXSwgcG93ID0gSW50ZWdlclsxXSwgaTtcclxuICAgICAgICBmb3IgKGkgPSBkaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFsID0gdmFsLmFkZChkaWdpdHNbaV0udGltZXMocG93KSk7XHJcbiAgICAgICAgICAgIHBvdyA9IHBvdy50aW1lcyhiYXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzTmVnYXRpdmUgPyB2YWwubmVnYXRlKCkgOiB2YWw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KGRpZ2l0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIGFscGhhYmV0ID0gYWxwaGFiZXQgfHwgREVGQVVMVF9BTFBIQUJFVDtcclxuICAgICAgICBpZiAoZGlnaXQgPCBhbHBoYWJldC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2RpZ2l0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiPFwiICsgZGlnaXQgKyBcIj5cIjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0Jhc2UobiwgYmFzZSkge1xyXG4gICAgICAgIGJhc2UgPSBiaWdJbnQoYmFzZSk7XHJcbiAgICAgICAgaWYgKGJhc2UuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgaWYgKG4uaXNaZXJvKCkpIHJldHVybiB7IHZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5vbnplcm8gbnVtYmVycyB0byBiYXNlIDAuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFzZS5lcXVhbHMoLTEpKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4geyB2YWx1ZTogWzBdLCBpc05lZ2F0aXZlOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICBpZiAobi5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbXS5jb25jYXQuYXBwbHkoW10sIEFycmF5LmFwcGx5KG51bGwsIEFycmF5KC1uLnRvSlNOdW1iZXIoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoQXJyYXkucHJvdG90eXBlLnZhbHVlT2YsIFsxLCAwXSlcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzTmVnYXRpdmU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGFyciA9IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KG4udG9KU051bWJlcigpIC0gMSkpXHJcbiAgICAgICAgICAgICAgICAubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLCBbMCwgMV0pO1xyXG4gICAgICAgICAgICBhcnIudW5zaGlmdChbMV0pO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFtdLmNvbmNhdC5hcHBseShbXSwgYXJyKSxcclxuICAgICAgICAgICAgICAgIGlzTmVnYXRpdmU6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbmVnID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpICYmIGJhc2UuaXNQb3NpdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIG5lZyA9IHRydWU7XHJcbiAgICAgICAgICAgIG4gPSBuLmFicygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFzZS5pc1VuaXQoKSkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIHsgdmFsdWU6IFswXSwgaXNOZWdhdGl2ZTogZmFsc2UgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkobi50b0pTTnVtYmVyKCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLCAxKSxcclxuICAgICAgICAgICAgICAgIGlzTmVnYXRpdmU6IG5lZ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3V0ID0gW107XHJcbiAgICAgICAgdmFyIGxlZnQgPSBuLCBkaXZtb2Q7XHJcbiAgICAgICAgd2hpbGUgKGxlZnQuaXNOZWdhdGl2ZSgpIHx8IGxlZnQuY29tcGFyZUFicyhiYXNlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGRpdm1vZCA9IGxlZnQuZGl2bW9kKGJhc2UpO1xyXG4gICAgICAgICAgICBsZWZ0ID0gZGl2bW9kLnF1b3RpZW50O1xyXG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBkaXZtb2QucmVtYWluZGVyO1xyXG4gICAgICAgICAgICBpZiAoZGlnaXQuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBkaWdpdCA9IGJhc2UubWludXMoZGlnaXQpLmFicygpO1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dC5wdXNoKGRpZ2l0LnRvSlNOdW1iZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dC5wdXNoKGxlZnQudG9KU051bWJlcigpKTtcclxuICAgICAgICByZXR1cm4geyB2YWx1ZTogb3V0LnJldmVyc2UoKSwgaXNOZWdhdGl2ZTogbmVnIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9CYXNlU3RyaW5nKG4sIGJhc2UsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGFyciA9IHRvQmFzZShuLCBiYXNlKTtcclxuICAgICAgICByZXR1cm4gKGFyci5pc05lZ2F0aXZlID8gXCItXCIgOiBcIlwiKSArIGFyci52YWx1ZS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh4LCBhbHBoYWJldCk7XHJcbiAgICAgICAgfSkuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChyYWRpeCkge1xyXG4gICAgICAgIHJldHVybiB0b0Jhc2UodGhpcywgcmFkaXgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcclxuICAgIH07XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKHJhZGl4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvQmFzZSh0aGlzLCByYWRpeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHJhZGl4LCBhbHBoYWJldCkge1xyXG4gICAgICAgIGlmIChyYWRpeCA9PT0gdW5kZWZpbmVkKSByYWRpeCA9IDEwO1xyXG4gICAgICAgIGlmIChyYWRpeCAhPT0gMTAgfHwgYWxwaGFiZXQpIHJldHVybiB0b0Jhc2VTdHJpbmcodGhpcywgcmFkaXgsIGFscGhhYmV0KTtcclxuICAgICAgICB2YXIgdiA9IHRoaXMudmFsdWUsIGwgPSB2Lmxlbmd0aCwgc3RyID0gU3RyaW5nKHZbLS1sXSksIHplcm9zID0gXCIwMDAwMDAwXCIsIGRpZ2l0O1xyXG4gICAgICAgIHdoaWxlICgtLWwgPj0gMCkge1xyXG4gICAgICAgICAgICBkaWdpdCA9IFN0cmluZyh2W2xdKTtcclxuICAgICAgICAgICAgc3RyICs9IHplcm9zLnNsaWNlKGRpZ2l0Lmxlbmd0aCkgKyBkaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpZ24gPSB0aGlzLnNpZ24gPyBcIi1cIiA6IFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIHNpZ24gKyBzdHI7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgaWYgKHJhZGl4ID09PSB1bmRlZmluZWQpIHJhZGl4ID0gMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4ICE9IDEwIHx8IGFscGhhYmV0KSByZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMsIHJhZGl4LCBhbHBoYWJldCk7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS50b1N0cmluZyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmc7XHJcblxyXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS50b0pTT04gPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0pTT04gPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTsgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwgMTApO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y7XHJcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nVmFsdWUodikge1xyXG4gICAgICAgIGlmIChpc1ByZWNpc2UoK3YpKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gK3Y7XHJcbiAgICAgICAgICAgIGlmICh4ID09PSB0cnVuY2F0ZSh4KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0c05hdGl2ZUJpZ0ludCA/IG5ldyBOYXRpdmVCaWdJbnQoQmlnSW50KHgpKSA6IG5ldyBTbWFsbEludGVnZXIoeCk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIgKyB2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpZ24gPSB2WzBdID09PSBcIi1cIjtcclxuICAgICAgICBpZiAoc2lnbikgdiA9IHYuc2xpY2UoMSk7XHJcbiAgICAgICAgdmFyIHNwbGl0ID0gdi5zcGxpdCgvZS9pKTtcclxuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID4gMikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHNwbGl0LmpvaW4oXCJlXCIpKTtcclxuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBleHAgPSBzcGxpdFsxXTtcclxuICAgICAgICAgICAgaWYgKGV4cFswXSA9PT0gXCIrXCIpIGV4cCA9IGV4cC5zbGljZSgxKTtcclxuICAgICAgICAgICAgZXhwID0gK2V4cDtcclxuICAgICAgICAgICAgaWYgKGV4cCAhPT0gdHJ1bmNhdGUoZXhwKSB8fCAhaXNQcmVjaXNlKGV4cCkpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIgKyBleHAgKyBcIiBpcyBub3QgYSB2YWxpZCBleHBvbmVudC5cIik7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc3BsaXRbMF07XHJcbiAgICAgICAgICAgIHZhciBkZWNpbWFsUGxhY2UgPSB0ZXh0LmluZGV4T2YoXCIuXCIpO1xyXG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBsYWNlID49IDApIHtcclxuICAgICAgICAgICAgICAgIGV4cCAtPSB0ZXh0Lmxlbmd0aCAtIGRlY2ltYWxQbGFjZSAtIDE7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBkZWNpbWFsUGxhY2UpICsgdGV4dC5zbGljZShkZWNpbWFsUGxhY2UgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXhwIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluY2x1ZGUgbmVnYXRpdmUgZXhwb25lbnQgcGFydCBmb3IgaW50ZWdlcnNcIik7XHJcbiAgICAgICAgICAgIHRleHQgKz0gKG5ldyBBcnJheShleHAgKyAxKSkuam9pbihcIjBcIik7XHJcbiAgICAgICAgICAgIHYgPSB0ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXNWYWxpZCA9IC9eKFswLTldWzAtOV0qKSQvLnRlc3Qodik7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgdik7XHJcbiAgICAgICAgaWYgKHN1cHBvcnRzTmF0aXZlQmlnSW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KEJpZ0ludChzaWduID8gXCItXCIgKyB2IDogdikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgciA9IFtdLCBtYXggPSB2Lmxlbmd0aCwgbCA9IExPR19CQVNFLCBtaW4gPSBtYXggLSBsO1xyXG4gICAgICAgIHdoaWxlIChtYXggPiAwKSB7XHJcbiAgICAgICAgICAgIHIucHVzaCgrdi5zbGljZShtaW4sIG1heCkpO1xyXG4gICAgICAgICAgICBtaW4gLT0gbDtcclxuICAgICAgICAgICAgaWYgKG1pbiA8IDApIG1pbiA9IDA7XHJcbiAgICAgICAgICAgIG1heCAtPSBsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmltKHIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihyLCBzaWduKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZU51bWJlclZhbHVlKHYpIHtcclxuICAgICAgICBpZiAoc3VwcG9ydHNOYXRpdmVCaWdJbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQoQmlnSW50KHYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUHJlY2lzZSh2KSkge1xyXG4gICAgICAgICAgICBpZiAodiAhPT0gdHJ1bmNhdGUodikpIHRocm93IG5ldyBFcnJvcih2ICsgXCIgaXMgbm90IGFuIGludGVnZXIuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodi50b1N0cmluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyVmFsdWUodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmdWYWx1ZSh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImJpZ2ludFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH1cclxuICAgIC8vIFByZS1kZWZpbmUgbnVtYmVycyBpbiByYW5nZSBbLTk5OSw5OTldXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xyXG4gICAgICAgIEludGVnZXJbaV0gPSBwYXJzZVZhbHVlKGkpO1xyXG4gICAgICAgIGlmIChpID4gMCkgSW50ZWdlclstaV0gPSBwYXJzZVZhbHVlKC1pKTtcclxuICAgIH1cclxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcbiAgICBJbnRlZ2VyLm9uZSA9IEludGVnZXJbMV07XHJcbiAgICBJbnRlZ2VyLnplcm8gPSBJbnRlZ2VyWzBdO1xyXG4gICAgSW50ZWdlci5taW51c09uZSA9IEludGVnZXJbLTFdO1xyXG4gICAgSW50ZWdlci5tYXggPSBtYXg7XHJcbiAgICBJbnRlZ2VyLm1pbiA9IG1pbjtcclxuICAgIEludGVnZXIuZ2NkID0gZ2NkO1xyXG4gICAgSW50ZWdlci5sY20gPSBsY207XHJcbiAgICBJbnRlZ2VyLmlzSW5zdGFuY2UgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIEJpZ0ludGVnZXIgfHwgeCBpbnN0YW5jZW9mIFNtYWxsSW50ZWdlciB8fCB4IGluc3RhbmNlb2YgTmF0aXZlQmlnSW50OyB9O1xyXG4gICAgSW50ZWdlci5yYW5kQmV0d2VlbiA9IHJhbmRCZXR3ZWVuO1xyXG5cclxuICAgIEludGVnZXIuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLm1hcChwYXJzZVZhbHVlKSwgcGFyc2VWYWx1ZShiYXNlIHx8IDEwKSwgaXNOZWdhdGl2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBJbnRlZ2VyO1xyXG59KSgpO1xyXG5cclxuLy8gTm9kZS5qcyBjaGVja1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuaGFzT3duUHJvcGVydHkoXCJleHBvcnRzXCIpKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpZ0ludDtcclxufVxyXG5cclxuLy9hbWQgY2hlY2tcclxuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gYmlnSW50O1xyXG4gICAgfSk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImJpZ0ludCIsInVuZGVmaW5lZCIsIkJBU0UiLCJMT0dfQkFTRSIsIk1BWF9JTlQiLCJNQVhfSU5UX0FSUiIsInNtYWxsVG9BcnJheSIsIkRFRkFVTFRfQUxQSEFCRVQiLCJzdXBwb3J0c05hdGl2ZUJpZ0ludCIsIkJpZ0ludCIsIkludGVnZXIiLCJ2IiwicmFkaXgiLCJhbHBoYWJldCIsImNhc2VTZW5zaXRpdmUiLCJwYXJzZVZhbHVlIiwicGFyc2VCYXNlIiwiQmlnSW50ZWdlciIsInZhbHVlIiwic2lnbiIsImlzU21hbGwiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJTbWFsbEludGVnZXIiLCJOYXRpdmVCaWdJbnQiLCJpc1ByZWNpc2UiLCJuIiwiTWF0aCIsImZsb29yIiwiYXJyYXlUb1NtYWxsIiwiYXJyIiwidHJpbSIsImxlbmd0aCIsImNvbXBhcmVBYnMiLCJpIiwiY3JlYXRlQXJyYXkiLCJ4IiwiQXJyYXkiLCJ0cnVuY2F0ZSIsImNlaWwiLCJhZGQiLCJhIiwiYiIsImxfYSIsImxfYiIsInIiLCJjYXJyeSIsImJhc2UiLCJzdW0iLCJwdXNoIiwiYWRkQW55IiwiYWRkU21hbGwiLCJsIiwic3VidHJhY3QiLCJuZWdhdGUiLCJhYnMiLCJwbHVzIiwiYV9sIiwiYl9sIiwiYm9ycm93IiwiZGlmZmVyZW5jZSIsInN1YnRyYWN0QW55Iiwic3VidHJhY3RTbWFsbCIsIm1pbnVzIiwic21hbGwiLCJtdWx0aXBseUxvbmciLCJwcm9kdWN0IiwiYV9pIiwiYl9qIiwiaiIsIm11bHRpcGx5U21hbGwiLCJzaGlmdExlZnQiLCJjb25jYXQiLCJtdWx0aXBseUthcmF0c3ViYSIsInkiLCJtYXgiLCJzbGljZSIsImQiLCJjIiwiYWMiLCJiZCIsImFiY2QiLCJ1c2VLYXJhdHN1YmEiLCJsMSIsImwyIiwibXVsdGlwbHkiLCJ0aW1lcyIsIm11bHRpcGx5U21hbGxBbmRBcnJheSIsIl9tdWx0aXBseUJ5U21hbGwiLCJzcXVhcmUiLCJhX2oiLCJkaXZNb2QxIiwicmVzdWx0IiwiZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0IiwibGFtYmRhIiwicmVtYWluZGVyIiwiZGl2aXNvciIsInF1b3RpZW50RGlnaXQiLCJzaGlmdCIsInEiLCJkaXZNb2RTbWFsbCIsImRpdk1vZDIiLCJwYXJ0IiwiZ3Vlc3MiLCJ4bGVuIiwiaGlnaHgiLCJoaWdoeSIsImNoZWNrIiwidW5zaGlmdCIsInJldmVyc2UiLCJxdW90aWVudCIsImRpdk1vZEFueSIsInNlbGYiLCJFcnJvciIsImNvbXBhcmlzb24iLCJxU2lnbiIsIm1vZCIsIm1TaWduIiwiZGl2bW9kIiwiZGl2aWRlIiwib3ZlciIsInBvdyIsImlzRXZlbiIsInRvU3RyaW5nIiwiXzAiLCJfMSIsIl8yIiwiaXNOZWdhdGl2ZSIsIm1vZFBvdyIsImV4cCIsImlzWmVybyIsIm1vZEludiIsImlzUG9zaXRpdmUiLCJpc09kZCIsImNvbXBhcmUiLCJJbmZpbml0eSIsImNvbXBhcmVUbyIsImVxdWFscyIsImVxIiwibm90RXF1YWxzIiwibmVxIiwiZ3JlYXRlciIsImd0IiwibGVzc2VyIiwibHQiLCJncmVhdGVyT3JFcXVhbHMiLCJnZXEiLCJsZXNzZXJPckVxdWFscyIsImxlcSIsImlzVW5pdCIsImlzRGl2aXNpYmxlQnkiLCJpc0Jhc2ljUHJpbWUiLCJtaWxsZXJSYWJpblRlc3QiLCJuUHJldiIsInByZXYiLCJ0IiwibmV4dCIsImlzUHJpbWUiLCJzdHJpY3QiLCJiaXRzIiwiYml0TGVuZ3RoIiwibG9nTiIsImxvZyIsInRvSlNOdW1iZXIiLCJpc1Byb2JhYmxlUHJpbWUiLCJpdGVyYXRpb25zIiwicm5nIiwicmFuZEJldHdlZW4iLCJ6ZXJvIiwibmV3VCIsIm9uZSIsIm5ld1IiLCJsYXN0VCIsImxhc3RSIiwicG93ZXJzT2ZUd28iLCJwb3dlcnMyTGVuZ3RoIiwiaGlnaGVzdFBvd2VyMiIsInNoaWZ0X2lzU21hbGwiLCJTdHJpbmciLCJzaGlmdFJpZ2h0IiwicmVtUXVvIiwiYml0d2lzZSIsImZuIiwieFNpZ24iLCJ5U2lnbiIsInhSZW0iLCJub3QiLCJ5UmVtIiwieERpZ2l0IiwieURpZ2l0IiwieERpdk1vZCIsInlEaXZNb2QiLCJhbmQiLCJvciIsInhvciIsIkxPQk1BU0tfSSIsIkxPQk1BU0tfQkkiLCJyb3VnaExPQiIsImludGVnZXJMb2dhcml0aG0iLCJ0bXAiLCJwIiwiZSIsIm1pbiIsImdjZCIsImxjbSIsInVzZWRSTkciLCJyYW5kb20iLCJsb3ciLCJoaWdoIiwicmFuZ2UiLCJkaWdpdHMiLCJ0b0Jhc2UiLCJyZXN0cmljdGVkIiwidG9wIiwiZGlnaXQiLCJmcm9tQXJyYXkiLCJ0ZXh0IiwidG9Mb3dlckNhc2UiLCJhYnNCYXNlIiwiYWxwaGFiZXRWYWx1ZXMiLCJzdGFydCIsInBhcnNlQmFzZUZyb21BcnJheSIsInZhbCIsInN0cmluZ2lmeSIsImFwcGx5IiwibWFwIiwidmFsdWVPZiIsIm5lZyIsIk51bWJlciIsIm91dCIsImxlZnQiLCJ0b0Jhc2VTdHJpbmciLCJqb2luIiwidG9BcnJheSIsInN0ciIsInplcm9zIiwidG9KU09OIiwicGFyc2VJbnQiLCJwYXJzZVN0cmluZ1ZhbHVlIiwic3BsaXQiLCJkZWNpbWFsUGxhY2UiLCJpbmRleE9mIiwiaXNWYWxpZCIsInRlc3QiLCJwYXJzZU51bWJlclZhbHVlIiwibWludXNPbmUiLCJpc0luc3RhbmNlIiwibW9kdWxlIiwiaGFzT3duUHJvcGVydHkiLCJleHBvcnRzIiwiZGVmaW5lIiwiYW1kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/big-integer/BigInteger.js\n");

/***/ })

};
;