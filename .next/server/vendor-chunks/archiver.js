/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/archiver";
exports.ids = ["vendor-chunks/archiver"];
exports.modules = {

/***/ "(ssr)/./node_modules/archiver/index.js":
/*!****************************************!*\
  !*** ./node_modules/archiver/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Archiver Vending\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */ var Archiver = __webpack_require__(/*! ./lib/core */ \"(ssr)/./node_modules/archiver/lib/core.js\");\nvar formats = {};\n/**\n * Dispenses a new Archiver instance.\n *\n * @constructor\n * @param  {String} format The archive format to use.\n * @param  {Object} options See [Archiver]{@link Archiver}\n * @return {Archiver}\n */ var vending = function(format, options) {\n    return vending.create(format, options);\n};\n/**\n * Creates a new Archiver instance.\n *\n * @param  {String} format The archive format to use.\n * @param  {Object} options See [Archiver]{@link Archiver}\n * @return {Archiver}\n */ vending.create = function(format, options) {\n    if (formats[format]) {\n        var instance = new Archiver(format, options);\n        instance.setFormat(format);\n        instance.setModule(new formats[format](options));\n        return instance;\n    } else {\n        throw new Error(\"create(\" + format + \"): format not registered\");\n    }\n};\n/**\n * Registers a format for use with archiver.\n *\n * @param  {String} format The name of the format.\n * @param  {Function} module The function for archiver to interact with.\n * @return void\n */ vending.registerFormat = function(format, module1) {\n    if (formats[format]) {\n        throw new Error(\"register(\" + format + \"): format already registered\");\n    }\n    if (typeof module1 !== \"function\") {\n        throw new Error(\"register(\" + format + \"): format module invalid\");\n    }\n    if (typeof module1.prototype.append !== \"function\" || typeof module1.prototype.finalize !== \"function\") {\n        throw new Error(\"register(\" + format + \"): format module missing methods\");\n    }\n    formats[format] = module1;\n};\n/**\n * Check if the format is already registered.\n * \n * @param {String} format the name of the format.\n * @return boolean\n */ vending.isRegisteredFormat = function(format) {\n    if (formats[format]) {\n        return true;\n    }\n    return false;\n};\nvending.registerFormat(\"zip\", __webpack_require__(/*! ./lib/plugins/zip */ \"(ssr)/./node_modules/archiver/lib/plugins/zip.js\"));\nvending.registerFormat(\"tar\", __webpack_require__(/*! ./lib/plugins/tar */ \"(ssr)/./node_modules/archiver/lib/plugins/tar.js\"));\nvending.registerFormat(\"json\", __webpack_require__(/*! ./lib/plugins/json */ \"(ssr)/./node_modules/archiver/lib/plugins/json.js\"));\nmodule.exports = vending;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJjaGl2ZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DLEdBQ0QsSUFBSUEsV0FBV0MsbUJBQU9BLENBQUM7QUFFdkIsSUFBSUMsVUFBVSxDQUFDO0FBRWY7Ozs7Ozs7Q0FPQyxHQUNELElBQUlDLFVBQVUsU0FBU0MsTUFBTSxFQUFFQyxPQUFPO0lBQ3BDLE9BQU9GLFFBQVFHLE1BQU0sQ0FBQ0YsUUFBUUM7QUFDaEM7QUFFQTs7Ozs7O0NBTUMsR0FDREYsUUFBUUcsTUFBTSxHQUFHLFNBQVNGLE1BQU0sRUFBRUMsT0FBTztJQUN2QyxJQUFJSCxPQUFPLENBQUNFLE9BQU8sRUFBRTtRQUNuQixJQUFJRyxXQUFXLElBQUlQLFNBQVNJLFFBQVFDO1FBQ3BDRSxTQUFTQyxTQUFTLENBQUNKO1FBQ25CRyxTQUFTRSxTQUFTLENBQUMsSUFBSVAsT0FBTyxDQUFDRSxPQUFPLENBQUNDO1FBRXZDLE9BQU9FO0lBQ1QsT0FBTztRQUNMLE1BQU0sSUFBSUcsTUFBTSxZQUFZTixTQUFTO0lBQ3ZDO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDREQsUUFBUVEsY0FBYyxHQUFHLFNBQVNQLE1BQU0sRUFBRVEsT0FBTTtJQUM5QyxJQUFJVixPQUFPLENBQUNFLE9BQU8sRUFBRTtRQUNuQixNQUFNLElBQUlNLE1BQU0sY0FBY04sU0FBUztJQUN6QztJQUVBLElBQUksT0FBT1EsWUFBVyxZQUFZO1FBQ2hDLE1BQU0sSUFBSUYsTUFBTSxjQUFjTixTQUFTO0lBQ3pDO0lBRUEsSUFBSSxPQUFPUSxRQUFPQyxTQUFTLENBQUNDLE1BQU0sS0FBSyxjQUFjLE9BQU9GLFFBQU9DLFNBQVMsQ0FBQ0UsUUFBUSxLQUFLLFlBQVk7UUFDcEcsTUFBTSxJQUFJTCxNQUFNLGNBQWNOLFNBQVM7SUFDekM7SUFFQUYsT0FBTyxDQUFDRSxPQUFPLEdBQUdRO0FBQ3BCO0FBRUE7Ozs7O0NBS0MsR0FDRFQsUUFBUWEsa0JBQWtCLEdBQUcsU0FBVVosTUFBTTtJQUMzQyxJQUFJRixPQUFPLENBQUNFLE9BQU8sRUFBRTtRQUNuQixPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFFQUQsUUFBUVEsY0FBYyxDQUFDLE9BQU9WLG1CQUFPQSxDQUFDO0FBQ3RDRSxRQUFRUSxjQUFjLENBQUMsT0FBT1YsbUJBQU9BLENBQUM7QUFDdENFLFFBQVFRLGNBQWMsQ0FBQyxRQUFRVixtQkFBT0EsQ0FBQztBQUV2Q1csT0FBT0ssT0FBTyxHQUFHZCIsInNvdXJjZXMiOlsid2VicGFjazovL2NkLXRpbWVzaGVldC1hbmFseXplci8uL25vZGVfbW9kdWxlcy9hcmNoaXZlci9pbmRleC5qcz8wYzk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXJjaGl2ZXIgVmVuZGluZ1xuICpcbiAqIEBpZ25vcmVcbiAqIEBsaWNlbnNlIFtNSVRde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL25vZGUtYXJjaGl2ZXIvYmxvYi9tYXN0ZXIvTElDRU5TRX1cbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTItMjAxNCBDaHJpcyBUYWxraW5ndG9uLCBjb250cmlidXRvcnMuXG4gKi9cbnZhciBBcmNoaXZlciA9IHJlcXVpcmUoJy4vbGliL2NvcmUnKTtcblxudmFyIGZvcm1hdHMgPSB7fTtcblxuLyoqXG4gKiBEaXNwZW5zZXMgYSBuZXcgQXJjaGl2ZXIgaW5zdGFuY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGZvcm1hdCBUaGUgYXJjaGl2ZSBmb3JtYXQgdG8gdXNlLlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIFNlZSBbQXJjaGl2ZXJde0BsaW5rIEFyY2hpdmVyfVxuICogQHJldHVybiB7QXJjaGl2ZXJ9XG4gKi9cbnZhciB2ZW5kaW5nID0gZnVuY3Rpb24oZm9ybWF0LCBvcHRpb25zKSB7XG4gIHJldHVybiB2ZW5kaW5nLmNyZWF0ZShmb3JtYXQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEFyY2hpdmVyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZm9ybWF0IFRoZSBhcmNoaXZlIGZvcm1hdCB0byB1c2UuXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgU2VlIFtBcmNoaXZlcl17QGxpbmsgQXJjaGl2ZXJ9XG4gKiBAcmV0dXJuIHtBcmNoaXZlcn1cbiAqL1xudmVuZGluZy5jcmVhdGUgPSBmdW5jdGlvbihmb3JtYXQsIG9wdGlvbnMpIHtcbiAgaWYgKGZvcm1hdHNbZm9ybWF0XSkge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBBcmNoaXZlcihmb3JtYXQsIG9wdGlvbnMpO1xuICAgIGluc3RhbmNlLnNldEZvcm1hdChmb3JtYXQpO1xuICAgIGluc3RhbmNlLnNldE1vZHVsZShuZXcgZm9ybWF0c1tmb3JtYXRdKG9wdGlvbnMpKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZSgnICsgZm9ybWF0ICsgJyk6IGZvcm1hdCBub3QgcmVnaXN0ZXJlZCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGZvcm1hdCBmb3IgdXNlIHdpdGggYXJjaGl2ZXIuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBmb3JtYXQgVGhlIG5hbWUgb2YgdGhlIGZvcm1hdC5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBtb2R1bGUgVGhlIGZ1bmN0aW9uIGZvciBhcmNoaXZlciB0byBpbnRlcmFjdCB3aXRoLlxuICogQHJldHVybiB2b2lkXG4gKi9cbnZlbmRpbmcucmVnaXN0ZXJGb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQsIG1vZHVsZSkge1xuICBpZiAoZm9ybWF0c1tmb3JtYXRdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWdpc3RlcignICsgZm9ybWF0ICsgJyk6IGZvcm1hdCBhbHJlYWR5IHJlZ2lzdGVyZWQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWdpc3RlcignICsgZm9ybWF0ICsgJyk6IGZvcm1hdCBtb2R1bGUgaW52YWxpZCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUucHJvdG90eXBlLmFwcGVuZCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbW9kdWxlLnByb3RvdHlwZS5maW5hbGl6ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVnaXN0ZXIoJyArIGZvcm1hdCArICcpOiBmb3JtYXQgbW9kdWxlIG1pc3NpbmcgbWV0aG9kcycpO1xuICB9XG5cbiAgZm9ybWF0c1tmb3JtYXRdID0gbW9kdWxlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZm9ybWF0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5cbiAqIFxuICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCB0aGUgbmFtZSBvZiB0aGUgZm9ybWF0LlxuICogQHJldHVybiBib29sZWFuXG4gKi9cbnZlbmRpbmcuaXNSZWdpc3RlcmVkRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICBpZiAoZm9ybWF0c1tmb3JtYXRdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZlbmRpbmcucmVnaXN0ZXJGb3JtYXQoJ3ppcCcsIHJlcXVpcmUoJy4vbGliL3BsdWdpbnMvemlwJykpO1xudmVuZGluZy5yZWdpc3RlckZvcm1hdCgndGFyJywgcmVxdWlyZSgnLi9saWIvcGx1Z2lucy90YXInKSk7XG52ZW5kaW5nLnJlZ2lzdGVyRm9ybWF0KCdqc29uJywgcmVxdWlyZSgnLi9saWIvcGx1Z2lucy9qc29uJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlbmRpbmc7Il0sIm5hbWVzIjpbIkFyY2hpdmVyIiwicmVxdWlyZSIsImZvcm1hdHMiLCJ2ZW5kaW5nIiwiZm9ybWF0Iiwib3B0aW9ucyIsImNyZWF0ZSIsImluc3RhbmNlIiwic2V0Rm9ybWF0Iiwic2V0TW9kdWxlIiwiRXJyb3IiLCJyZWdpc3RlckZvcm1hdCIsIm1vZHVsZSIsInByb3RvdHlwZSIsImFwcGVuZCIsImZpbmFsaXplIiwiaXNSZWdpc3RlcmVkRm9ybWF0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/archiver/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/archiver/lib/core.js":
/*!*******************************************!*\
  !*** ./node_modules/archiver/lib/core.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Archiver Core\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */ var fs = __webpack_require__(/*! fs */ \"fs\");\nvar glob = __webpack_require__(/*! readdir-glob */ \"(ssr)/./node_modules/readdir-glob/index.js\");\nvar async = __webpack_require__(/*! async */ \"(ssr)/./node_modules/async/dist/async.mjs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar util = __webpack_require__(/*! archiver-utils */ \"(ssr)/./node_modules/archiver-utils/index.js\");\nvar inherits = (__webpack_require__(/*! util */ \"util\").inherits);\nvar ArchiverError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/archiver/lib/error.js\");\nvar Transform = (__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/readable.js\").Transform);\nvar win32 = process.platform === \"win32\";\n/**\n * @constructor\n * @param {String} format The archive format to use.\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\n */ var Archiver = function(format, options) {\n    if (!(this instanceof Archiver)) {\n        return new Archiver(format, options);\n    }\n    if (typeof format !== \"string\") {\n        options = format;\n        format = \"zip\";\n    }\n    options = this.options = util.defaults(options, {\n        highWaterMark: 1024 * 1024,\n        statConcurrency: 4\n    });\n    Transform.call(this, options);\n    this._format = false;\n    this._module = false;\n    this._pending = 0;\n    this._pointer = 0;\n    this._entriesCount = 0;\n    this._entriesProcessedCount = 0;\n    this._fsEntriesTotalBytes = 0;\n    this._fsEntriesProcessedBytes = 0;\n    this._queue = async.queue(this._onQueueTask.bind(this), 1);\n    this._queue.drain(this._onQueueDrain.bind(this));\n    this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\n    this._statQueue.drain(this._onQueueDrain.bind(this));\n    this._state = {\n        aborted: false,\n        finalize: false,\n        finalizing: false,\n        finalized: false,\n        modulePiped: false\n    };\n    this._streams = [];\n};\ninherits(Archiver, Transform);\n/**\n * Internal logic for `abort`.\n *\n * @private\n * @return void\n */ Archiver.prototype._abort = function() {\n    this._state.aborted = true;\n    this._queue.kill();\n    this._statQueue.kill();\n    if (this._queue.idle()) {\n        this._shutdown();\n    }\n};\n/**\n * Internal helper for appending files.\n *\n * @private\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data The entry data.\n * @return void\n */ Archiver.prototype._append = function(filepath, data) {\n    data = data || {};\n    var task = {\n        source: null,\n        filepath: filepath\n    };\n    if (!data.name) {\n        data.name = filepath;\n    }\n    data.sourcePath = filepath;\n    task.data = data;\n    this._entriesCount++;\n    if (data.stats && data.stats instanceof fs.Stats) {\n        task = this._updateQueueTaskWithStats(task, data.stats);\n        if (task) {\n            if (data.stats.size) {\n                this._fsEntriesTotalBytes += data.stats.size;\n            }\n            this._queue.push(task);\n        }\n    } else {\n        this._statQueue.push(task);\n    }\n};\n/**\n * Internal logic for `finalize`.\n *\n * @private\n * @return void\n */ Archiver.prototype._finalize = function() {\n    if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n        return;\n    }\n    this._state.finalizing = true;\n    this._moduleFinalize();\n    this._state.finalizing = false;\n    this._state.finalized = true;\n};\n/**\n * Checks the various state variables to determine if we can `finalize`.\n *\n * @private\n * @return {Boolean}\n */ Archiver.prototype._maybeFinalize = function() {\n    if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n        return false;\n    }\n    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n        this._finalize();\n        return true;\n    }\n    return false;\n};\n/**\n * Appends an entry to the module.\n *\n * @private\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream)} source\n * @param  {EntryData} data\n * @param  {Function} callback\n * @return void\n */ Archiver.prototype._moduleAppend = function(source, data, callback) {\n    if (this._state.aborted) {\n        callback();\n        return;\n    }\n    this._module.append(source, data, (function(err) {\n        this._task = null;\n        if (this._state.aborted) {\n            this._shutdown();\n            return;\n        }\n        if (err) {\n            this.emit(\"error\", err);\n            setImmediate(callback);\n            return;\n        }\n        /**\n     * Fires when the entry's input has been processed and appended to the archive.\n     *\n     * @event Archiver#entry\n     * @type {EntryData}\n     */ this.emit(\"entry\", data);\n        this._entriesProcessedCount++;\n        if (data.stats && data.stats.size) {\n            this._fsEntriesProcessedBytes += data.stats.size;\n        }\n        /**\n     * @event Archiver#progress\n     * @type {ProgressData}\n     */ this.emit(\"progress\", {\n            entries: {\n                total: this._entriesCount,\n                processed: this._entriesProcessedCount\n            },\n            fs: {\n                totalBytes: this._fsEntriesTotalBytes,\n                processedBytes: this._fsEntriesProcessedBytes\n            }\n        });\n        setImmediate(callback);\n    }).bind(this));\n};\n/**\n * Finalizes the module.\n *\n * @private\n * @return void\n */ Archiver.prototype._moduleFinalize = function() {\n    if (typeof this._module.finalize === \"function\") {\n        this._module.finalize();\n    } else if (typeof this._module.end === \"function\") {\n        this._module.end();\n    } else {\n        this.emit(\"error\", new ArchiverError(\"NOENDMETHOD\"));\n    }\n};\n/**\n * Pipes the module to our internal stream with error bubbling.\n *\n * @private\n * @return void\n */ Archiver.prototype._modulePipe = function() {\n    this._module.on(\"error\", this._onModuleError.bind(this));\n    this._module.pipe(this);\n    this._state.modulePiped = true;\n};\n/**\n * Determines if the current module supports a defined feature.\n *\n * @private\n * @param  {String} key\n * @return {Boolean}\n */ Archiver.prototype._moduleSupports = function(key) {\n    if (!this._module.supports || !this._module.supports[key]) {\n        return false;\n    }\n    return this._module.supports[key];\n};\n/**\n * Unpipes the module from our internal stream.\n *\n * @private\n * @return void\n */ Archiver.prototype._moduleUnpipe = function() {\n    this._module.unpipe(this);\n    this._state.modulePiped = false;\n};\n/**\n * Normalizes entry data with fallbacks for key properties.\n *\n * @private\n * @param  {Object} data\n * @param  {fs.Stats} stats\n * @return {Object}\n */ Archiver.prototype._normalizeEntryData = function(data, stats) {\n    data = util.defaults(data, {\n        type: \"file\",\n        name: null,\n        date: null,\n        mode: null,\n        prefix: null,\n        sourcePath: null,\n        stats: false\n    });\n    if (stats && data.stats === false) {\n        data.stats = stats;\n    }\n    var isDir = data.type === \"directory\";\n    if (data.name) {\n        if (typeof data.prefix === \"string\" && \"\" !== data.prefix) {\n            data.name = data.prefix + \"/\" + data.name;\n            data.prefix = null;\n        }\n        data.name = util.sanitizePath(data.name);\n        if (data.type !== \"symlink\" && data.name.slice(-1) === \"/\") {\n            isDir = true;\n            data.type = \"directory\";\n        } else if (isDir) {\n            data.name += \"/\";\n        }\n    }\n    // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\n    if (typeof data.mode === \"number\") {\n        if (win32) {\n            data.mode &= 511;\n        } else {\n            data.mode &= 4095;\n        }\n    } else if (data.stats && data.mode === null) {\n        if (win32) {\n            data.mode = data.stats.mode & 511;\n        } else {\n            data.mode = data.stats.mode & 4095;\n        }\n        // stat isn't reliable on windows; force 0755 for dir\n        if (win32 && isDir) {\n            data.mode = 493;\n        }\n    } else if (data.mode === null) {\n        data.mode = isDir ? 493 : 420;\n    }\n    if (data.stats && data.date === null) {\n        data.date = data.stats.mtime;\n    } else {\n        data.date = util.dateify(data.date);\n    }\n    return data;\n};\n/**\n * Error listener that re-emits error on to our internal stream.\n *\n * @private\n * @param  {Error} err\n * @return void\n */ Archiver.prototype._onModuleError = function(err) {\n    /**\n   * @event Archiver#error\n   * @type {ErrorData}\n   */ this.emit(\"error\", err);\n};\n/**\n * Checks the various state variables after queue has drained to determine if\n * we need to `finalize`.\n *\n * @private\n * @return void\n */ Archiver.prototype._onQueueDrain = function() {\n    if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n        return;\n    }\n    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n        this._finalize();\n    }\n};\n/**\n * Appends each queue task to the module.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */ Archiver.prototype._onQueueTask = function(task, callback) {\n    var fullCallback = ()=>{\n        if (task.data.callback) {\n            task.data.callback();\n        }\n        callback();\n    };\n    if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n        fullCallback();\n        return;\n    }\n    this._task = task;\n    this._moduleAppend(task.source, task.data, fullCallback);\n};\n/**\n * Performs a file stat and reinjects the task back into the queue.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */ Archiver.prototype._onStatQueueTask = function(task, callback) {\n    if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n        callback();\n        return;\n    }\n    fs.lstat(task.filepath, (function(err, stats) {\n        if (this._state.aborted) {\n            setImmediate(callback);\n            return;\n        }\n        if (err) {\n            this._entriesCount--;\n            /**\n       * @event Archiver#warning\n       * @type {ErrorData}\n       */ this.emit(\"warning\", err);\n            setImmediate(callback);\n            return;\n        }\n        task = this._updateQueueTaskWithStats(task, stats);\n        if (task) {\n            if (stats.size) {\n                this._fsEntriesTotalBytes += stats.size;\n            }\n            this._queue.push(task);\n        }\n        setImmediate(callback);\n    }).bind(this));\n};\n/**\n * Unpipes the module and ends our internal stream.\n *\n * @private\n * @return void\n */ Archiver.prototype._shutdown = function() {\n    this._moduleUnpipe();\n    this.end();\n};\n/**\n * Tracks the bytes emitted by our internal stream.\n *\n * @private\n * @param  {Buffer} chunk\n * @param  {String} encoding\n * @param  {Function} callback\n * @return void\n */ Archiver.prototype._transform = function(chunk, encoding, callback) {\n    if (chunk) {\n        this._pointer += chunk.length;\n    }\n    callback(null, chunk);\n};\n/**\n * Updates and normalizes a queue task using stats data.\n *\n * @private\n * @param  {Object} task\n * @param  {fs.Stats} stats\n * @return {Object}\n */ Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {\n    if (stats.isFile()) {\n        task.data.type = \"file\";\n        task.data.sourceType = \"stream\";\n        task.source = util.lazyReadStream(task.filepath);\n    } else if (stats.isDirectory() && this._moduleSupports(\"directory\")) {\n        task.data.name = util.trailingSlashIt(task.data.name);\n        task.data.type = \"directory\";\n        task.data.sourcePath = util.trailingSlashIt(task.filepath);\n        task.data.sourceType = \"buffer\";\n        task.source = Buffer.concat([]);\n    } else if (stats.isSymbolicLink() && this._moduleSupports(\"symlink\")) {\n        var linkPath = fs.readlinkSync(task.filepath);\n        var dirName = path.dirname(task.filepath);\n        task.data.type = \"symlink\";\n        task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\n        task.data.sourceType = \"buffer\";\n        task.source = Buffer.concat([]);\n    } else {\n        if (stats.isDirectory()) {\n            this.emit(\"warning\", new ArchiverError(\"DIRECTORYNOTSUPPORTED\", task.data));\n        } else if (stats.isSymbolicLink()) {\n            this.emit(\"warning\", new ArchiverError(\"SYMLINKNOTSUPPORTED\", task.data));\n        } else {\n            this.emit(\"warning\", new ArchiverError(\"ENTRYNOTSUPPORTED\", task.data));\n        }\n        return null;\n    }\n    task.data = this._normalizeEntryData(task.data, stats);\n    return task;\n};\n/**\n * Aborts the archiving process, taking a best-effort approach, by:\n *\n * - removing any pending queue tasks\n * - allowing any active queue workers to finish\n * - detaching internal module pipes\n * - ending both sides of the Transform stream\n *\n * It will NOT drain any remaining sources.\n *\n * @return {this}\n */ Archiver.prototype.abort = function() {\n    if (this._state.aborted || this._state.finalized) {\n        return this;\n    }\n    this._abort();\n    return this;\n};\n/**\n * Appends an input source (text string, buffer, or stream) to the instance.\n *\n * When the instance has received, processed, and emitted the input, the `entry`\n * event is fired.\n *\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream|String)} source The input source.\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\n * @return {this}\n */ Archiver.prototype.append = function(source, data) {\n    if (this._state.finalize || this._state.aborted) {\n        this.emit(\"error\", new ArchiverError(\"QUEUECLOSED\"));\n        return this;\n    }\n    data = this._normalizeEntryData(data);\n    if (typeof data.name !== \"string\" || data.name.length === 0) {\n        this.emit(\"error\", new ArchiverError(\"ENTRYNAMEREQUIRED\"));\n        return this;\n    }\n    if (data.type === \"directory\" && !this._moduleSupports(\"directory\")) {\n        this.emit(\"error\", new ArchiverError(\"DIRECTORYNOTSUPPORTED\", {\n            name: data.name\n        }));\n        return this;\n    }\n    source = util.normalizeInputSource(source);\n    if (Buffer.isBuffer(source)) {\n        data.sourceType = \"buffer\";\n    } else if (util.isStream(source)) {\n        data.sourceType = \"stream\";\n    } else {\n        this.emit(\"error\", new ArchiverError(\"INPUTSTEAMBUFFERREQUIRED\", {\n            name: data.name\n        }));\n        return this;\n    }\n    this._entriesCount++;\n    this._queue.push({\n        data: data,\n        source: source\n    });\n    return this;\n};\n/**\n * Appends a directory and its files, recursively, given its dirpath.\n *\n * @param  {String} dirpath The source directory path.\n * @param  {String} destpath The destination path within the archive.\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */ Archiver.prototype.directory = function(dirpath, destpath, data) {\n    if (this._state.finalize || this._state.aborted) {\n        this.emit(\"error\", new ArchiverError(\"QUEUECLOSED\"));\n        return this;\n    }\n    if (typeof dirpath !== \"string\" || dirpath.length === 0) {\n        this.emit(\"error\", new ArchiverError(\"DIRECTORYDIRPATHREQUIRED\"));\n        return this;\n    }\n    this._pending++;\n    if (destpath === false) {\n        destpath = \"\";\n    } else if (typeof destpath !== \"string\") {\n        destpath = dirpath;\n    }\n    var dataFunction = false;\n    if (typeof data === \"function\") {\n        dataFunction = data;\n        data = {};\n    } else if (typeof data !== \"object\") {\n        data = {};\n    }\n    var globOptions = {\n        stat: true,\n        dot: true\n    };\n    function onGlobEnd() {\n        this._pending--;\n        this._maybeFinalize();\n    }\n    function onGlobError(err) {\n        this.emit(\"error\", err);\n    }\n    function onGlobMatch(match) {\n        globber.pause();\n        var ignoreMatch = false;\n        var entryData = Object.assign({}, data);\n        entryData.name = match.relative;\n        entryData.prefix = destpath;\n        entryData.stats = match.stat;\n        entryData.callback = globber.resume.bind(globber);\n        try {\n            if (dataFunction) {\n                entryData = dataFunction(entryData);\n                if (entryData === false) {\n                    ignoreMatch = true;\n                } else if (typeof entryData !== \"object\") {\n                    throw new ArchiverError(\"DIRECTORYFUNCTIONINVALIDDATA\", {\n                        dirpath: dirpath\n                    });\n                }\n            }\n        } catch (e) {\n            this.emit(\"error\", e);\n            return;\n        }\n        if (ignoreMatch) {\n            globber.resume();\n            return;\n        }\n        this._append(match.absolute, entryData);\n    }\n    var globber = glob(dirpath, globOptions);\n    globber.on(\"error\", onGlobError.bind(this));\n    globber.on(\"match\", onGlobMatch.bind(this));\n    globber.on(\"end\", onGlobEnd.bind(this));\n    return this;\n};\n/**\n * Appends a file given its filepath using a\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\n * prevent issues with open file limits.\n *\n * When the instance has received, processed, and emitted the file, the `entry`\n * event is fired.\n *\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */ Archiver.prototype.file = function(filepath, data) {\n    if (this._state.finalize || this._state.aborted) {\n        this.emit(\"error\", new ArchiverError(\"QUEUECLOSED\"));\n        return this;\n    }\n    if (typeof filepath !== \"string\" || filepath.length === 0) {\n        this.emit(\"error\", new ArchiverError(\"FILEFILEPATHREQUIRED\"));\n        return this;\n    }\n    this._append(filepath, data);\n    return this;\n};\n/**\n * Appends multiple files that match a glob pattern.\n *\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/minimatch} to match.\n * @param  {Object} options See [node-readdir-glob]{@link https://github.com/yqnn/node-readdir-glob#options}.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */ Archiver.prototype.glob = function(pattern, options, data) {\n    this._pending++;\n    options = util.defaults(options, {\n        stat: true,\n        pattern: pattern\n    });\n    function onGlobEnd() {\n        this._pending--;\n        this._maybeFinalize();\n    }\n    function onGlobError(err) {\n        this.emit(\"error\", err);\n    }\n    function onGlobMatch(match) {\n        globber.pause();\n        var entryData = Object.assign({}, data);\n        entryData.callback = globber.resume.bind(globber);\n        entryData.stats = match.stat;\n        entryData.name = match.relative;\n        this._append(match.absolute, entryData);\n    }\n    var globber = glob(options.cwd || \".\", options);\n    globber.on(\"error\", onGlobError.bind(this));\n    globber.on(\"match\", onGlobMatch.bind(this));\n    globber.on(\"end\", onGlobEnd.bind(this));\n    return this;\n};\n/**\n * Finalizes the instance and prevents further appending to the archive\n * structure (queue will continue til drained).\n *\n * The `end`, `close` or `finish` events on the destination stream may fire\n * right after calling this method so you should set listeners beforehand to\n * properly detect stream completion.\n *\n * @return {Promise}\n */ Archiver.prototype.finalize = function() {\n    if (this._state.aborted) {\n        var abortedError = new ArchiverError(\"ABORTED\");\n        this.emit(\"error\", abortedError);\n        return Promise.reject(abortedError);\n    }\n    if (this._state.finalize) {\n        var finalizingError = new ArchiverError(\"FINALIZING\");\n        this.emit(\"error\", finalizingError);\n        return Promise.reject(finalizingError);\n    }\n    this._state.finalize = true;\n    if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n        this._finalize();\n    }\n    var self = this;\n    return new Promise(function(resolve, reject) {\n        var errored;\n        self._module.on(\"end\", function() {\n            if (!errored) {\n                resolve();\n            }\n        });\n        self._module.on(\"error\", function(err) {\n            errored = true;\n            reject(err);\n        });\n    });\n};\n/**\n * Sets the module format name used for archiving.\n *\n * @param {String} format The name of the format.\n * @return {this}\n */ Archiver.prototype.setFormat = function(format) {\n    if (this._format) {\n        this.emit(\"error\", new ArchiverError(\"FORMATSET\"));\n        return this;\n    }\n    this._format = format;\n    return this;\n};\n/**\n * Sets the module used for archiving.\n *\n * @param {Function} module The function for archiver to interact with.\n * @return {this}\n */ Archiver.prototype.setModule = function(module1) {\n    if (this._state.aborted) {\n        this.emit(\"error\", new ArchiverError(\"ABORTED\"));\n        return this;\n    }\n    if (this._state.module) {\n        this.emit(\"error\", new ArchiverError(\"MODULESET\"));\n        return this;\n    }\n    this._module = module1;\n    this._modulePipe();\n    return this;\n};\n/**\n * Appends a symlink to the instance.\n *\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\n *\n * @param  {String} filepath The symlink path (within archive).\n * @param  {String} target The target path (within archive).\n * @param  {Number} mode Sets the entry permissions.\n * @return {this}\n */ Archiver.prototype.symlink = function(filepath, target, mode) {\n    if (this._state.finalize || this._state.aborted) {\n        this.emit(\"error\", new ArchiverError(\"QUEUECLOSED\"));\n        return this;\n    }\n    if (typeof filepath !== \"string\" || filepath.length === 0) {\n        this.emit(\"error\", new ArchiverError(\"SYMLINKFILEPATHREQUIRED\"));\n        return this;\n    }\n    if (typeof target !== \"string\" || target.length === 0) {\n        this.emit(\"error\", new ArchiverError(\"SYMLINKTARGETREQUIRED\", {\n            filepath: filepath\n        }));\n        return this;\n    }\n    if (!this._moduleSupports(\"symlink\")) {\n        this.emit(\"error\", new ArchiverError(\"SYMLINKNOTSUPPORTED\", {\n            filepath: filepath\n        }));\n        return this;\n    }\n    var data = {};\n    data.type = \"symlink\";\n    data.name = filepath.replace(/\\\\/g, \"/\");\n    data.linkname = target.replace(/\\\\/g, \"/\");\n    data.sourceType = \"buffer\";\n    if (typeof mode === \"number\") {\n        data.mode = mode;\n    }\n    this._entriesCount++;\n    this._queue.push({\n        data: data,\n        source: Buffer.concat([])\n    });\n    return this;\n};\n/**\n * Returns the current length (in bytes) that has been emitted.\n *\n * @return {Number}\n */ Archiver.prototype.pointer = function() {\n    return this._pointer;\n};\n/**\n * Middleware-like helper that has yet to be fully implemented.\n *\n * @private\n * @param  {Function} plugin\n * @return {this}\n */ Archiver.prototype.use = function(plugin) {\n    this._streams.push(plugin);\n    return this;\n};\nmodule.exports = Archiver; /**\n * @typedef {Object} CoreOptions\n * @global\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\n * process the internal fs stat queue.\n */  /**\n * @typedef {Object} TransformOptions\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\n * will automatically end the readable side when the writable side ends and vice\n * versa.\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\n * into Buffers before passing them to _write(). `Writable`\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\n * to strings using the specified encoding. `Readable`\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\n * in the internal buffer before ceasing to read from the underlying resource.\n * `Readable` `Writable`\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\n * stream of objects. Meaning that stream.read(n) returns a single value instead\n * of a Buffer of size n. `Readable` `Writable`\n */  /**\n * @typedef {Object} EntryData\n * @property {String} name Sets the entry name including internal path.\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\n * when working with methods like `directory` or `glob`.\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\n * for reduction of fs stat calls when stat data is already known.\n */  /**\n * @typedef {Object} ErrorData\n * @property {String} message The message of the error.\n * @property {String} code The error code assigned to this error.\n * @property {String} data Additional data provided for reporting or debugging (where available).\n */  /**\n * @typedef {Object} ProgressData\n * @property {Object} entries\n * @property {Number} entries.total Number of entries that have been appended.\n * @property {Number} entries.processed Number of entries that have been processed.\n * @property {Object} fs\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJjaGl2ZXIvbGliL2NvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DLEdBQ0QsSUFBSUEsS0FBS0MsbUJBQU9BLENBQUM7QUFDakIsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUcsT0FBT0gsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUksT0FBT0osbUJBQU9BLENBQUM7QUFFbkIsSUFBSUssV0FBV0wsa0RBQXdCO0FBQ3ZDLElBQUlNLGdCQUFnQk4sbUJBQU9BLENBQUM7QUFDNUIsSUFBSU8sWUFBWVAsMEdBQW9DO0FBRXBELElBQUlRLFFBQVFDLFFBQVFDLFFBQVEsS0FBSztBQUVqQzs7OztDQUlDLEdBQ0QsSUFBSUMsV0FBVyxTQUFTQyxNQUFNLEVBQUVDLE9BQU87SUFDckMsSUFBSSxDQUFFLEtBQUksWUFBWUYsUUFBTyxHQUFJO1FBQy9CLE9BQU8sSUFBSUEsU0FBU0MsUUFBUUM7SUFDOUI7SUFFQSxJQUFJLE9BQU9ELFdBQVcsVUFBVTtRQUM5QkMsVUFBVUQ7UUFDVkEsU0FBUztJQUNYO0lBRUFDLFVBQVUsSUFBSSxDQUFDQSxPQUFPLEdBQUdULEtBQUtVLFFBQVEsQ0FBQ0QsU0FBUztRQUM5Q0UsZUFBZSxPQUFPO1FBQ3RCQyxpQkFBaUI7SUFDbkI7SUFFQVQsVUFBVVUsSUFBSSxDQUFDLElBQUksRUFBRUo7SUFFckIsSUFBSSxDQUFDSyxPQUFPLEdBQUc7SUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBRWhCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO0lBQ3JCLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUc7SUFDOUIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztJQUM1QixJQUFJLENBQUNDLHdCQUF3QixHQUFHO0lBRWhDLElBQUksQ0FBQ0MsTUFB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QVMsQ0FBQ2dILE9BQU8sR0FBRztJQUMzQixPQUFPLElBQUksQ0FBQ3BJLFFBQVE7QUFDdEI7QUFFQTs7Ozs7O0NBTUMsR0FDRFYsU0FBUzhCLFNBQVMsQ0FBQ2lILEdBQUcsR0FBRyxTQUFTQyxNQUFNO0lBQ3RDLElBQUksQ0FBQ25ILFFBQVEsQ0FBQ2lCLElBQUksQ0FBQ2tHO0lBQ25CLE9BQU8sSUFBSTtBQUNiO0FBRUFOLE9BQU9PLE9BQU8sR0FBR2pKLFVBRWpCOzs7OztDQUtDLElBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsSUFFRDs7Ozs7Ozs7O0NBU0MsSUFFRDs7Ozs7Q0FLQyxJQUVEOzs7Ozs7OztDQVFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2QtdGltZXNoZWV0LWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyL2xpYi9jb3JlLmpzPzc1MzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBcmNoaXZlciBDb3JlXG4gKlxuICogQGlnbm9yZVxuICogQGxpY2Vuc2UgW01JVF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS1hcmNoaXZlci9ibG9iL21hc3Rlci9MSUNFTlNFfVxuICogQGNvcHlyaWdodCAoYykgMjAxMi0yMDE0IENocmlzIFRhbGtpbmd0b24sIGNvbnRyaWJ1dG9ycy5cbiAqL1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBnbG9iID0gcmVxdWlyZSgncmVhZGRpci1nbG9iJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ2FyY2hpdmVyLXV0aWxzJyk7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBBcmNoaXZlckVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybTtcblxudmFyIHdpbjMyID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgVGhlIGFyY2hpdmUgZm9ybWF0IHRvIHVzZS5cbiAqIEBwYXJhbSB7KENvcmVPcHRpb25zfFRyYW5zZm9ybU9wdGlvbnMpfSBvcHRpb25zIFNlZSBhbHNvIHtAbGluayBaaXBPcHRpb25zfSBhbmQge0BsaW5rIFRhck9wdGlvbnN9LlxuICovXG52YXIgQXJjaGl2ZXIgPSBmdW5jdGlvbihmb3JtYXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFyY2hpdmVyKSkge1xuICAgIHJldHVybiBuZXcgQXJjaGl2ZXIoZm9ybWF0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZm9ybWF0ICE9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSBmb3JtYXQ7XG4gICAgZm9ybWF0ID0gJ3ppcCc7XG4gIH1cblxuICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gdXRpbC5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgaGlnaFdhdGVyTWFyazogMTAyNCAqIDEwMjQsXG4gICAgc3RhdENvbmN1cnJlbmN5OiA0XG4gIH0pO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX2Zvcm1hdCA9IGZhbHNlO1xuICB0aGlzLl9tb2R1bGUgPSBmYWxzZTtcbiAgdGhpcy5fcGVuZGluZyA9IDA7XG4gIHRoaXMuX3BvaW50ZXIgPSAwO1xuXG4gIHRoaXMuX2VudHJpZXNDb3VudCA9IDA7XG4gIHRoaXMuX2VudHJpZXNQcm9jZXNzZWRDb3VudCA9IDA7XG4gIHRoaXMuX2ZzRW50cmllc1RvdGFsQnl0ZXMgPSAwO1xuICB0aGlzLl9mc0VudHJpZXNQcm9jZXNzZWRCeXRlcyA9IDA7XG5cbiAgdGhpcy5fcXVldWUgPSBhc3luYy5xdWV1ZSh0aGlzLl9vblF1ZXVlVGFzay5iaW5kKHRoaXMpLCAxKTtcbiAgdGhpcy5fcXVldWUuZHJhaW4odGhpcy5fb25RdWV1ZURyYWluLmJpbmQodGhpcykpO1xuXG4gIHRoaXMuX3N0YXRRdWV1ZSA9IGFzeW5jLnF1ZXVlKHRoaXMuX29uU3RhdFF1ZXVlVGFzay5iaW5kKHRoaXMpLCBvcHRpb25zLnN0YXRDb25jdXJyZW5jeSk7XG4gIHRoaXMuX3N0YXRRdWV1ZS5kcmFpbih0aGlzLl9vblF1ZXVlRHJhaW4uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5fc3RhdGUgPSB7XG4gICAgYWJvcnRlZDogZmFsc2UsXG4gICAgZmluYWxpemU6IGZhbHNlLFxuICAgIGZpbmFsaXppbmc6IGZhbHNlLFxuICAgIGZpbmFsaXplZDogZmFsc2UsXG4gICAgbW9kdWxlUGlwZWQ6IGZhbHNlXG4gIH07XG5cbiAgdGhpcy5fc3RyZWFtcyA9IFtdO1xufTtcblxuaW5oZXJpdHMoQXJjaGl2ZXIsIFRyYW5zZm9ybSk7XG5cbi8qKlxuICogSW50ZXJuYWwgbG9naWMgZm9yIGBhYm9ydGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4gdm9pZFxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N0YXRlLmFib3J0ZWQgPSB0cnVlO1xuICB0aGlzLl9xdWV1ZS5raWxsKCk7XG4gIHRoaXMuX3N0YXRRdWV1ZS5raWxsKCk7XG5cbiAgaWYgKHRoaXMuX3F1ZXVlLmlkbGUoKSkge1xuICAgIHRoaXMuX3NodXRkb3duKCk7XG4gIH1cbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZvciBhcHBlbmRpbmcgZmlsZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1N0cmluZ30gZmlsZXBhdGggVGhlIHNvdXJjZSBmaWxlcGF0aC5cbiAqIEBwYXJhbSAge0VudHJ5RGF0YX0gZGF0YSBUaGUgZW50cnkgZGF0YS5cbiAqIEByZXR1cm4gdm9pZFxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuX2FwcGVuZCA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIHZhciB0YXNrID0ge1xuICAgIHNvdXJjZTogbnVsbCxcbiAgICBmaWxlcGF0aDogZmlsZXBhdGhcbiAgfTtcblxuICBpZiAoIWRhdGEubmFtZSkge1xuICAgIGRhdGEubmFtZSA9IGZpbGVwYXRoO1xuICB9XG5cbiAgZGF0YS5zb3VyY2VQYXRoID0gZmlsZXBhdGg7XG4gIHRhc2suZGF0YSA9IGRhdGE7XG4gIHRoaXMuX2VudHJpZXNDb3VudCsrO1xuXG4gIGlmIChkYXRhLnN0YXRzICYmIGRhdGEuc3RhdHMgaW5zdGFuY2VvZiBmcy5TdGF0cykge1xuICAgIHRhc2sgPSB0aGlzLl91cGRhdGVRdWV1ZVRhc2tXaXRoU3RhdHModGFzaywgZGF0YS5zdGF0cyk7XG4gICAgaWYgKHRhc2spIHtcbiAgICAgIGlmIChkYXRhLnN0YXRzLnNpemUpIHtcbiAgICAgICAgdGhpcy5fZnNFbnRyaWVzVG90YWxCeXRlcyArPSBkYXRhLnN0YXRzLnNpemU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGFzayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX3N0YXRRdWV1ZS5wdXNoKHRhc2spO1xuICB9XG59O1xuXG4vKipcbiAqIEludGVybmFsIGxvZ2ljIGZvciBgZmluYWxpemVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHZvaWRcbiAqL1xuQXJjaGl2ZXIucHJvdG90eXBlLl9maW5hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc3RhdGUuZmluYWxpemluZyB8fCB0aGlzLl9zdGF0ZS5maW5hbGl6ZWQgfHwgdGhpcy5fc3RhdGUuYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3N0YXRlLmZpbmFsaXppbmcgPSB0cnVlO1xuXG4gIHRoaXMuX21vZHVsZUZpbmFsaXplKCk7XG5cbiAgdGhpcy5fc3RhdGUuZmluYWxpemluZyA9IGZhbHNlO1xuICB0aGlzLl9zdGF0ZS5maW5hbGl6ZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBDaGVja3MgdGhlIHZhcmlvdXMgc3RhdGUgdmFyaWFibGVzIHRvIGRldGVybWluZSBpZiB3ZSBjYW4gYGZpbmFsaXplYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQXJjaGl2ZXIucHJvdG90eXBlLl9tYXliZUZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zdGF0ZS5maW5hbGl6aW5nIHx8IHRoaXMuX3N0YXRlLmZpbmFsaXplZCB8fCB0aGlzLl9zdGF0ZS5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3N0YXRlLmZpbmFsaXplICYmIHRoaXMuX3BlbmRpbmcgPT09IDAgJiYgdGhpcy5fcXVldWUuaWRsZSgpICYmIHRoaXMuX3N0YXRRdWV1ZS5pZGxlKCkpIHtcbiAgICB0aGlzLl9maW5hbGl6ZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGFuIGVudHJ5IHRvIHRoZSBtb2R1bGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmaXJlcyAgQXJjaGl2ZXIjZW50cnlcbiAqIEBwYXJhbSAgeyhCdWZmZXJ8U3RyZWFtKX0gc291cmNlXG4gKiBAcGFyYW0gIHtFbnRyeURhdGF9IGRhdGFcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB2b2lkXG4gKi9cbkFyY2hpdmVyLnByb3RvdHlwZS5fbW9kdWxlQXBwZW5kID0gZnVuY3Rpb24oc291cmNlLCBkYXRhLCBjYWxsYmFjaykge1xuICBpZiAodGhpcy5fc3RhdGUuYWJvcnRlZCkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fbW9kdWxlLmFwcGVuZChzb3VyY2UsIGRhdGEsIGZ1bmN0aW9uKGVycikge1xuICAgIHRoaXMuX3Rhc2sgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMuX3NodXRkb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVycikge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGVudHJ5J3MgaW5wdXQgaGFzIGJlZW4gcHJvY2Vzc2VkIGFuZCBhcHBlbmRlZCB0byB0aGUgYXJjaGl2ZS5cbiAgICAgKlxuICAgICAqIEBldmVudCBBcmNoaXZlciNlbnRyeVxuICAgICAqIEB0eXBlIHtFbnRyeURhdGF9XG4gICAgICovXG4gICAgdGhpcy5lbWl0KCdlbnRyeScsIGRhdGEpO1xuICAgIHRoaXMuX2VudHJpZXNQcm9jZXNzZWRDb3VudCsrO1xuXG4gICAgaWYgKGRhdGEuc3RhdHMgJiYgZGF0YS5zdGF0cy5zaXplKSB7XG4gICAgICB0aGlzLl9mc0VudHJpZXNQcm9jZXNzZWRCeXRlcyArPSBkYXRhLnN0YXRzLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IEFyY2hpdmVyI3Byb2dyZXNzXG4gICAgICogQHR5cGUge1Byb2dyZXNzRGF0YX1cbiAgICAgKi9cbiAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywge1xuICAgICAgZW50cmllczoge1xuICAgICAgICB0b3RhbDogdGhpcy5fZW50cmllc0NvdW50LFxuICAgICAgICBwcm9jZXNzZWQ6IHRoaXMuX2VudHJpZXNQcm9jZXNzZWRDb3VudFxuICAgICAgfSxcbiAgICAgIGZzOiB7XG4gICAgICAgIHRvdGFsQnl0ZXM6IHRoaXMuX2ZzRW50cmllc1RvdGFsQnl0ZXMsXG4gICAgICAgIHByb2Nlc3NlZEJ5dGVzOiB0aGlzLl9mc0VudHJpZXNQcm9jZXNzZWRCeXRlc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogRmluYWxpemVzIHRoZSBtb2R1bGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4gdm9pZFxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuX21vZHVsZUZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5fbW9kdWxlLmZpbmFsaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fbW9kdWxlLmZpbmFsaXplKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX21vZHVsZS5lbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9tb2R1bGUuZW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBBcmNoaXZlckVycm9yKCdOT0VORE1FVEhPRCcpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQaXBlcyB0aGUgbW9kdWxlIHRvIG91ciBpbnRlcm5hbCBzdHJlYW0gd2l0aCBlcnJvciBidWJibGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB2b2lkXG4gKi9cbkFyY2hpdmVyLnByb3RvdHlwZS5fbW9kdWxlUGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9tb2R1bGUub24oJ2Vycm9yJywgdGhpcy5fb25Nb2R1bGVFcnJvci5iaW5kKHRoaXMpKTtcbiAgdGhpcy5fbW9kdWxlLnBpcGUodGhpcyk7XG4gIHRoaXMuX3N0YXRlLm1vZHVsZVBpcGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBtb2R1bGUgc3VwcG9ydHMgYSBkZWZpbmVkIGZlYXR1cmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuX21vZHVsZVN1cHBvcnRzID0gZnVuY3Rpb24oa2V5KSB7XG4gIGlmICghdGhpcy5fbW9kdWxlLnN1cHBvcnRzIHx8ICF0aGlzLl9tb2R1bGUuc3VwcG9ydHNba2V5XSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9tb2R1bGUuc3VwcG9ydHNba2V5XTtcbn07XG5cbi8qKlxuICogVW5waXBlcyB0aGUgbW9kdWxlIGZyb20gb3VyIGludGVybmFsIHN0cmVhbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB2b2lkXG4gKi9cbkFyY2hpdmVyLnByb3RvdHlwZS5fbW9kdWxlVW5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX21vZHVsZS51bnBpcGUodGhpcyk7XG4gIHRoaXMuX3N0YXRlLm1vZHVsZVBpcGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgZW50cnkgZGF0YSB3aXRoIGZhbGxiYWNrcyBmb3Iga2V5IHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHBhcmFtICB7ZnMuU3RhdHN9IHN0YXRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkFyY2hpdmVyLnByb3RvdHlwZS5fbm9ybWFsaXplRW50cnlEYXRhID0gZnVuY3Rpb24oZGF0YSwgc3RhdHMpIHtcbiAgZGF0YSA9IHV0aWwuZGVmYXVsdHMoZGF0YSwge1xuICAgIHR5cGU6ICdmaWxlJyxcbiAgICBuYW1lOiBudWxsLFxuICAgIGRhdGU6IG51bGwsXG4gICAgbW9kZTogbnVsbCxcbiAgICBwcmVmaXg6IG51bGwsXG4gICAgc291cmNlUGF0aDogbnVsbCxcbiAgICBzdGF0czogZmFsc2VcbiAgfSk7XG5cbiAgaWYgKHN0YXRzICYmIGRhdGEuc3RhdHMgPT09IGZhbHNlKSB7XG4gICAgZGF0YS5zdGF0cyA9IHN0YXRzO1xuICB9XG5cbiAgdmFyIGlzRGlyID0gZGF0YS50eXBlID09PSAnZGlyZWN0b3J5JztcblxuICBpZiAoZGF0YS5uYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhLnByZWZpeCA9PT0gJ3N0cmluZycgJiYgJycgIT09IGRhdGEucHJlZml4KSB7XG4gICAgICBkYXRhLm5hbWUgPSBkYXRhLnByZWZpeCArICcvJyArIGRhdGEubmFtZTtcbiAgICAgIGRhdGEucHJlZml4ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkYXRhLm5hbWUgPSB1dGlsLnNhbml0aXplUGF0aChkYXRhLm5hbWUpO1xuXG4gICAgaWYgKGRhdGEudHlwZSAhPT0gJ3N5bWxpbmsnICYmIGRhdGEubmFtZS5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgaXNEaXIgPSB0cnVlO1xuICAgICAgZGF0YS50eXBlID0gJ2RpcmVjdG9yeSc7XG4gICAgfSBlbHNlIGlmIChpc0Rpcikge1xuICAgICAgZGF0YS5uYW1lICs9ICcvJztcbiAgICB9XG4gIH1cblxuICAvLyA1MTEgPT09IDA3Nzc7IDQ5MyA9PT0gMDc1NTsgNDM4ID09PSAwNjY2OyA0MjAgPT09IDA2NDRcbiAgaWYgKHR5cGVvZiBkYXRhLm1vZGUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHdpbjMyKSB7XG4gICAgICBkYXRhLm1vZGUgJj0gNTExO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLm1vZGUgJj0gNDA5NVxuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhLnN0YXRzICYmIGRhdGEubW9kZSA9PT0gbnVsbCkge1xuICAgIGlmICh3aW4zMikge1xuICAgICAgZGF0YS5tb2RlID0gZGF0YS5zdGF0cy5tb2RlICYgNTExO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLm1vZGUgPSBkYXRhLnN0YXRzLm1vZGUgJiA0MDk1O1xuICAgIH1cblxuICAgIC8vIHN0YXQgaXNuJ3QgcmVsaWFibGUgb24gd2luZG93czsgZm9yY2UgMDc1NSBmb3IgZGlyXG4gICAgaWYgKHdpbjMyICYmIGlzRGlyKSB7XG4gICAgICBkYXRhLm1vZGUgPSA0OTM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEubW9kZSA9PT0gbnVsbCkge1xuICAgIGRhdGEubW9kZSA9IGlzRGlyID8gNDkzIDogNDIwO1xuICB9XG5cbiAgaWYgKGRhdGEuc3RhdHMgJiYgZGF0YS5kYXRlID09PSBudWxsKSB7XG4gICAgZGF0YS5kYXRlID0gZGF0YS5zdGF0cy5tdGltZTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmRhdGUgPSB1dGlsLmRhdGVpZnkoZGF0YS5kYXRlKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuLyoqXG4gKiBFcnJvciBsaXN0ZW5lciB0aGF0IHJlLWVtaXRzIGVycm9yIG9uIHRvIG91ciBpbnRlcm5hbCBzdHJlYW0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0Vycm9yfSBlcnJcbiAqIEByZXR1cm4gdm9pZFxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuX29uTW9kdWxlRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgLyoqXG4gICAqIEBldmVudCBBcmNoaXZlciNlcnJvclxuICAgKiBAdHlwZSB7RXJyb3JEYXRhfVxuICAgKi9cbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENoZWNrcyB0aGUgdmFyaW91cyBzdGF0ZSB2YXJpYWJsZXMgYWZ0ZXIgcXVldWUgaGFzIGRyYWluZWQgdG8gZGV0ZXJtaW5lIGlmXG4gKiB3ZSBuZWVkIHRvIGBmaW5hbGl6ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4gdm9pZFxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuX29uUXVldWVEcmFpbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc3RhdGUuZmluYWxpemluZyB8fCB0aGlzLl9zdGF0ZS5maW5hbGl6ZWQgfHwgdGhpcy5fc3RhdGUuYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9zdGF0ZS5maW5hbGl6ZSAmJiB0aGlzLl9wZW5kaW5nID09PSAwICYmIHRoaXMuX3F1ZXVlLmlkbGUoKSAmJiB0aGlzLl9zdGF0UXVldWUuaWRsZSgpKSB7XG4gICAgdGhpcy5fZmluYWxpemUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBlbmRzIGVhY2ggcXVldWUgdGFzayB0byB0aGUgbW9kdWxlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhc2tcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB2b2lkXG4gKi9cbkFyY2hpdmVyLnByb3RvdHlwZS5fb25RdWV1ZVRhc2sgPSBmdW5jdGlvbih0YXNrLCBjYWxsYmFjaykge1xuICB2YXIgZnVsbENhbGxiYWNrID0gKCkgPT4ge1xuICAgIGlmKHRhc2suZGF0YS5jYWxsYmFjaykge1xuICAgICAgdGFzay5kYXRhLmNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBpZiAodGhpcy5fc3RhdGUuZmluYWxpemluZyB8fCB0aGlzLl9zdGF0ZS5maW5hbGl6ZWQgfHwgdGhpcy5fc3RhdGUuYWJvcnRlZCkge1xuICAgIGZ1bGxDYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3Rhc2sgPSB0YXNrO1xuICB0aGlzLl9tb2R1bGVBcHBlbmQodGFzay5zb3VyY2UsIHRhc2suZGF0YSwgZnVsbENhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBmaWxlIHN0YXQgYW5kIHJlaW5qZWN0cyB0aGUgdGFzayBiYWNrIGludG8gdGhlIHF1ZXVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhc2tcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB2b2lkXG4gKi9cbkFyY2hpdmVyLnByb3RvdHlwZS5fb25TdGF0UXVldWVUYXNrID0gZnVuY3Rpb24odGFzaywgY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuX3N0YXRlLmZpbmFsaXppbmcgfHwgdGhpcy5fc3RhdGUuZmluYWxpemVkIHx8IHRoaXMuX3N0YXRlLmFib3J0ZWQpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZzLmxzdGF0KHRhc2suZmlsZXBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdHMpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUuYWJvcnRlZCkge1xuICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aGlzLl9lbnRyaWVzQ291bnQtLTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgQXJjaGl2ZXIjd2FybmluZ1xuICAgICAgICogQHR5cGUge0Vycm9yRGF0YX1cbiAgICAgICAqL1xuICAgICAgdGhpcy5lbWl0KCd3YXJuaW5nJywgZXJyKTtcbiAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGFzayA9IHRoaXMuX3VwZGF0ZVF1ZXVlVGFza1dpdGhTdGF0cyh0YXNrLCBzdGF0cyk7XG5cbiAgICBpZiAodGFzaykge1xuICAgICAgaWYgKHN0YXRzLnNpemUpIHtcbiAgICAgICAgdGhpcy5fZnNFbnRyaWVzVG90YWxCeXRlcyArPSBzdGF0cy5zaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHRhc2spO1xuICAgIH1cblxuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIFVucGlwZXMgdGhlIG1vZHVsZSBhbmQgZW5kcyBvdXIgaW50ZXJuYWwgc3RyZWFtLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHZvaWRcbiAqL1xuQXJjaGl2ZXIucHJvdG90eXBlLl9zaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9tb2R1bGVVbnBpcGUoKTtcbiAgdGhpcy5lbmQoKTtcbn07XG5cbi8qKlxuICogVHJhY2tzIHRoZSBieXRlcyBlbWl0dGVkIGJ5IG91ciBpbnRlcm5hbCBzdHJlYW0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0J1ZmZlcn0gY2h1bmtcbiAqIEBwYXJhbSAge1N0cmluZ30gZW5jb2RpbmdcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB2b2lkXG4gKi9cbkFyY2hpdmVyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBpZiAoY2h1bmspIHtcbiAgICB0aGlzLl9wb2ludGVyICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuXG4gIGNhbGxiYWNrKG51bGwsIGNodW5rKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhbmQgbm9ybWFsaXplcyBhIHF1ZXVlIHRhc2sgdXNpbmcgc3RhdHMgZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7T2JqZWN0fSB0YXNrXG4gKiBAcGFyYW0gIHtmcy5TdGF0c30gc3RhdHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuQXJjaGl2ZXIucHJvdG90eXBlLl91cGRhdGVRdWV1ZVRhc2tXaXRoU3RhdHMgPSBmdW5jdGlvbih0YXNrLCBzdGF0cykge1xuICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICB0YXNrLmRhdGEudHlwZSA9ICdmaWxlJztcbiAgICB0YXNrLmRhdGEuc291cmNlVHlwZSA9ICdzdHJlYW0nO1xuICAgIHRhc2suc291cmNlID0gdXRpbC5sYXp5UmVhZFN0cmVhbSh0YXNrLmZpbGVwYXRoKTtcbiAgfSBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpICYmIHRoaXMuX21vZHVsZVN1cHBvcnRzKCdkaXJlY3RvcnknKSkge1xuICAgIHRhc2suZGF0YS5uYW1lID0gdXRpbC50cmFpbGluZ1NsYXNoSXQodGFzay5kYXRhLm5hbWUpO1xuICAgIHRhc2suZGF0YS50eXBlID0gJ2RpcmVjdG9yeSc7XG4gICAgdGFzay5kYXRhLnNvdXJjZVBhdGggPSB1dGlsLnRyYWlsaW5nU2xhc2hJdCh0YXNrLmZpbGVwYXRoKTtcbiAgICB0YXNrLmRhdGEuc291cmNlVHlwZSA9ICdidWZmZXInO1xuICAgIHRhc2suc291cmNlID0gQnVmZmVyLmNvbmNhdChbXSk7XG4gIH0gZWxzZSBpZiAoc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSAmJiB0aGlzLl9tb2R1bGVTdXBwb3J0cygnc3ltbGluaycpKSB7XG4gICAgdmFyIGxpbmtQYXRoID0gZnMucmVhZGxpbmtTeW5jKHRhc2suZmlsZXBhdGgpO1xuICAgIHZhciBkaXJOYW1lID0gcGF0aC5kaXJuYW1lKHRhc2suZmlsZXBhdGgpO1xuICAgIHRhc2suZGF0YS50eXBlID0gJ3N5bWxpbmsnO1xuICAgIHRhc2suZGF0YS5saW5rbmFtZSA9IHBhdGgucmVsYXRpdmUoZGlyTmFtZSwgcGF0aC5yZXNvbHZlKGRpck5hbWUsIGxpbmtQYXRoKSk7XG4gICAgdGFzay5kYXRhLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcbiAgICB0YXNrLnNvdXJjZSA9IEJ1ZmZlci5jb25jYXQoW10pO1xuICB9IGVsc2Uge1xuICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBuZXcgQXJjaGl2ZXJFcnJvcignRElSRUNUT1JZTk9UU1VQUE9SVEVEJywgdGFzay5kYXRhKSk7XG4gICAgfSBlbHNlIGlmIChzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBuZXcgQXJjaGl2ZXJFcnJvcignU1lNTElOS05PVFNVUFBPUlRFRCcsIHRhc2suZGF0YSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBuZXcgQXJjaGl2ZXJFcnJvcignRU5UUllOT1RTVVBQT1JURUQnLCB0YXNrLmRhdGEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRhc2suZGF0YSA9IHRoaXMuX25vcm1hbGl6ZUVudHJ5RGF0YSh0YXNrLmRhdGEsIHN0YXRzKTtcblxuICByZXR1cm4gdGFzaztcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSBhcmNoaXZpbmcgcHJvY2VzcywgdGFraW5nIGEgYmVzdC1lZmZvcnQgYXBwcm9hY2gsIGJ5OlxuICpcbiAqIC0gcmVtb3ZpbmcgYW55IHBlbmRpbmcgcXVldWUgdGFza3NcbiAqIC0gYWxsb3dpbmcgYW55IGFjdGl2ZSBxdWV1ZSB3b3JrZXJzIHRvIGZpbmlzaFxuICogLSBkZXRhY2hpbmcgaW50ZXJuYWwgbW9kdWxlIHBpcGVzXG4gKiAtIGVuZGluZyBib3RoIHNpZGVzIG9mIHRoZSBUcmFuc2Zvcm0gc3RyZWFtXG4gKlxuICogSXQgd2lsbCBOT1QgZHJhaW4gYW55IHJlbWFpbmluZyBzb3VyY2VzLlxuICpcbiAqIEByZXR1cm4ge3RoaXN9XG4gKi9cbkFyY2hpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc3RhdGUuYWJvcnRlZCB8fCB0aGlzLl9zdGF0ZS5maW5hbGl6ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX2Fib3J0KCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYW4gaW5wdXQgc291cmNlICh0ZXh0IHN0cmluZywgYnVmZmVyLCBvciBzdHJlYW0pIHRvIHRoZSBpbnN0YW5jZS5cbiAqXG4gKiBXaGVuIHRoZSBpbnN0YW5jZSBoYXMgcmVjZWl2ZWQsIHByb2Nlc3NlZCwgYW5kIGVtaXR0ZWQgdGhlIGlucHV0LCB0aGUgYGVudHJ5YFxuICogZXZlbnQgaXMgZmlyZWQuXG4gKlxuICogQGZpcmVzICBBcmNoaXZlciNlbnRyeVxuICogQHBhcmFtICB7KEJ1ZmZlcnxTdHJlYW18U3RyaW5nKX0gc291cmNlIFRoZSBpbnB1dCBzb3VyY2UuXG4gKiBAcGFyYW0gIHtFbnRyeURhdGF9IGRhdGEgU2VlIGFsc28ge0BsaW5rIFppcEVudHJ5RGF0YX0gYW5kIHtAbGluayBUYXJFbnRyeURhdGF9LlxuICogQHJldHVybiB7dGhpc31cbiAqL1xuQXJjaGl2ZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHNvdXJjZSwgZGF0YSkge1xuICBpZiAodGhpcy5fc3RhdGUuZmluYWxpemUgfHwgdGhpcy5fc3RhdGUuYWJvcnRlZCkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgQXJjaGl2ZXJFcnJvcignUVVFVUVDTE9TRUQnKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkYXRhID0gdGhpcy5fbm9ybWFsaXplRW50cnlEYXRhKGRhdGEpO1xuXG4gIGlmICh0eXBlb2YgZGF0YS5uYW1lICE9PSAnc3RyaW5nJyB8fCBkYXRhLm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBBcmNoaXZlckVycm9yKCdFTlRSWU5BTUVSRVFVSVJFRCcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChkYXRhLnR5cGUgPT09ICdkaXJlY3RvcnknICYmICF0aGlzLl9tb2R1bGVTdXBwb3J0cygnZGlyZWN0b3J5JykpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEFyY2hpdmVyRXJyb3IoJ0RJUkVDVE9SWU5PVFNVUFBPUlRFRCcsIHsgbmFtZTogZGF0YS5uYW1lIH0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNvdXJjZSA9IHV0aWwubm9ybWFsaXplSW5wdXRTb3VyY2Uoc291cmNlKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNvdXJjZSkpIHtcbiAgICBkYXRhLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcbiAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKHNvdXJjZSkpIHtcbiAgICBkYXRhLnNvdXJjZVR5cGUgPSAnc3RyZWFtJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEFyY2hpdmVyRXJyb3IoJ0lOUFVUU1RFQU1CVUZGRVJSRVFVSVJFRCcsIHsgbmFtZTogZGF0YS5uYW1lIH0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX2VudHJpZXNDb3VudCsrO1xuICB0aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHNvdXJjZTogc291cmNlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgZGlyZWN0b3J5IGFuZCBpdHMgZmlsZXMsIHJlY3Vyc2l2ZWx5LCBnaXZlbiBpdHMgZGlycGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGRpcnBhdGggVGhlIHNvdXJjZSBkaXJlY3RvcnkgcGF0aC5cbiAqIEBwYXJhbSAge1N0cmluZ30gZGVzdHBhdGggVGhlIGRlc3RpbmF0aW9uIHBhdGggd2l0aGluIHRoZSBhcmNoaXZlLlxuICogQHBhcmFtICB7KEVudHJ5RGF0YXxGdW5jdGlvbil9IGRhdGEgU2VlIGFsc28gW1ppcEVudHJ5RGF0YV17QGxpbmsgWmlwRW50cnlEYXRhfSBhbmRcbiAqIFtUYXJFbnRyeURhdGFde0BsaW5rIFRhckVudHJ5RGF0YX0uXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuZGlyZWN0b3J5ID0gZnVuY3Rpb24oZGlycGF0aCwgZGVzdHBhdGgsIGRhdGEpIHtcbiAgaWYgKHRoaXMuX3N0YXRlLmZpbmFsaXplIHx8IHRoaXMuX3N0YXRlLmFib3J0ZWQpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEFyY2hpdmVyRXJyb3IoJ1FVRVVFQ0xPU0VEJykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkaXJwYXRoICE9PSAnc3RyaW5nJyB8fCBkaXJwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgQXJjaGl2ZXJFcnJvcignRElSRUNUT1JZRElSUEFUSFJFUVVJUkVEJykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fcGVuZGluZysrO1xuXG4gIGlmIChkZXN0cGF0aCA9PT0gZmFsc2UpIHtcbiAgICBkZXN0cGF0aCA9ICcnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0cGF0aCAhPT0gJ3N0cmluZycpe1xuICAgIGRlc3RwYXRoID0gZGlycGF0aDtcbiAgfVxuXG4gIHZhciBkYXRhRnVuY3Rpb24gPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YUZ1bmN0aW9uID0gZGF0YTtcbiAgICBkYXRhID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgdmFyIGdsb2JPcHRpb25zID0ge1xuICAgIHN0YXQ6IHRydWUsXG4gICAgZG90OiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gb25HbG9iRW5kKCkge1xuICAgIHRoaXMuX3BlbmRpbmctLTtcbiAgICB0aGlzLl9tYXliZUZpbmFsaXplKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkdsb2JFcnJvcihlcnIpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uR2xvYk1hdGNoKG1hdGNoKXtcbiAgICBnbG9iYmVyLnBhdXNlKCk7XG5cbiAgICB2YXIgaWdub3JlTWF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgZW50cnlEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgZW50cnlEYXRhLm5hbWUgPSBtYXRjaC5yZWxhdGl2ZTtcbiAgICBlbnRyeURhdGEucHJlZml4ID0gZGVzdHBhdGg7XG4gICAgZW50cnlEYXRhLnN0YXRzID0gbWF0Y2guc3RhdDtcbiAgICBlbnRyeURhdGEuY2FsbGJhY2sgPSBnbG9iYmVyLnJlc3VtZS5iaW5kKGdsb2JiZXIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChkYXRhRnVuY3Rpb24pIHtcbiAgICAgICAgZW50cnlEYXRhID0gZGF0YUZ1bmN0aW9uKGVudHJ5RGF0YSk7XG5cbiAgICAgICAgaWYgKGVudHJ5RGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZ25vcmVNYXRjaCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVudHJ5RGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXJjaGl2ZXJFcnJvcignRElSRUNUT1JZRlVOQ1RJT05JTlZBTElEREFUQScsIHsgZGlycGF0aDogZGlycGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpZ25vcmVNYXRjaCkge1xuICAgICAgZ2xvYmJlci5yZXN1bWUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9hcHBlbmQobWF0Y2guYWJzb2x1dGUsIGVudHJ5RGF0YSk7XG4gIH1cblxuICB2YXIgZ2xvYmJlciA9IGdsb2IoZGlycGF0aCwgZ2xvYk9wdGlvbnMpO1xuICBnbG9iYmVyLm9uKCdlcnJvcicsIG9uR2xvYkVycm9yLmJpbmQodGhpcykpO1xuICBnbG9iYmVyLm9uKCdtYXRjaCcsIG9uR2xvYk1hdGNoLmJpbmQodGhpcykpO1xuICBnbG9iYmVyLm9uKCdlbmQnLCBvbkdsb2JFbmQuYmluZCh0aGlzKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBmaWxlIGdpdmVuIGl0cyBmaWxlcGF0aCB1c2luZyBhXG4gKiBbbGF6eXN0cmVhbV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2pwb21tZXJlbmluZy9ub2RlLWxhenlzdHJlYW19IHdyYXBwZXIgdG9cbiAqIHByZXZlbnQgaXNzdWVzIHdpdGggb3BlbiBmaWxlIGxpbWl0cy5cbiAqXG4gKiBXaGVuIHRoZSBpbnN0YW5jZSBoYXMgcmVjZWl2ZWQsIHByb2Nlc3NlZCwgYW5kIGVtaXR0ZWQgdGhlIGZpbGUsIHRoZSBgZW50cnlgXG4gKiBldmVudCBpcyBmaXJlZC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVwYXRoIFRoZSBzb3VyY2UgZmlsZXBhdGguXG4gKiBAcGFyYW0gIHtFbnRyeURhdGF9IGRhdGEgU2VlIGFsc28gW1ppcEVudHJ5RGF0YV17QGxpbmsgWmlwRW50cnlEYXRhfSBhbmRcbiAqIFtUYXJFbnRyeURhdGFde0BsaW5rIFRhckVudHJ5RGF0YX0uXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuZmlsZSA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBkYXRhKSB7XG4gIGlmICh0aGlzLl9zdGF0ZS5maW5hbGl6ZSB8fCB0aGlzLl9zdGF0ZS5hYm9ydGVkKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBBcmNoaXZlckVycm9yKCdRVUVVRUNMT1NFRCcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZmlsZXBhdGggIT09ICdzdHJpbmcnIHx8IGZpbGVwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgQXJjaGl2ZXJFcnJvcignRklMRUZJTEVQQVRIUkVRVUlSRUQnKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9hcHBlbmQoZmlsZXBhdGgsIGRhdGEpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIG11bHRpcGxlIGZpbGVzIHRoYXQgbWF0Y2ggYSBnbG9iIHBhdHRlcm4uXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBwYXR0ZXJuIFRoZSBbZ2xvYiBwYXR0ZXJuXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL21pbmltYXRjaH0gdG8gbWF0Y2guXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgU2VlIFtub2RlLXJlYWRkaXItZ2xvYl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3lxbm4vbm9kZS1yZWFkZGlyLWdsb2Ijb3B0aW9uc30uXG4gKiBAcGFyYW0gIHtFbnRyeURhdGF9IGRhdGEgU2VlIGFsc28gW1ppcEVudHJ5RGF0YV17QGxpbmsgWmlwRW50cnlEYXRhfSBhbmRcbiAqIFtUYXJFbnRyeURhdGFde0BsaW5rIFRhckVudHJ5RGF0YX0uXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuZ2xvYiA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMsIGRhdGEpIHtcbiAgdGhpcy5fcGVuZGluZysrO1xuXG4gIG9wdGlvbnMgPSB1dGlsLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBzdGF0OiB0cnVlLFxuICAgIHBhdHRlcm46IHBhdHRlcm5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gb25HbG9iRW5kKCkge1xuICAgIHRoaXMuX3BlbmRpbmctLTtcbiAgICB0aGlzLl9tYXliZUZpbmFsaXplKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkdsb2JFcnJvcihlcnIpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uR2xvYk1hdGNoKG1hdGNoKXtcbiAgICBnbG9iYmVyLnBhdXNlKCk7XG4gICAgdmFyIGVudHJ5RGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpO1xuICAgIGVudHJ5RGF0YS5jYWxsYmFjayA9IGdsb2JiZXIucmVzdW1lLmJpbmQoZ2xvYmJlcik7XG4gICAgZW50cnlEYXRhLnN0YXRzID0gbWF0Y2guc3RhdDtcbiAgICBlbnRyeURhdGEubmFtZSA9IG1hdGNoLnJlbGF0aXZlO1xuXG4gICAgdGhpcy5fYXBwZW5kKG1hdGNoLmFic29sdXRlLCBlbnRyeURhdGEpO1xuICB9XG5cbiAgdmFyIGdsb2JiZXIgPSBnbG9iKG9wdGlvbnMuY3dkIHx8ICcuJywgb3B0aW9ucyk7XG4gIGdsb2JiZXIub24oJ2Vycm9yJywgb25HbG9iRXJyb3IuYmluZCh0aGlzKSk7XG4gIGdsb2JiZXIub24oJ21hdGNoJywgb25HbG9iTWF0Y2guYmluZCh0aGlzKSk7XG4gIGdsb2JiZXIub24oJ2VuZCcsIG9uR2xvYkVuZC5iaW5kKHRoaXMpKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluYWxpemVzIHRoZSBpbnN0YW5jZSBhbmQgcHJldmVudHMgZnVydGhlciBhcHBlbmRpbmcgdG8gdGhlIGFyY2hpdmVcbiAqIHN0cnVjdHVyZSAocXVldWUgd2lsbCBjb250aW51ZSB0aWwgZHJhaW5lZCkuXG4gKlxuICogVGhlIGBlbmRgLCBgY2xvc2VgIG9yIGBmaW5pc2hgIGV2ZW50cyBvbiB0aGUgZGVzdGluYXRpb24gc3RyZWFtIG1heSBmaXJlXG4gKiByaWdodCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIHNvIHlvdSBzaG91bGQgc2V0IGxpc3RlbmVycyBiZWZvcmVoYW5kIHRvXG4gKiBwcm9wZXJseSBkZXRlY3Qgc3RyZWFtIGNvbXBsZXRpb24uXG4gKlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuQXJjaGl2ZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zdGF0ZS5hYm9ydGVkKSB7XG4gICAgdmFyIGFib3J0ZWRFcnJvciA9IG5ldyBBcmNoaXZlckVycm9yKCdBQk9SVEVEJyk7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGFib3J0ZWRFcnJvcik7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0ZWRFcnJvcik7XG4gIH1cblxuICBpZiAodGhpcy5fc3RhdGUuZmluYWxpemUpIHtcbiAgICB2YXIgZmluYWxpemluZ0Vycm9yID0gbmV3IEFyY2hpdmVyRXJyb3IoJ0ZJTkFMSVpJTkcnKTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZmluYWxpemluZ0Vycm9yKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZmluYWxpemluZ0Vycm9yKTtcbiAgfVxuXG4gIHRoaXMuX3N0YXRlLmZpbmFsaXplID0gdHJ1ZTtcblxuICBpZiAodGhpcy5fcGVuZGluZyA9PT0gMCAmJiB0aGlzLl9xdWV1ZS5pZGxlKCkgJiYgdGhpcy5fc3RhdFF1ZXVlLmlkbGUoKSkge1xuICAgIHRoaXMuX2ZpbmFsaXplKCk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBlcnJvcmVkO1xuXG4gICAgc2VsZi5fbW9kdWxlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZXJyb3JlZCkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSlcblxuICAgIHNlbGYuX21vZHVsZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfSlcbiAgfSlcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbW9kdWxlIGZvcm1hdCBuYW1lIHVzZWQgZm9yIGFyY2hpdmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IFRoZSBuYW1lIG9mIHRoZSBmb3JtYXQuXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5BcmNoaXZlci5wcm90b3R5cGUuc2V0Rm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gIGlmICh0aGlzLl9mb3JtYXQpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEFyY2hpdmVyRXJyb3IoJ0ZPUk1BVFNFVCcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX2Zvcm1hdCA9IGZvcm1hdDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbW9kdWxlIHVzZWQgZm9yIGFyY2hpdmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2R1bGUgVGhlIGZ1bmN0aW9uIGZvciBhcmNoaXZlciB0byBpbnRlcmFjdCB3aXRoLlxuICogQHJldHVybiB7dGhpc31cbiAqL1xuQXJjaGl2ZXIucHJvdG90eXBlLnNldE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICBpZiAodGhpcy5fc3RhdGUuYWJvcnRlZCkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgQXJjaGl2ZXJFcnJvcignQUJPUlRFRCcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0aGlzLl9zdGF0ZS5tb2R1bGUpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEFyY2hpdmVyRXJyb3IoJ01PRFVMRVNFVCcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX21vZHVsZSA9IG1vZHVsZTtcbiAgdGhpcy5fbW9kdWxlUGlwZSgpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgc3ltbGluayB0byB0aGUgaW5zdGFuY2UuXG4gKlxuICogVGhpcyBkb2VzIE5PVCBpbnRlcmFjdCB3aXRoIGZpbGVzeXN0ZW0gYW5kIGlzIHVzZWQgZm9yIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRpbmcgc3ltbGlua3MuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBmaWxlcGF0aCBUaGUgc3ltbGluayBwYXRoICh3aXRoaW4gYXJjaGl2ZSkuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHRhcmdldCBUaGUgdGFyZ2V0IHBhdGggKHdpdGhpbiBhcmNoaXZlKS5cbiAqIEBwYXJhbSAge051bWJlcn0gbW9kZSBTZXRzIHRoZSBlbnRyeSBwZXJtaXNzaW9ucy5cbiAqIEByZXR1cm4ge3RoaXN9XG4gKi9cbkFyY2hpdmVyLnByb3RvdHlwZS5zeW1saW5rID0gZnVuY3Rpb24oZmlsZXBhdGgsIHRhcmdldCwgbW9kZSkge1xuICBpZiAodGhpcy5fc3RhdGUuZmluYWxpemUgfHwgdGhpcy5fc3RhdGUuYWJvcnRlZCkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgQXJjaGl2ZXJFcnJvcignUVVFVUVDTE9TRUQnKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodHlwZW9mIGZpbGVwYXRoICE9PSAnc3RyaW5nJyB8fCBmaWxlcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEFyY2hpdmVyRXJyb3IoJ1NZTUxJTktGSUxFUEFUSFJFUVVJUkVEJykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnIHx8IHRhcmdldC5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEFyY2hpdmVyRXJyb3IoJ1NZTUxJTktUQVJHRVRSRVFVSVJFRCcsIHsgZmlsZXBhdGg6IGZpbGVwYXRoIH0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICghdGhpcy5fbW9kdWxlU3VwcG9ydHMoJ3N5bWxpbmsnKSkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgQXJjaGl2ZXJFcnJvcignU1lNTElOS05PVFNVUFBPUlRFRCcsIHsgZmlsZXBhdGg6IGZpbGVwYXRoIH0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBkYXRhID0ge307XG4gIGRhdGEudHlwZSA9ICdzeW1saW5rJztcbiAgZGF0YS5uYW1lID0gZmlsZXBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICBkYXRhLmxpbmtuYW1lID0gdGFyZ2V0LnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgZGF0YS5zb3VyY2VUeXBlID0gJ2J1ZmZlcic7XG5cbiAgaWYgKHR5cGVvZiBtb2RlID09PSBcIm51bWJlclwiKSB7XG4gICAgZGF0YS5tb2RlID0gbW9kZTtcbiAgfVxuXG4gIHRoaXMuX2VudHJpZXNDb3VudCsrO1xuICB0aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHNvdXJjZTogQnVmZmVyLmNvbmNhdChbXSlcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbGVuZ3RoIChpbiBieXRlcykgdGhhdCBoYXMgYmVlbiBlbWl0dGVkLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQXJjaGl2ZXIucHJvdG90eXBlLnBvaW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BvaW50ZXI7XG59O1xuXG4vKipcbiAqIE1pZGRsZXdhcmUtbGlrZSBoZWxwZXIgdGhhdCBoYXMgeWV0IHRvIGJlIGZ1bGx5IGltcGxlbWVudGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gcGx1Z2luXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5BcmNoaXZlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gIHRoaXMuX3N0cmVhbXMucHVzaChwbHVnaW4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXJjaGl2ZXI7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29yZU9wdGlvbnNcbiAqIEBnbG9iYWxcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3RhdENvbmN1cnJlbmN5PTRdIFNldHMgdGhlIG51bWJlciBvZiB3b3JrZXJzIHVzZWQgdG9cbiAqIHByb2Nlc3MgdGhlIGludGVybmFsIGZzIHN0YXQgcXVldWUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmFuc2Zvcm1PcHRpb25zXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFthbGxvd0hhbGZPcGVuPXRydWVdIElmIHNldCB0byBmYWxzZSwgdGhlbiB0aGUgc3RyZWFtXG4gKiB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSByZWFkYWJsZSBzaWRlIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZW5kcyBhbmQgdmljZVxuICogdmVyc2EuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZWFkYWJsZU9iamVjdE1vZGU9ZmFsc2VdIFNldHMgb2JqZWN0TW9kZSBmb3IgcmVhZGFibGVcbiAqIHNpZGUgb2YgdGhlIHN0cmVhbS4gSGFzIG5vIGVmZmVjdCBpZiBvYmplY3RNb2RlIGlzIHRydWUuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFt3cml0YWJsZU9iamVjdE1vZGU9ZmFsc2VdIFNldHMgb2JqZWN0TW9kZSBmb3Igd3JpdGFibGVcbiAqIHNpZGUgb2YgdGhlIHN0cmVhbS4gSGFzIG5vIGVmZmVjdCBpZiBvYmplY3RNb2RlIGlzIHRydWUuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkZWNvZGVTdHJpbmdzPXRydWVdIFdoZXRoZXIgb3Igbm90IHRvIGRlY29kZSBzdHJpbmdzXG4gKiBpbnRvIEJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBfd3JpdGUoKS4gYFdyaXRhYmxlYFxuICogQHByb3BlcnR5IHtTdHJpbmd9IFtlbmNvZGluZz1OVUxMXSBJZiBzcGVjaWZpZWQsIHRoZW4gYnVmZmVycyB3aWxsIGJlIGRlY29kZWRcbiAqIHRvIHN0cmluZ3MgdXNpbmcgdGhlIHNwZWNpZmllZCBlbmNvZGluZy4gYFJlYWRhYmxlYFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtoaWdoV2F0ZXJNYXJrPTE2a2JdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byBzdG9yZVxuICogaW4gdGhlIGludGVybmFsIGJ1ZmZlciBiZWZvcmUgY2Vhc2luZyB0byByZWFkIGZyb20gdGhlIHVuZGVybHlpbmcgcmVzb3VyY2UuXG4gKiBgUmVhZGFibGVgIGBXcml0YWJsZWBcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW29iamVjdE1vZGU9ZmFsc2VdIFdoZXRoZXIgdGhpcyBzdHJlYW0gc2hvdWxkIGJlaGF2ZSBhcyBhXG4gKiBzdHJlYW0gb2Ygb2JqZWN0cy4gTWVhbmluZyB0aGF0IHN0cmVhbS5yZWFkKG4pIHJldHVybnMgYSBzaW5nbGUgdmFsdWUgaW5zdGVhZFxuICogb2YgYSBCdWZmZXIgb2Ygc2l6ZSBuLiBgUmVhZGFibGVgIGBXcml0YWJsZWBcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVudHJ5RGF0YVxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWUgU2V0cyB0aGUgZW50cnkgbmFtZSBpbmNsdWRpbmcgaW50ZXJuYWwgcGF0aC5cbiAqIEBwcm9wZXJ0eSB7KFN0cmluZ3xEYXRlKX0gW2RhdGU9Tk9XKCldIFNldHMgdGhlIGVudHJ5IGRhdGUuXG4gKiBAcHJvcGVydHkge051bWJlcn0gW21vZGU9RDowNzU1L0Y6MDY0NF0gU2V0cyB0aGUgZW50cnkgcGVybWlzc2lvbnMuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW3ByZWZpeF0gU2V0cyBhIHBhdGggcHJlZml4IGZvciB0aGUgZW50cnkgbmFtZS4gVXNlZnVsXG4gKiB3aGVuIHdvcmtpbmcgd2l0aCBtZXRob2RzIGxpa2UgYGRpcmVjdG9yeWAgb3IgYGdsb2JgLlxuICogQHByb3BlcnR5IHtmcy5TdGF0c30gW3N0YXRzXSBTZXRzIHRoZSBmcyBzdGF0IGRhdGEgZm9yIHRoaXMgZW50cnkgYWxsb3dpbmdcbiAqIGZvciByZWR1Y3Rpb24gb2YgZnMgc3RhdCBjYWxscyB3aGVuIHN0YXQgZGF0YSBpcyBhbHJlYWR5IGtub3duLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRXJyb3JEYXRhXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSBvZiB0aGUgZXJyb3IuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY29kZSBUaGUgZXJyb3IgY29kZSBhc3NpZ25lZCB0byB0aGlzIGVycm9yLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEgQWRkaXRpb25hbCBkYXRhIHByb3ZpZGVkIGZvciByZXBvcnRpbmcgb3IgZGVidWdnaW5nICh3aGVyZSBhdmFpbGFibGUpLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvZ3Jlc3NEYXRhXG4gKiBAcHJvcGVydHkge09iamVjdH0gZW50cmllc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGVudHJpZXMudG90YWwgTnVtYmVyIG9mIGVudHJpZXMgdGhhdCBoYXZlIGJlZW4gYXBwZW5kZWQuXG4gKiBAcHJvcGVydHkge051bWJlcn0gZW50cmllcy5wcm9jZXNzZWQgTnVtYmVyIG9mIGVudHJpZXMgdGhhdCBoYXZlIGJlZW4gcHJvY2Vzc2VkLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGZzXG4gKiBAcHJvcGVydHkge051bWJlcn0gZnMudG90YWxCeXRlcyBOdW1iZXIgb2YgYnl0ZXMgdGhhdCBoYXZlIGJlZW4gYXBwZW5kZWQuIENhbGN1bGF0ZWQgYXN5bmNocm9ub3VzbHkgYW5kIG1pZ2h0IG5vdCBiZSBhY2N1cmF0ZTogaXQgZ3Jvd3RoIHdoaWxlIGVudHJpZXMgYXJlIGFkZGVkLiAoYmFzZWQgb24gZnMuU3RhdHMpXG4gKiBAcHJvcGVydHkge051bWJlcn0gZnMucHJvY2Vzc2VkQnl0ZXMgTnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gKGJhc2VkIG9uIGZzLlN0YXRzKVxuICovXG4iXSwibmFtZXMiOlsiZnMiLCJyZXF1aXJlIiwiZ2xvYiIsImFzeW5jIiwicGF0aCIsInV0aWwiLCJpbmhlcml0cyIsIkFyY2hpdmVyRXJyb3IiLCJUcmFuc2Zvcm0iLCJ3aW4zMiIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsIkFyY2hpdmVyIiwiZm9ybWF0Iiwib3B0aW9ucyIsImRlZmF1bHRzIiwiaGlnaFdhdGVyTWFyayIsInN0YXRDb25jdXJyZW5jeSIsImNhbGwiLCJfZm9ybWF0IiwiX21vZHVsZSIsIl9wZW5kaW5nIiwiX3BvaW50ZXIiLCJfZW50cmllc0NvdW50IiwiX2VudHJpZXNQcm9jZXNzZWRDb3VudCIsIl9mc0VudHJpZXNUb3RhbEJ5dGVzIiwiX2ZzRW50cmllc1Byb2Nlc3NlZEJ5dGVzIiwiX3F1ZXVlIiwicXVldWUiLCJfb25RdWV1ZVRhc2siLCJiaW5kIiwiZHJhaW4iLCJfb25RdWV1ZURyYWluIiwiX3N0YXRRdWV1ZSIsIl9vblN0YXRRdWV1ZVRhc2siLCJfc3RhdGUiLCJhYm9ydGVkIiwiZmluYWxpemUiLCJmaW5hbGl6aW5nIiwiZmluYWxpemVkIiwibW9kdWxlUGlwZWQiLCJfc3RyZWFtcyIsInByb3RvdHlwZSIsIl9hYm9ydCIsImtpbGwiLCJpZGxlIiwiX3NodXRkb3duIiwiX2FwcGVuZCIsImZpbGVwYXRoIiwiZGF0YSIsInRhc2siLCJzb3VyY2UiLCJuYW1lIiwic291cmNlUGF0aCIsInN0YXRzIiwiU3RhdHMiLCJfdXBkYXRlUXVldWVUYXNrV2l0aFN0YXRzIiwic2l6ZSIsInB1c2giLCJfZmluYWxpemUiLCJfbW9kdWxlRmluYWxpemUiLCJfbWF5YmVGaW5hbGl6ZSIsIl9tb2R1bGVBcHBlbmQiLCJjYWxsYmFjayIsImFwcGVuZCIsImVyciIsIl90YXNrIiwiZW1pdCIsInNldEltbWVkaWF0ZSIsImVudHJpZXMiLCJ0b3RhbCIsInByb2Nlc3NlZCIsInRvdGFsQnl0ZXMiLCJwcm9jZXNzZWRCeXRlcyIsImVuZCIsIl9tb2R1bGVQaXBlIiwib24iLCJfb25Nb2R1bGVFcnJvciIsInBpcGUiLCJfbW9kdWxlU3VwcG9ydHMiLCJrZXkiLCJzdXBwb3J0cyIsIl9tb2R1bGVVbnBpcGUiLCJ1bnBpcGUiLCJfbm9ybWFsaXplRW50cnlEYXRhIiwidHlwZSIsImRhdGUiLCJtb2RlIiwicHJlZml4IiwiaXNEaXIiLCJzYW5pdGl6ZVBhdGgiLCJzbGljZSIsIm10aW1lIiwiZGF0ZWlmeSIsImZ1bGxDYWxsYmFjayIsImxzdGF0IiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJsZW5ndGgiLCJpc0ZpbGUiLCJzb3VyY2VUeXBlIiwibGF6eVJlYWRTdHJlYW0iLCJpc0RpcmVjdG9yeSIsInRyYWlsaW5nU2xhc2hJdCIsIkJ1ZmZlciIsImNvbmNhdCIsImlzU3ltYm9saWNMaW5rIiwibGlua1BhdGgiLCJyZWFkbGlua1N5bmMiLCJkaXJOYW1lIiwiZGlybmFtZSIsImxpbmtuYW1lIiwicmVsYXRpdmUiLCJyZXNvbHZlIiwiYWJvcnQiLCJub3JtYWxpemVJbnB1dFNvdXJjZSIsImlzQnVmZmVyIiwiaXNTdHJlYW0iLCJkaXJlY3RvcnkiLCJkaXJwYXRoIiwiZGVzdHBhdGgiLCJkYXRhRnVuY3Rpb24iLCJnbG9iT3B0aW9ucyIsInN0YXQiLCJkb3QiLCJvbkdsb2JFbmQiLCJvbkdsb2JFcnJvciIsIm9uR2xvYk1hdGNoIiwibWF0Y2giLCJnbG9iYmVyIiwicGF1c2UiLCJpZ25vcmVNYXRjaCIsImVudHJ5RGF0YSIsIk9iamVjdCIsImFzc2lnbiIsInJlc3VtZSIsImUiLCJhYnNvbHV0ZSIsImZpbGUiLCJwYXR0ZXJuIiwiY3dkIiwiYWJvcnRlZEVycm9yIiwiUHJvbWlzZSIsInJlamVjdCIsImZpbmFsaXppbmdFcnJvciIsInNlbGYiLCJlcnJvcmVkIiwic2V0Rm9ybWF0Iiwic2V0TW9kdWxlIiwibW9kdWxlIiwic3ltbGluayIsInRhcmdldCIsInJlcGxhY2UiLCJwb2ludGVyIiwidXNlIiwicGx1Z2luIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/archiver/lib/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/archiver/lib/error.js":
/*!********************************************!*\
  !*** ./node_modules/archiver/lib/error.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Archiver Core\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */ var util = __webpack_require__(/*! util */ \"util\");\nconst ERROR_CODES = {\n    \"ABORTED\": \"archive was aborted\",\n    \"DIRECTORYDIRPATHREQUIRED\": \"diretory dirpath argument must be a non-empty string value\",\n    \"DIRECTORYFUNCTIONINVALIDDATA\": \"invalid data returned by directory custom data function\",\n    \"ENTRYNAMEREQUIRED\": \"entry name must be a non-empty string value\",\n    \"FILEFILEPATHREQUIRED\": \"file filepath argument must be a non-empty string value\",\n    \"FINALIZING\": \"archive already finalizing\",\n    \"QUEUECLOSED\": \"queue closed\",\n    \"NOENDMETHOD\": \"no suitable finalize/end method defined by module\",\n    \"DIRECTORYNOTSUPPORTED\": \"support for directory entries not defined by module\",\n    \"FORMATSET\": \"archive format already set\",\n    \"INPUTSTEAMBUFFERREQUIRED\": \"input source must be valid Stream or Buffer instance\",\n    \"MODULESET\": \"module already set\",\n    \"SYMLINKNOTSUPPORTED\": \"support for symlink entries not defined by module\",\n    \"SYMLINKFILEPATHREQUIRED\": \"symlink filepath argument must be a non-empty string value\",\n    \"SYMLINKTARGETREQUIRED\": \"symlink target argument must be a non-empty string value\",\n    \"ENTRYNOTSUPPORTED\": \"entry not supported\"\n};\nfunction ArchiverError(code, data) {\n    Error.captureStackTrace(this, this.constructor);\n    //this.name = this.constructor.name;\n    this.message = ERROR_CODES[code] || code;\n    this.code = code;\n    this.data = data;\n}\nutil.inherits(ArchiverError, Error);\nexports = module.exports = ArchiverError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJjaGl2ZXIvbGliL2Vycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQyxHQUVELElBQUlBLE9BQU9DLG1CQUFPQSxDQUFDO0FBRW5CLE1BQU1DLGNBQWM7SUFDbEIsV0FBVztJQUNYLDRCQUE0QjtJQUM1QixnQ0FBZ0M7SUFDaEMscUJBQXFCO0lBQ3JCLHdCQUF3QjtJQUN4QixjQUFjO0lBQ2QsZUFBZTtJQUNmLGVBQWU7SUFDZix5QkFBeUI7SUFDekIsYUFBYTtJQUNiLDRCQUE0QjtJQUM1QixhQUFhO0lBQ2IsdUJBQXVCO0lBQ3ZCLDJCQUEyQjtJQUMzQix5QkFBeUI7SUFDekIscUJBQXFCO0FBQ3ZCO0FBRUEsU0FBU0MsY0FBY0MsSUFBSSxFQUFFQyxJQUFJO0lBQy9CQyxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxXQUFXO0lBQzlDLG9DQUFvQztJQUNwQyxJQUFJLENBQUNDLE9BQU8sR0FBR1AsV0FBVyxDQUFDRSxLQUFLLElBQUlBO0lBQ3BDLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtJQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtBQUNkO0FBRUFMLEtBQUtVLFFBQVEsQ0FBQ1AsZUFBZUc7QUFFN0JLLFVBQVVDLE9BQU9ELE9BQU8sR0FBR1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZC10aW1lc2hlZXQtYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvYXJjaGl2ZXIvbGliL2Vycm9yLmpzPzRjZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBcmNoaXZlciBDb3JlXG4gKlxuICogQGlnbm9yZVxuICogQGxpY2Vuc2UgW01JVF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS1hcmNoaXZlci9ibG9iL21hc3Rlci9MSUNFTlNFfVxuICogQGNvcHlyaWdodCAoYykgMjAxMi0yMDE0IENocmlzIFRhbGtpbmd0b24sIGNvbnRyaWJ1dG9ycy5cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgRVJST1JfQ09ERVMgPSB7XG4gICdBQk9SVEVEJzogJ2FyY2hpdmUgd2FzIGFib3J0ZWQnLFxuICAnRElSRUNUT1JZRElSUEFUSFJFUVVJUkVEJzogJ2RpcmV0b3J5IGRpcnBhdGggYXJndW1lbnQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgdmFsdWUnLFxuICAnRElSRUNUT1JZRlVOQ1RJT05JTlZBTElEREFUQSc6ICdpbnZhbGlkIGRhdGEgcmV0dXJuZWQgYnkgZGlyZWN0b3J5IGN1c3RvbSBkYXRhIGZ1bmN0aW9uJyxcbiAgJ0VOVFJZTkFNRVJFUVVJUkVEJzogJ2VudHJ5IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgdmFsdWUnLFxuICAnRklMRUZJTEVQQVRIUkVRVUlSRUQnOiAnZmlsZSBmaWxlcGF0aCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyB2YWx1ZScsXG4gICdGSU5BTElaSU5HJzogJ2FyY2hpdmUgYWxyZWFkeSBmaW5hbGl6aW5nJyxcbiAgJ1FVRVVFQ0xPU0VEJzogJ3F1ZXVlIGNsb3NlZCcsXG4gICdOT0VORE1FVEhPRCc6ICdubyBzdWl0YWJsZSBmaW5hbGl6ZS9lbmQgbWV0aG9kIGRlZmluZWQgYnkgbW9kdWxlJyxcbiAgJ0RJUkVDVE9SWU5PVFNVUFBPUlRFRCc6ICdzdXBwb3J0IGZvciBkaXJlY3RvcnkgZW50cmllcyBub3QgZGVmaW5lZCBieSBtb2R1bGUnLFxuICAnRk9STUFUU0VUJzogJ2FyY2hpdmUgZm9ybWF0IGFscmVhZHkgc2V0JyxcbiAgJ0lOUFVUU1RFQU1CVUZGRVJSRVFVSVJFRCc6ICdpbnB1dCBzb3VyY2UgbXVzdCBiZSB2YWxpZCBTdHJlYW0gb3IgQnVmZmVyIGluc3RhbmNlJyxcbiAgJ01PRFVMRVNFVCc6ICdtb2R1bGUgYWxyZWFkeSBzZXQnLFxuICAnU1lNTElOS05PVFNVUFBPUlRFRCc6ICdzdXBwb3J0IGZvciBzeW1saW5rIGVudHJpZXMgbm90IGRlZmluZWQgYnkgbW9kdWxlJyxcbiAgJ1NZTUxJTktGSUxFUEFUSFJFUVVJUkVEJzogJ3N5bWxpbmsgZmlsZXBhdGggYXJndW1lbnQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgdmFsdWUnLFxuICAnU1lNTElOS1RBUkdFVFJFUVVJUkVEJzogJ3N5bWxpbmsgdGFyZ2V0IGFyZ3VtZW50IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIHZhbHVlJyxcbiAgJ0VOVFJZTk9UU1VQUE9SVEVEJzogJ2VudHJ5IG5vdCBzdXBwb3J0ZWQnXG59O1xuXG5mdW5jdGlvbiBBcmNoaXZlckVycm9yKGNvZGUsIGRhdGEpIHtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIC8vdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB0aGlzLm1lc3NhZ2UgPSBFUlJPUl9DT0RFU1tjb2RlXSB8fCBjb2RlO1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG51dGlsLmluaGVyaXRzKEFyY2hpdmVyRXJyb3IsIEVycm9yKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQXJjaGl2ZXJFcnJvcjsiXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJFUlJPUl9DT0RFUyIsIkFyY2hpdmVyRXJyb3IiLCJjb2RlIiwiZGF0YSIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJpbmhlcml0cyIsImV4cG9ydHMiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/archiver/lib/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/archiver/lib/plugins/json.js":
/*!***************************************************!*\
  !*** ./node_modules/archiver/lib/plugins/json.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * JSON Format Plugin\n *\n * @module plugins/json\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */ var inherits = (__webpack_require__(/*! util */ \"util\").inherits);\nvar Transform = (__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/readable.js\").Transform);\nvar crc32 = __webpack_require__(/*! buffer-crc32 */ \"(ssr)/./node_modules/buffer-crc32/index.js\");\nvar util = __webpack_require__(/*! archiver-utils */ \"(ssr)/./node_modules/archiver-utils/index.js\");\n/**\n * @constructor\n * @param {(JsonOptions|TransformOptions)} options\n */ var Json = function(options) {\n    if (!(this instanceof Json)) {\n        return new Json(options);\n    }\n    options = this.options = util.defaults(options, {});\n    Transform.call(this, options);\n    this.supports = {\n        directory: true,\n        symlink: true\n    };\n    this.files = [];\n};\ninherits(Json, Transform);\n/**\n * [_transform description]\n *\n * @private\n * @param  {Buffer}   chunk\n * @param  {String}   encoding\n * @param  {Function} callback\n * @return void\n */ Json.prototype._transform = function(chunk, encoding, callback) {\n    callback(null, chunk);\n};\n/**\n * [_writeStringified description]\n *\n * @private\n * @return void\n */ Json.prototype._writeStringified = function() {\n    var fileString = JSON.stringify(this.files);\n    this.write(fileString);\n};\n/**\n * [append description]\n *\n * @param  {(Buffer|Stream)}   source\n * @param  {EntryData}   data\n * @param  {Function} callback\n * @return void\n */ Json.prototype.append = function(source, data, callback) {\n    var self = this;\n    data.crc32 = 0;\n    function onend(err, sourceBuffer) {\n        if (err) {\n            callback(err);\n            return;\n        }\n        data.size = sourceBuffer.length || 0;\n        data.crc32 = crc32.unsigned(sourceBuffer);\n        self.files.push(data);\n        callback(null, data);\n    }\n    if (data.sourceType === \"buffer\") {\n        onend(null, source);\n    } else if (data.sourceType === \"stream\") {\n        util.collectStream(source, onend);\n    }\n};\n/**\n * [finalize description]\n *\n * @return void\n */ Json.prototype.finalize = function() {\n    this._writeStringified();\n    this.end();\n};\nmodule.exports = Json; /**\n * @typedef {Object} JsonOptions\n * @global\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJjaGl2ZXIvbGliL3BsdWdpbnMvanNvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUMsR0FDRCxJQUFJQSxXQUFXQyxrREFBd0I7QUFDdkMsSUFBSUMsWUFBWUQsMEdBQW9DO0FBRXBELElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlHLE9BQU9ILG1CQUFPQSxDQUFDO0FBRW5COzs7Q0FHQyxHQUNELElBQUlJLE9BQU8sU0FBU0MsT0FBTztJQUN6QixJQUFJLENBQUUsS0FBSSxZQUFZRCxJQUFHLEdBQUk7UUFDM0IsT0FBTyxJQUFJQSxLQUFLQztJQUNsQjtJQUVBQSxVQUFVLElBQUksQ0FBQ0EsT0FBTyxHQUFHRixLQUFLRyxRQUFRLENBQUNELFNBQVMsQ0FBQztJQUVqREosVUFBVU0sSUFBSSxDQUFDLElBQUksRUFBRUY7SUFFckIsSUFBSSxDQUFDRyxRQUFRLEdBQUc7UUFDZEMsV0FBVztRQUNYQyxTQUFTO0lBQ1g7SUFFQSxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO0FBQ2pCO0FBRUFaLFNBQVNLLE1BQU1IO0FBRWY7Ozs7Ozs7O0NBUUMsR0FDREcsS0FBS1EsU0FBUyxDQUFDQyxVQUFVLEdBQUcsU0FBU0MsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLFFBQVE7SUFDNURBLFNBQVMsTUFBTUY7QUFDakI7QUFFQTs7Ozs7Q0FLQyxHQUNEVixLQUFLUSxTQUFTLENBQUNLLGlCQUFpQixHQUFHO0lBQ2pDLElBQUlDLGFBQWFDLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUNULEtBQUs7SUFDMUMsSUFBSSxDQUFDVSxLQUFLLENBQUNIO0FBQ2I7QUFFQTs7Ozs7OztDQU9DLEdBQ0RkLEtBQUtRLFNBQVMsQ0FBQ1UsTUFBTSxHQUFHLFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFUixRQUFRO0lBQ3JELElBQUlTLE9BQU8sSUFBSTtJQUVmRCxLQUFLdEIsS0FBSyxHQUFHO0lBRWIsU0FBU3dCLE1BQU1DLEdBQUcsRUFBRUMsWUFBWTtRQUM5QixJQUFJRCxLQUFLO1lBQ1BYLFNBQVNXO1lBQ1Q7UUFDRjtRQUVBSCxLQUFLSyxJQUFJLEdBQUdELGFBQWFFLE1BQU0sSUFBSTtRQUNuQ04sS0FBS3RCLEtBQUssR0FBR0EsTUFBTTZCLFFBQVEsQ0FBQ0g7UUFFNUJILEtBQUtkLEtBQUssQ0FBQ3FCLElBQUksQ0FBQ1I7UUFFaEJSLFNBQVMsTUFBTVE7SUFDakI7SUFFQSxJQUFJQSxLQUFLUyxVQUFVLEtBQUssVUFBVTtRQUNoQ1AsTUFBTSxNQUFNSDtJQUNkLE9BQU8sSUFBSUMsS0FBS1MsVUFBVSxLQUFLLFVBQVU7UUFDdkM5QixLQUFLK0IsYUFBYSxDQUFDWCxRQUFRRztJQUM3QjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNEdEIsS0FBS1EsU0FBUyxDQUFDdUIsUUFBUSxHQUFHO0lBQ3hCLElBQUksQ0FBQ2xCLGlCQUFpQjtJQUN0QixJQUFJLENBQUNtQixHQUFHO0FBQ1Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHbEMsTUFFakI7OztDQUdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2QtdGltZXNoZWV0LWFuYWx5emVyLy4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyL2xpYi9wbHVnaW5zL2pzb24uanM/ZDdiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEpTT04gRm9ybWF0IFBsdWdpblxuICpcbiAqIEBtb2R1bGUgcGx1Z2lucy9qc29uXG4gKiBAbGljZW5zZSBbTUlUXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXJjaGl2ZXJqcy9ub2RlLWFyY2hpdmVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0V9XG4gKiBAY29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQ2hyaXMgVGFsa2luZ3RvbiwgY29udHJpYnV0b3JzLlxuICovXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtO1xuXG52YXIgY3JjMzIgPSByZXF1aXJlKCdidWZmZXItY3JjMzInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnYXJjaGl2ZXItdXRpbHMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7KEpzb25PcHRpb25zfFRyYW5zZm9ybU9wdGlvbnMpfSBvcHRpb25zXG4gKi9cbnZhciBKc29uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSnNvbikpIHtcbiAgICByZXR1cm4gbmV3IEpzb24ob3B0aW9ucyk7XG4gIH1cblxuICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gdXRpbC5kZWZhdWx0cyhvcHRpb25zLCB7fSk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5zdXBwb3J0cyA9IHtcbiAgICBkaXJlY3Rvcnk6IHRydWUsXG4gICAgc3ltbGluazogdHJ1ZVxuICB9O1xuXG4gIHRoaXMuZmlsZXMgPSBbXTtcbn07XG5cbmluaGVyaXRzKEpzb24sIFRyYW5zZm9ybSk7XG5cbi8qKlxuICogW190cmFuc2Zvcm0gZGVzY3JpcHRpb25dXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0J1ZmZlcn0gICBjaHVua1xuICogQHBhcmFtICB7U3RyaW5nfSAgIGVuY29kaW5nXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4gdm9pZFxuICovXG5Kc29uLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG59O1xuXG4vKipcbiAqIFtfd3JpdGVTdHJpbmdpZmllZCBkZXNjcmlwdGlvbl1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB2b2lkXG4gKi9cbkpzb24ucHJvdG90eXBlLl93cml0ZVN0cmluZ2lmaWVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmaWxlU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodGhpcy5maWxlcyk7XG4gIHRoaXMud3JpdGUoZmlsZVN0cmluZyk7XG59O1xuXG4vKipcbiAqIFthcHBlbmQgZGVzY3JpcHRpb25dXG4gKlxuICogQHBhcmFtICB7KEJ1ZmZlcnxTdHJlYW0pfSAgIHNvdXJjZVxuICogQHBhcmFtICB7RW50cnlEYXRhfSAgIGRhdGFcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB2b2lkXG4gKi9cbkpzb24ucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHNvdXJjZSwgZGF0YSwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGRhdGEuY3JjMzIgPSAwO1xuXG4gIGZ1bmN0aW9uIG9uZW5kKGVyciwgc291cmNlQnVmZmVyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhLnNpemUgPSBzb3VyY2VCdWZmZXIubGVuZ3RoIHx8IDA7XG4gICAgZGF0YS5jcmMzMiA9IGNyYzMyLnVuc2lnbmVkKHNvdXJjZUJ1ZmZlcik7XG5cbiAgICBzZWxmLmZpbGVzLnB1c2goZGF0YSk7XG5cbiAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgfVxuXG4gIGlmIChkYXRhLnNvdXJjZVR5cGUgPT09ICdidWZmZXInKSB7XG4gICAgb25lbmQobnVsbCwgc291cmNlKTtcbiAgfSBlbHNlIGlmIChkYXRhLnNvdXJjZVR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgdXRpbC5jb2xsZWN0U3RyZWFtKHNvdXJjZSwgb25lbmQpO1xuICB9XG59O1xuXG4vKipcbiAqIFtmaW5hbGl6ZSBkZXNjcmlwdGlvbl1cbiAqXG4gKiBAcmV0dXJuIHZvaWRcbiAqL1xuSnNvbi5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fd3JpdGVTdHJpbmdpZmllZCgpO1xuICB0aGlzLmVuZCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEpzb25PcHRpb25zXG4gKiBAZ2xvYmFsXG4gKi9cbiJdLCJuYW1lcyI6WyJpbmhlcml0cyIsInJlcXVpcmUiLCJUcmFuc2Zvcm0iLCJjcmMzMiIsInV0aWwiLCJKc29uIiwib3B0aW9ucyIsImRlZmF1bHRzIiwiY2FsbCIsInN1cHBvcnRzIiwiZGlyZWN0b3J5Iiwic3ltbGluayIsImZpbGVzIiwicHJvdG90eXBlIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsIl93cml0ZVN0cmluZ2lmaWVkIiwiZmlsZVN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ3cml0ZSIsImFwcGVuZCIsInNvdXJjZSIsImRhdGEiLCJzZWxmIiwib25lbmQiLCJlcnIiLCJzb3VyY2VCdWZmZXIiLCJzaXplIiwibGVuZ3RoIiwidW5zaWduZWQiLCJwdXNoIiwic291cmNlVHlwZSIsImNvbGxlY3RTdHJlYW0iLCJmaW5hbGl6ZSIsImVuZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/archiver/lib/plugins/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/archiver/lib/plugins/tar.js":
/*!**************************************************!*\
  !*** ./node_modules/archiver/lib/plugins/tar.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * TAR Format Plugin\n *\n * @module plugins/tar\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */ var zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar engine = __webpack_require__(/*! tar-stream */ \"(ssr)/./node_modules/tar-stream/index.js\");\nvar util = __webpack_require__(/*! archiver-utils */ \"(ssr)/./node_modules/archiver-utils/index.js\");\n/**\n * @constructor\n * @param {TarOptions} options\n */ var Tar = function(options) {\n    if (!(this instanceof Tar)) {\n        return new Tar(options);\n    }\n    options = this.options = util.defaults(options, {\n        gzip: false\n    });\n    if (typeof options.gzipOptions !== \"object\") {\n        options.gzipOptions = {};\n    }\n    this.supports = {\n        directory: true,\n        symlink: true\n    };\n    this.engine = engine.pack(options);\n    this.compressor = false;\n    if (options.gzip) {\n        this.compressor = zlib.createGzip(options.gzipOptions);\n        this.compressor.on(\"error\", this._onCompressorError.bind(this));\n    }\n};\n/**\n * [_onCompressorError description]\n *\n * @private\n * @param  {Error} err\n * @return void\n */ Tar.prototype._onCompressorError = function(err) {\n    this.engine.emit(\"error\", err);\n};\n/**\n * [append description]\n *\n * @param  {(Buffer|Stream)} source\n * @param  {TarEntryData} data\n * @param  {Function} callback\n * @return void\n */ Tar.prototype.append = function(source, data, callback) {\n    var self = this;\n    data.mtime = data.date;\n    function append(err, sourceBuffer) {\n        if (err) {\n            callback(err);\n            return;\n        }\n        self.engine.entry(data, sourceBuffer, function(err) {\n            callback(err, data);\n        });\n    }\n    if (data.sourceType === \"buffer\") {\n        append(null, source);\n    } else if (data.sourceType === \"stream\" && data.stats) {\n        data.size = data.stats.size;\n        var entry = self.engine.entry(data, function(err) {\n            callback(err, data);\n        });\n        source.pipe(entry);\n    } else if (data.sourceType === \"stream\") {\n        util.collectStream(source, append);\n    }\n};\n/**\n * [finalize description]\n *\n * @return void\n */ Tar.prototype.finalize = function() {\n    this.engine.finalize();\n};\n/**\n * [on description]\n *\n * @return this.engine\n */ Tar.prototype.on = function() {\n    return this.engine.on.apply(this.engine, arguments);\n};\n/**\n * [pipe description]\n *\n * @param  {String} destination\n * @param  {Object} options\n * @return this.engine\n */ Tar.prototype.pipe = function(destination, options) {\n    if (this.compressor) {\n        return this.engine.pipe.apply(this.engine, [\n            this.compressor\n        ]).pipe(destination, options);\n    } else {\n        return this.engine.pipe.apply(this.engine, arguments);\n    }\n};\n/**\n * [unpipe description]\n *\n * @return this.engine\n */ Tar.prototype.unpipe = function() {\n    if (this.compressor) {\n        return this.compressor.unpipe.apply(this.compressor, arguments);\n    } else {\n        return this.engine.unpipe.apply(this.engine, arguments);\n    }\n};\nmodule.exports = Tar; /**\n * @typedef {Object} TarOptions\n * @global\n * @property {Boolean} [gzip=false] Compress the tar archive using gzip.\n * @property {Object} [gzipOptions] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}\n * to control compression.\n * @property {*} [*] See [tar-stream]{@link https://github.com/mafintosh/tar-stream} documentation for additional properties.\n */  /**\n * @typedef {Object} TarEntryData\n * @global\n * @property {String} name Sets the entry name including internal path.\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\n * when working with methods like `directory` or `glob`.\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\n * for reduction of fs stat calls when stat data is already known.\n */  /**\n * TarStream Module\n * @external TarStream\n * @see {@link https://github.com/mafintosh/tar-stream}\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJjaGl2ZXIvbGliL3BsdWdpbnMvdGFyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQyxHQUNELElBQUlBLE9BQU9DLG1CQUFPQSxDQUFDO0FBRW5CLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlFLE9BQU9GLG1CQUFPQSxDQUFDO0FBRW5COzs7Q0FHQyxHQUNELElBQUlHLE1BQU0sU0FBU0MsT0FBTztJQUN4QixJQUFJLENBQUUsS0FBSSxZQUFZRCxHQUFFLEdBQUk7UUFDMUIsT0FBTyxJQUFJQSxJQUFJQztJQUNqQjtJQUVBQSxVQUFVLElBQUksQ0FBQ0EsT0FBTyxHQUFHRixLQUFLRyxRQUFRLENBQUNELFNBQVM7UUFDOUNFLE1BQU07SUFDUjtJQUVBLElBQUksT0FBT0YsUUFBUUcsV0FBVyxLQUFLLFVBQVU7UUFDM0NILFFBQVFHLFdBQVcsR0FBRyxDQUFDO0lBQ3pCO0lBRUEsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDZEMsV0FBVztRQUNYQyxTQUFTO0lBQ1g7SUFFQSxJQUFJLENBQUNULE1BQU0sR0FBR0EsT0FBT1UsSUFBSSxDQUFDUDtJQUMxQixJQUFJLENBQUNRLFVBQVUsR0FBRztJQUVsQixJQUFJUixRQUFRRSxJQUFJLEVBQUU7UUFDaEIsSUFBSSxDQUFDTSxVQUFVLEdBQUdiLEtBQUtjLFVBQVUsQ0FBQ1QsUUFBUUcsV0FBVztRQUNyRCxJQUFJLENBQUNLLFVBQVUsQ0FBQ0UsRUFBRSxDQUFDLFNBQVMsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7SUFDL0Q7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNEYixJQUFJYyxTQUFTLENBQUNGLGtCQUFrQixHQUFHLFNBQVNHLEdBQUc7SUFDN0MsSUFBSSxDQUFDakIsTUFBTSxDQUFDa0IsSUFBSSxDQUFDLFNBQVNEO0FBQzVCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEZixJQUFJYyxTQUFTLENBQUNHLE1BQU0sR0FBRyxTQUFTQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsUUFBUTtJQUNwRCxJQUFJQyxPQUFPLElBQUk7SUFFZkYsS0FBS0csS0FBSyxHQUFHSCxLQUFLSSxJQUFJO0lBRXRCLFNBQVNOLE9BQU9GLEdBQUcsRUFBRVMsWUFBWTtRQUMvQixJQUFJVCxLQUFLO1lBQ1BLLFNBQVNMO1lBQ1Q7UUFDRjtRQUVBTSxLQUFLdkIsTUFBTSxDQUFDMkIsS0FBSyxDQUFDTixNQUFNSyxjQUFjLFNBQVNULEdBQUc7WUFDaERLLFNBQVNMLEtBQUtJO1FBQ2hCO0lBQ0Y7SUFFQSxJQUFJQSxLQUFLTyxVQUFVLEtBQUssVUFBVTtRQUNoQ1QsT0FBTyxNQUFNQztJQUNmLE9BQU8sSUFBSUMsS0FBS08sVUFBVSxLQUFLLFlBQVlQLEtBQUtRLEtBQUssRUFBRTtRQUNyRFIsS0FBS1MsSUFBSSxHQUFHVCxLQUFLUSxLQUFLLENBQUNDLElBQUk7UUFFM0IsSUFBSUgsUUFBUUosS0FBS3ZCLE1BQU0sQ0FBQzJCLEtBQUssQ0FBQ04sTUFBTSxTQUFTSixHQUFHO1lBQzlDSyxTQUFTTCxLQUFLSTtRQUNoQjtRQUVBRCxPQUFPVyxJQUFJLENBQUNKO0lBQ2QsT0FBTyxJQUFJTixLQUFLTyxVQUFVLEtBQUssVUFBVTtRQUN2QzNCLEtBQUsrQixhQUFhLENBQUNaLFFBQVFEO0lBQzdCO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0RqQixJQUFJYyxTQUFTLENBQUNpQixRQUFRLEdBQUc7SUFDdkIsSUFBSSxDQUFDakMsTUFBTSxDQUFDaUMsUUFBUTtBQUN0QjtBQUVBOzs7O0NBSUMsR0FDRC9CLElBQUljLFNBQVMsQ0FBQ0gsRUFBRSxHQUFHO0lBQ2pCLE9BQU8sSUFBSSxDQUFDYixNQUFNLENBQUNhLEVBQUUsQ0FBQ3FCLEtBQUssQ0FBQyxJQUFJLENBQUNsQyxNQUFNLEVBQUVtQztBQUMzQztBQUVBOzs7Ozs7Q0FNQyxHQUNEakMsSUFBSWMsU0FBUyxDQUFDZSxJQUFJLEdBQUcsU0FBU0ssV0FBVyxFQUFFakMsT0FBTztJQUNoRCxJQUFJLElBQUksQ0FBQ1EsVUFBVSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDWCxNQUFNLENBQUMrQixJQUFJLENBQUNHLEtBQUssQ0FBQyxJQUFJLENBQUNsQyxNQUFNLEVBQUU7WUFBQyxJQUFJLENBQUNXLFVBQVU7U0FBQyxFQUFFb0IsSUFBSSxDQUFDSyxhQUFhakM7SUFDbEYsT0FBTztRQUNMLE9BQU8sSUFBSSxDQUFDSCxNQUFNLENBQUMrQixJQUFJLENBQUNHLEtBQUssQ0FBQyxJQUFJLENBQUNsQyxNQUFNLEVBQUVtQztJQUM3QztBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNEakMsSUFBSWMsU0FBUyxDQUFDcUIsTUFBTSxHQUFHO0lBQ3JCLElBQUksSUFBSSxDQUFDMUIsVUFBVSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDQSxVQUFVLENBQUMwQixNQUFNLENBQUNILEtBQUssQ0FBQyxJQUFJLENBQUN2QixVQUFVLEVBQUV3QjtJQUN2RCxPQUFPO1FBQ0wsT0FBTyxJQUFJLENBQUNuQyxNQUFNLENBQUNxQyxNQUFNLENBQUNILEtBQUssQ0FBQyxJQUFJLENBQUNsQyxNQUFNLEVBQUVtQztJQUMvQztBQUNGO0FBRUFHLE9BQU9DLE9BQU8sR0FBR3JDLEtBRWpCOzs7Ozs7O0NBT0MsSUFFRDs7Ozs7Ozs7OztDQVVDLElBRUQ7Ozs7Q0FJQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NkLXRpbWVzaGVldC1hbmFseXplci8uL25vZGVfbW9kdWxlcy9hcmNoaXZlci9saWIvcGx1Z2lucy90YXIuanM/YTA1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRBUiBGb3JtYXQgUGx1Z2luXG4gKlxuICogQG1vZHVsZSBwbHVnaW5zL3RhclxuICogQGxpY2Vuc2UgW01JVF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS1hcmNoaXZlci9ibG9iL21hc3Rlci9MSUNFTlNFfVxuICogQGNvcHlyaWdodCAoYykgMjAxMi0yMDE0IENocmlzIFRhbGtpbmd0b24sIGNvbnRyaWJ1dG9ycy5cbiAqL1xudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbnZhciBlbmdpbmUgPSByZXF1aXJlKCd0YXItc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ2FyY2hpdmVyLXV0aWxzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Rhck9wdGlvbnN9IG9wdGlvbnNcbiAqL1xudmFyIFRhciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRhcikpIHtcbiAgICByZXR1cm4gbmV3IFRhcihvcHRpb25zKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSB1dGlsLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBnemlwOiBmYWxzZVxuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuZ3ppcE9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucy5nemlwT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdGhpcy5zdXBwb3J0cyA9IHtcbiAgICBkaXJlY3Rvcnk6IHRydWUsXG4gICAgc3ltbGluazogdHJ1ZVxuICB9O1xuXG4gIHRoaXMuZW5naW5lID0gZW5naW5lLnBhY2sob3B0aW9ucyk7XG4gIHRoaXMuY29tcHJlc3NvciA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zLmd6aXApIHtcbiAgICB0aGlzLmNvbXByZXNzb3IgPSB6bGliLmNyZWF0ZUd6aXAob3B0aW9ucy5nemlwT3B0aW9ucyk7XG4gICAgdGhpcy5jb21wcmVzc29yLm9uKCdlcnJvcicsIHRoaXMuX29uQ29tcHJlc3NvckVycm9yLmJpbmQodGhpcykpO1xuICB9XG59O1xuXG4vKipcbiAqIFtfb25Db21wcmVzc29yRXJyb3IgZGVzY3JpcHRpb25dXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0Vycm9yfSBlcnJcbiAqIEByZXR1cm4gdm9pZFxuICovXG5UYXIucHJvdG90eXBlLl9vbkNvbXByZXNzb3JFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICB0aGlzLmVuZ2luZS5lbWl0KCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIFthcHBlbmQgZGVzY3JpcHRpb25dXG4gKlxuICogQHBhcmFtICB7KEJ1ZmZlcnxTdHJlYW0pfSBzb3VyY2VcbiAqIEBwYXJhbSAge1RhckVudHJ5RGF0YX0gZGF0YVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHZvaWRcbiAqL1xuVGFyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBkYXRhLm10aW1lID0gZGF0YS5kYXRlO1xuXG4gIGZ1bmN0aW9uIGFwcGVuZChlcnIsIHNvdXJjZUJ1ZmZlcikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5lbmdpbmUuZW50cnkoZGF0YSwgc291cmNlQnVmZmVyLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGF0YS5zb3VyY2VUeXBlID09PSAnYnVmZmVyJykge1xuICAgIGFwcGVuZChudWxsLCBzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGRhdGEuc291cmNlVHlwZSA9PT0gJ3N0cmVhbScgJiYgZGF0YS5zdGF0cykge1xuICAgIGRhdGEuc2l6ZSA9IGRhdGEuc3RhdHMuc2l6ZTtcblxuICAgIHZhciBlbnRyeSA9IHNlbGYuZW5naW5lLmVudHJ5KGRhdGEsIGZ1bmN0aW9uKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgICB9KTtcblxuICAgIHNvdXJjZS5waXBlKGVudHJ5KTtcbiAgfSBlbHNlIGlmIChkYXRhLnNvdXJjZVR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgdXRpbC5jb2xsZWN0U3RyZWFtKHNvdXJjZSwgYXBwZW5kKTtcbiAgfVxufTtcblxuLyoqXG4gKiBbZmluYWxpemUgZGVzY3JpcHRpb25dXG4gKlxuICogQHJldHVybiB2b2lkXG4gKi9cblRhci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbmdpbmUuZmluYWxpemUoKTtcbn07XG5cbi8qKlxuICogW29uIGRlc2NyaXB0aW9uXVxuICpcbiAqIEByZXR1cm4gdGhpcy5lbmdpbmVcbiAqL1xuVGFyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lbmdpbmUub24uYXBwbHkodGhpcy5lbmdpbmUsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFtwaXBlIGRlc2NyaXB0aW9uXVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZGVzdGluYXRpb25cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB0aGlzLmVuZ2luZVxuICovXG5UYXIucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0aW5hdGlvbiwgb3B0aW9ucykge1xuICBpZiAodGhpcy5jb21wcmVzc29yKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5naW5lLnBpcGUuYXBwbHkodGhpcy5lbmdpbmUsIFt0aGlzLmNvbXByZXNzb3JdKS5waXBlKGRlc3RpbmF0aW9uLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5lbmdpbmUucGlwZS5hcHBseSh0aGlzLmVuZ2luZSwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBbdW5waXBlIGRlc2NyaXB0aW9uXVxuICpcbiAqIEByZXR1cm4gdGhpcy5lbmdpbmVcbiAqL1xuVGFyLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY29tcHJlc3Nvcikge1xuICAgIHJldHVybiB0aGlzLmNvbXByZXNzb3IudW5waXBlLmFwcGx5KHRoaXMuY29tcHJlc3NvciwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5lbmdpbmUudW5waXBlLmFwcGx5KHRoaXMuZW5naW5lLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhcjtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUYXJPcHRpb25zXG4gKiBAZ2xvYmFsXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnemlwPWZhbHNlXSBDb21wcmVzcyB0aGUgdGFyIGFyY2hpdmUgdXNpbmcgZ3ppcC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbZ3ppcE9wdGlvbnNdIFBhc3NlZCB0byBbemxpYl17QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS96bGliLmh0bWwjemxpYl9jbGFzc19vcHRpb25zfVxuICogdG8gY29udHJvbCBjb21wcmVzc2lvbi5cbiAqIEBwcm9wZXJ0eSB7Kn0gWypdIFNlZSBbdGFyLXN0cmVhbV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC90YXItc3RyZWFtfSBkb2N1bWVudGF0aW9uIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUYXJFbnRyeURhdGFcbiAqIEBnbG9iYWxcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lIFNldHMgdGhlIGVudHJ5IG5hbWUgaW5jbHVkaW5nIGludGVybmFsIHBhdGguXG4gKiBAcHJvcGVydHkgeyhTdHJpbmd8RGF0ZSl9IFtkYXRlPU5PVygpXSBTZXRzIHRoZSBlbnRyeSBkYXRlLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFttb2RlPUQ6MDc1NS9GOjA2NDRdIFNldHMgdGhlIGVudHJ5IHBlcm1pc3Npb25zLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IFtwcmVmaXhdIFNldHMgYSBwYXRoIHByZWZpeCBmb3IgdGhlIGVudHJ5IG5hbWUuIFVzZWZ1bFxuICogd2hlbiB3b3JraW5nIHdpdGggbWV0aG9kcyBsaWtlIGBkaXJlY3RvcnlgIG9yIGBnbG9iYC5cbiAqIEBwcm9wZXJ0eSB7ZnMuU3RhdHN9IFtzdGF0c10gU2V0cyB0aGUgZnMgc3RhdCBkYXRhIGZvciB0aGlzIGVudHJ5IGFsbG93aW5nXG4gKiBmb3IgcmVkdWN0aW9uIG9mIGZzIHN0YXQgY2FsbHMgd2hlbiBzdGF0IGRhdGEgaXMgYWxyZWFkeSBrbm93bi5cbiAqL1xuXG4vKipcbiAqIFRhclN0cmVhbSBNb2R1bGVcbiAqIEBleHRlcm5hbCBUYXJTdHJlYW1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvdGFyLXN0cmVhbX1cbiAqL1xuIl0sIm5hbWVzIjpbInpsaWIiLCJyZXF1aXJlIiwiZW5naW5lIiwidXRpbCIsIlRhciIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsImd6aXAiLCJnemlwT3B0aW9ucyIsInN1cHBvcnRzIiwiZGlyZWN0b3J5Iiwic3ltbGluayIsInBhY2siLCJjb21wcmVzc29yIiwiY3JlYXRlR3ppcCIsIm9uIiwiX29uQ29tcHJlc3NvckVycm9yIiwiYmluZCIsInByb3RvdHlwZSIsImVyciIsImVtaXQiLCJhcHBlbmQiLCJzb3VyY2UiLCJkYXRhIiwiY2FsbGJhY2siLCJzZWxmIiwibXRpbWUiLCJkYXRlIiwic291cmNlQnVmZmVyIiwiZW50cnkiLCJzb3VyY2VUeXBlIiwic3RhdHMiLCJzaXplIiwicGlwZSIsImNvbGxlY3RTdHJlYW0iLCJmaW5hbGl6ZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiZGVzdGluYXRpb24iLCJ1bnBpcGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/archiver/lib/plugins/tar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/archiver/lib/plugins/zip.js":
/*!**************************************************!*\
  !*** ./node_modules/archiver/lib/plugins/zip.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * ZIP Format Plugin\n *\n * @module plugins/zip\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */ var engine = __webpack_require__(/*! zip-stream */ \"(ssr)/./node_modules/zip-stream/index.js\");\nvar util = __webpack_require__(/*! archiver-utils */ \"(ssr)/./node_modules/archiver-utils/index.js\");\n/**\n * @constructor\n * @param {ZipOptions} [options]\n * @param {String} [options.comment] Sets the zip archive comment.\n * @param {Boolean} [options.forceLocalTime=false] Forces the archive to contain local file times instead of UTC.\n * @param {Boolean} [options.forceZip64=false] Forces the archive to contain ZIP64 headers.\n * @param {Boolean} [options.namePrependSlash=false] Prepends a forward slash to archive file paths.\n * @param {Boolean} [options.store=false] Sets the compression method to STORE.\n * @param {Object} [options.zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}\n */ var Zip = function(options) {\n    if (!(this instanceof Zip)) {\n        return new Zip(options);\n    }\n    options = this.options = util.defaults(options, {\n        comment: \"\",\n        forceUTC: false,\n        namePrependSlash: false,\n        store: false\n    });\n    this.supports = {\n        directory: true,\n        symlink: true\n    };\n    this.engine = new engine(options);\n};\n/**\n * @param  {(Buffer|Stream)} source\n * @param  {ZipEntryData} data\n * @param  {String} data.name Sets the entry name including internal path.\n * @param  {(String|Date)} [data.date=NOW()] Sets the entry date.\n * @param  {Number} [data.mode=D:0755/F:0644] Sets the entry permissions.\n * @param  {String} [data.prefix] Sets a path prefix for the entry name. Useful\n * when working with methods like `directory` or `glob`.\n * @param  {fs.Stats} [data.stats] Sets the fs stat data for this entry allowing\n * for reduction of fs stat calls when stat data is already known.\n * @param  {Boolean} [data.store=ZipOptions.store] Sets the compression method to STORE.\n * @param  {Function} callback\n * @return void\n */ Zip.prototype.append = function(source, data, callback) {\n    this.engine.entry(source, data, callback);\n};\n/**\n * @return void\n */ Zip.prototype.finalize = function() {\n    this.engine.finalize();\n};\n/**\n * @return this.engine\n */ Zip.prototype.on = function() {\n    return this.engine.on.apply(this.engine, arguments);\n};\n/**\n * @return this.engine\n */ Zip.prototype.pipe = function() {\n    return this.engine.pipe.apply(this.engine, arguments);\n};\n/**\n * @return this.engine\n */ Zip.prototype.unpipe = function() {\n    return this.engine.unpipe.apply(this.engine, arguments);\n};\nmodule.exports = Zip; /**\n * @typedef {Object} ZipOptions\n * @global\n * @property {String} [comment] Sets the zip archive comment.\n * @property {Boolean} [forceLocalTime=false] Forces the archive to contain local file times instead of UTC.\n * @property {Boolean} [forceZip64=false] Forces the archive to contain ZIP64 headers.\n * @prpperty {Boolean} [namePrependSlash=false] Prepends a forward slash to archive file paths.\n * @property {Boolean} [store=false] Sets the compression method to STORE.\n * @property {Object} [zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}\n * to control compression.\n * @property {*} [*] See [zip-stream]{@link https://archiverjs.com/zip-stream/ZipStream.html} documentation for current list of properties.\n */  /**\n * @typedef {Object} ZipEntryData\n * @global\n * @property {String} name Sets the entry name including internal path.\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\n * @property {Boolean} [namePrependSlash=ZipOptions.namePrependSlash] Prepends a forward slash to archive file paths.\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\n * when working with methods like `directory` or `glob`.\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\n * for reduction of fs stat calls when stat data is already known.\n * @property {Boolean} [store=ZipOptions.store] Sets the compression method to STORE.\n */  /**\n * ZipStream Module\n * @external ZipStream\n * @see {@link https://www.archiverjs.com/zip-stream/ZipStream.html}\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJjaGl2ZXIvbGliL3BsdWdpbnMvemlwLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQyxHQUNELElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBRW5COzs7Ozs7Ozs7Q0FTQyxHQUNELElBQUlFLE1BQU0sU0FBU0MsT0FBTztJQUN4QixJQUFJLENBQUUsS0FBSSxZQUFZRCxHQUFFLEdBQUk7UUFDMUIsT0FBTyxJQUFJQSxJQUFJQztJQUNqQjtJQUVBQSxVQUFVLElBQUksQ0FBQ0EsT0FBTyxHQUFHRixLQUFLRyxRQUFRLENBQUNELFNBQVM7UUFDOUNFLFNBQVM7UUFDVEMsVUFBVTtRQUNWQyxrQkFBa0I7UUFDbEJDLE9BQU87SUFDVDtJQUVBLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2RDLFdBQVc7UUFDWEMsU0FBUztJQUNYO0lBRUEsSUFBSSxDQUFDWixNQUFNLEdBQUcsSUFBSUEsT0FBT0k7QUFDM0I7QUFFQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0RELElBQUlVLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQ3BELElBQUksQ0FBQ2pCLE1BQU0sQ0FBQ2tCLEtBQUssQ0FBQ0gsUUFBUUMsTUFBTUM7QUFDbEM7QUFFQTs7Q0FFQyxHQUNEZCxJQUFJVSxTQUFTLENBQUNNLFFBQVEsR0FBRztJQUN2QixJQUFJLENBQUNuQixNQUFNLENBQUNtQixRQUFRO0FBQ3RCO0FBRUE7O0NBRUMsR0FDRGhCLElBQUlVLFNBQVMsQ0FBQ08sRUFBRSxHQUFHO0lBQ2pCLE9BQU8sSUFBSSxDQUFDcEIsTUFBTSxDQUFDb0IsRUFBRSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDckIsTUFBTSxFQUFFc0I7QUFDM0M7QUFFQTs7Q0FFQyxHQUNEbkIsSUFBSVUsU0FBUyxDQUFDVSxJQUFJLEdBQUc7SUFDbkIsT0FBTyxJQUFJLENBQUN2QixNQUFNLENBQUN1QixJQUFJLENBQUNGLEtBQUssQ0FBQyxJQUFJLENBQUNyQixNQUFNLEVBQUVzQjtBQUM3QztBQUVBOztDQUVDLEdBQ0RuQixJQUFJVSxTQUFTLENBQUNXLE1BQU0sR0FBRztJQUNyQixPQUFPLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ3dCLE1BQU0sQ0FBQ0gsS0FBSyxDQUFDLElBQUksQ0FBQ3JCLE1BQU0sRUFBRXNCO0FBQy9DO0FBRUFHLE9BQU9DLE9BQU8sR0FBR3ZCLEtBRWpCOzs7Ozs7Ozs7OztDQVdDLElBRUQ7Ozs7Ozs7Ozs7OztDQVlDLElBRUQ7Ozs7Q0FJQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NkLXRpbWVzaGVldC1hbmFseXplci8uL25vZGVfbW9kdWxlcy9hcmNoaXZlci9saWIvcGx1Z2lucy96aXAuanM/M2QyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFpJUCBGb3JtYXQgUGx1Z2luXG4gKlxuICogQG1vZHVsZSBwbHVnaW5zL3ppcFxuICogQGxpY2Vuc2UgW01JVF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS1hcmNoaXZlci9ibG9iL21hc3Rlci9MSUNFTlNFfVxuICogQGNvcHlyaWdodCAoYykgMjAxMi0yMDE0IENocmlzIFRhbGtpbmd0b24sIGNvbnRyaWJ1dG9ycy5cbiAqL1xudmFyIGVuZ2luZSA9IHJlcXVpcmUoJ3ppcC1zdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnYXJjaGl2ZXItdXRpbHMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7WmlwT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29tbWVudF0gU2V0cyB0aGUgemlwIGFyY2hpdmUgY29tbWVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9yY2VMb2NhbFRpbWU9ZmFsc2VdIEZvcmNlcyB0aGUgYXJjaGl2ZSB0byBjb250YWluIGxvY2FsIGZpbGUgdGltZXMgaW5zdGVhZCBvZiBVVEMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvcmNlWmlwNjQ9ZmFsc2VdIEZvcmNlcyB0aGUgYXJjaGl2ZSB0byBjb250YWluIFpJUDY0IGhlYWRlcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5hbWVQcmVwZW5kU2xhc2g9ZmFsc2VdIFByZXBlbmRzIGEgZm9yd2FyZCBzbGFzaCB0byBhcmNoaXZlIGZpbGUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3JlPWZhbHNlXSBTZXRzIHRoZSBjb21wcmVzc2lvbiBtZXRob2QgdG8gU1RPUkUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYl0gUGFzc2VkIHRvIFt6bGliXXtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3psaWIuaHRtbCN6bGliX2NsYXNzX29wdGlvbnN9XG4gKi9cbnZhciBaaXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBaaXApKSB7XG4gICAgcmV0dXJuIG5ldyBaaXAob3B0aW9ucyk7XG4gIH1cblxuICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gdXRpbC5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgY29tbWVudDogJycsXG4gICAgZm9yY2VVVEM6IGZhbHNlLFxuICAgIG5hbWVQcmVwZW5kU2xhc2g6IGZhbHNlLFxuICAgIHN0b3JlOiBmYWxzZVxuICB9KTtcblxuICB0aGlzLnN1cHBvcnRzID0ge1xuICAgIGRpcmVjdG9yeTogdHJ1ZSxcbiAgICBzeW1saW5rOiB0cnVlXG4gIH07XG5cbiAgdGhpcy5lbmdpbmUgPSBuZXcgZW5naW5lKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHsoQnVmZmVyfFN0cmVhbSl9IHNvdXJjZVxuICogQHBhcmFtICB7WmlwRW50cnlEYXRhfSBkYXRhXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEubmFtZSBTZXRzIHRoZSBlbnRyeSBuYW1lIGluY2x1ZGluZyBpbnRlcm5hbCBwYXRoLlxuICogQHBhcmFtICB7KFN0cmluZ3xEYXRlKX0gW2RhdGEuZGF0ZT1OT1coKV0gU2V0cyB0aGUgZW50cnkgZGF0ZS5cbiAqIEBwYXJhbSAge051bWJlcn0gW2RhdGEubW9kZT1EOjA3NTUvRjowNjQ0XSBTZXRzIHRoZSBlbnRyeSBwZXJtaXNzaW9ucy5cbiAqIEBwYXJhbSAge1N0cmluZ30gW2RhdGEucHJlZml4XSBTZXRzIGEgcGF0aCBwcmVmaXggZm9yIHRoZSBlbnRyeSBuYW1lLiBVc2VmdWxcbiAqIHdoZW4gd29ya2luZyB3aXRoIG1ldGhvZHMgbGlrZSBgZGlyZWN0b3J5YCBvciBgZ2xvYmAuXG4gKiBAcGFyYW0gIHtmcy5TdGF0c30gW2RhdGEuc3RhdHNdIFNldHMgdGhlIGZzIHN0YXQgZGF0YSBmb3IgdGhpcyBlbnRyeSBhbGxvd2luZ1xuICogZm9yIHJlZHVjdGlvbiBvZiBmcyBzdGF0IGNhbGxzIHdoZW4gc3RhdCBkYXRhIGlzIGFscmVhZHkga25vd24uXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZGF0YS5zdG9yZT1aaXBPcHRpb25zLnN0b3JlXSBTZXRzIHRoZSBjb21wcmVzc2lvbiBtZXRob2QgdG8gU1RPUkUuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4gdm9pZFxuICovXG5aaXAucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHNvdXJjZSwgZGF0YSwgY2FsbGJhY2spIHtcbiAgdGhpcy5lbmdpbmUuZW50cnkoc291cmNlLCBkYXRhLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4gdm9pZFxuICovXG5aaXAucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW5naW5lLmZpbmFsaXplKCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4gdGhpcy5lbmdpbmVcbiAqL1xuWmlwLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lbmdpbmUub24uYXBwbHkodGhpcy5lbmdpbmUsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4gdGhpcy5lbmdpbmVcbiAqL1xuWmlwLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVuZ2luZS5waXBlLmFwcGx5KHRoaXMuZW5naW5lLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHRoaXMuZW5naW5lXG4gKi9cblppcC5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVuZ2luZS51bnBpcGUuYXBwbHkodGhpcy5lbmdpbmUsIGFyZ3VtZW50cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFppcDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBaaXBPcHRpb25zXG4gKiBAZ2xvYmFsXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW2NvbW1lbnRdIFNldHMgdGhlIHppcCBhcmNoaXZlIGNvbW1lbnQuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtmb3JjZUxvY2FsVGltZT1mYWxzZV0gRm9yY2VzIHRoZSBhcmNoaXZlIHRvIGNvbnRhaW4gbG9jYWwgZmlsZSB0aW1lcyBpbnN0ZWFkIG9mIFVUQy5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvcmNlWmlwNjQ9ZmFsc2VdIEZvcmNlcyB0aGUgYXJjaGl2ZSB0byBjb250YWluIFpJUDY0IGhlYWRlcnMuXG4gKiBAcHJwcGVydHkge0Jvb2xlYW59IFtuYW1lUHJlcGVuZFNsYXNoPWZhbHNlXSBQcmVwZW5kcyBhIGZvcndhcmQgc2xhc2ggdG8gYXJjaGl2ZSBmaWxlIHBhdGhzLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbc3RvcmU9ZmFsc2VdIFNldHMgdGhlIGNvbXByZXNzaW9uIG1ldGhvZCB0byBTVE9SRS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbemxpYl0gUGFzc2VkIHRvIFt6bGliXXtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3psaWIuaHRtbCN6bGliX2NsYXNzX29wdGlvbnN9XG4gKiB0byBjb250cm9sIGNvbXByZXNzaW9uLlxuICogQHByb3BlcnR5IHsqfSBbKl0gU2VlIFt6aXAtc3RyZWFtXXtAbGluayBodHRwczovL2FyY2hpdmVyanMuY29tL3ppcC1zdHJlYW0vWmlwU3RyZWFtLmh0bWx9IGRvY3VtZW50YXRpb24gZm9yIGN1cnJlbnQgbGlzdCBvZiBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWmlwRW50cnlEYXRhXG4gKiBAZ2xvYmFsXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbmFtZSBTZXRzIHRoZSBlbnRyeSBuYW1lIGluY2x1ZGluZyBpbnRlcm5hbCBwYXRoLlxuICogQHByb3BlcnR5IHsoU3RyaW5nfERhdGUpfSBbZGF0ZT1OT1coKV0gU2V0cyB0aGUgZW50cnkgZGF0ZS5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbW9kZT1EOjA3NTUvRjowNjQ0XSBTZXRzIHRoZSBlbnRyeSBwZXJtaXNzaW9ucy5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW25hbWVQcmVwZW5kU2xhc2g9WmlwT3B0aW9ucy5uYW1lUHJlcGVuZFNsYXNoXSBQcmVwZW5kcyBhIGZvcndhcmQgc2xhc2ggdG8gYXJjaGl2ZSBmaWxlIHBhdGhzLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IFtwcmVmaXhdIFNldHMgYSBwYXRoIHByZWZpeCBmb3IgdGhlIGVudHJ5IG5hbWUuIFVzZWZ1bFxuICogd2hlbiB3b3JraW5nIHdpdGggbWV0aG9kcyBsaWtlIGBkaXJlY3RvcnlgIG9yIGBnbG9iYC5cbiAqIEBwcm9wZXJ0eSB7ZnMuU3RhdHN9IFtzdGF0c10gU2V0cyB0aGUgZnMgc3RhdCBkYXRhIGZvciB0aGlzIGVudHJ5IGFsbG93aW5nXG4gKiBmb3IgcmVkdWN0aW9uIG9mIGZzIHN0YXQgY2FsbHMgd2hlbiBzdGF0IGRhdGEgaXMgYWxyZWFkeSBrbm93bi5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N0b3JlPVppcE9wdGlvbnMuc3RvcmVdIFNldHMgdGhlIGNvbXByZXNzaW9uIG1ldGhvZCB0byBTVE9SRS5cbiAqL1xuXG4vKipcbiAqIFppcFN0cmVhbSBNb2R1bGVcbiAqIEBleHRlcm5hbCBaaXBTdHJlYW1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFyY2hpdmVyanMuY29tL3ppcC1zdHJlYW0vWmlwU3RyZWFtLmh0bWx9XG4gKi9cbiJdLCJuYW1lcyI6WyJlbmdpbmUiLCJyZXF1aXJlIiwidXRpbCIsIlppcCIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsImNvbW1lbnQiLCJmb3JjZVVUQyIsIm5hbWVQcmVwZW5kU2xhc2giLCJzdG9yZSIsInN1cHBvcnRzIiwiZGlyZWN0b3J5Iiwic3ltbGluayIsInByb3RvdHlwZSIsImFwcGVuZCIsInNvdXJjZSIsImRhdGEiLCJjYWxsYmFjayIsImVudHJ5IiwiZmluYWxpemUiLCJvbiIsImFwcGx5IiwiYXJndW1lbnRzIiwicGlwZSIsInVucGlwZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/archiver/lib/plugins/zip.js\n");

/***/ })

};
;