/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minimatch";
exports.ids = ["vendor-chunks/minimatch"];
exports.modules = {

/***/ "(ssr)/./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = minimatch;\nminimatch.Minimatch = Minimatch;\nvar path = function() {\n    try {\n        return __webpack_require__(/*! path */ \"path\");\n    } catch (e) {}\n}() || {\n    sep: \"/\"\n};\nminimatch.sep = path.sep;\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\nvar expand = __webpack_require__(/*! brace-expansion */ \"(ssr)/./node_modules/brace-expansion/index.js\");\nvar plTypes = {\n    \"!\": {\n        open: \"(?:(?!(?:\",\n        close: \"))[^/]*?)\"\n    },\n    \"?\": {\n        open: \"(?:\",\n        close: \")?\"\n    },\n    \"+\": {\n        open: \"(?:\",\n        close: \")+\"\n    },\n    \"*\": {\n        open: \"(?:\",\n        close: \")*\"\n    },\n    \"@\": {\n        open: \"(?:\",\n        close: \")\"\n    }\n};\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = \"[^/]\";\n// * => any number of characters\nvar star = qmark + \"*?\";\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet(\"().*{}+?[]^$\\\\!\");\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet(s) {\n    return s.split(\"\").reduce(function(set, c) {\n        set[c] = true;\n        return set;\n    }, {});\n}\n// normalizes slashes.\nvar slashSplit = /\\/+/;\nminimatch.filter = filter;\nfunction filter(pattern, options) {\n    options = options || {};\n    return function(p, i, list) {\n        return minimatch(p, pattern, options);\n    };\n}\nfunction ext(a, b) {\n    b = b || {};\n    var t = {};\n    Object.keys(a).forEach(function(k) {\n        t[k] = a[k];\n    });\n    Object.keys(b).forEach(function(k) {\n        t[k] = b[k];\n    });\n    return t;\n}\nminimatch.defaults = function(def) {\n    if (!def || typeof def !== \"object\" || !Object.keys(def).length) {\n        return minimatch;\n    }\n    var orig = minimatch;\n    var m = function minimatch(p, pattern, options) {\n        return orig(p, pattern, ext(def, options));\n    };\n    m.Minimatch = function Minimatch(pattern, options) {\n        return new orig.Minimatch(pattern, ext(def, options));\n    };\n    m.Minimatch.defaults = function defaults(options) {\n        return orig.defaults(ext(def, options)).Minimatch;\n    };\n    m.filter = function filter(pattern, options) {\n        return orig.filter(pattern, ext(def, options));\n    };\n    m.defaults = function defaults(options) {\n        return orig.defaults(ext(def, options));\n    };\n    m.makeRe = function makeRe(pattern, options) {\n        return orig.makeRe(pattern, ext(def, options));\n    };\n    m.braceExpand = function braceExpand(pattern, options) {\n        return orig.braceExpand(pattern, ext(def, options));\n    };\n    m.match = function(list, pattern, options) {\n        return orig.match(list, pattern, ext(def, options));\n    };\n    return m;\n};\nMinimatch.defaults = function(def) {\n    return minimatch.defaults(def).Minimatch;\n};\nfunction minimatch(p, pattern, options) {\n    assertValidPattern(pattern);\n    if (!options) options = {};\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n}\nfunction Minimatch(pattern, options) {\n    if (!(this instanceof Minimatch)) {\n        return new Minimatch(pattern, options);\n    }\n    assertValidPattern(pattern);\n    if (!options) options = {};\n    pattern = pattern.trim();\n    // windows support: need to use /, not \\\n    if (!options.allowWindowsEscape && path.sep !== \"/\") {\n        pattern = pattern.split(path.sep).join(\"/\");\n    }\n    this.options = options;\n    this.set = [];\n    this.pattern = pattern;\n    this.regexp = null;\n    this.negate = false;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial;\n    // make the set of regexps etc.\n    this.make();\n}\nMinimatch.prototype.debug = function() {};\nMinimatch.prototype.make = make;\nfunction make() {\n    var pattern = this.pattern;\n    var options = this.options;\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        this.comment = true;\n        return;\n    }\n    if (!pattern) {\n        this.empty = true;\n        return;\n    }\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n    // step 2: expand braces\n    var set = this.globSet = this.braceExpand();\n    if (options.debug) this.debug = function debug() {\n        console.error.apply(console, arguments);\n    };\n    this.debug(this.pattern, set);\n    // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    set = this.globParts = set.map(function(s) {\n        return s.split(slashSplit);\n    });\n    this.debug(this.pattern, set);\n    // glob --> regexps\n    set = set.map(function(s, si, set) {\n        return s.map(this.parse, this);\n    }, this);\n    this.debug(this.pattern, set);\n    // filter out everything that didn't compile properly.\n    set = set.filter(function(s) {\n        return s.indexOf(false) === -1;\n    });\n    this.debug(this.pattern, set);\n    this.set = set;\n}\nMinimatch.prototype.parseNegate = parseNegate;\nfunction parseNegate() {\n    var pattern = this.pattern;\n    var negate = false;\n    var options = this.options;\n    var negateOffset = 0;\n    if (options.nonegate) return;\n    for(var i = 0, l = pattern.length; i < l && pattern.charAt(i) === \"!\"; i++){\n        negate = !negate;\n        negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.substr(negateOffset);\n    this.negate = negate;\n}\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function(pattern, options) {\n    return braceExpand(pattern, options);\n};\nMinimatch.prototype.braceExpand = braceExpand;\nfunction braceExpand(pattern, options) {\n    if (!options) {\n        if (this instanceof Minimatch) {\n            options = this.options;\n        } else {\n            options = {};\n        }\n    }\n    pattern = typeof pattern === \"undefined\" ? this.pattern : pattern;\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [\n            pattern\n        ];\n    }\n    return expand(pattern);\n}\nvar MAX_PATTERN_LENGTH = 1024 * 64;\nvar assertValidPattern = function(pattern) {\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"invalid pattern\");\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError(\"pattern is too long\");\n    }\n};\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse;\nvar SUBPARSE = {};\nfunction parse(pattern, isSub) {\n    assertValidPattern(pattern);\n    var options = this.options;\n    // shortcuts\n    if (pattern === \"**\") {\n        if (!options.noglobstar) return GLOBSTAR;\n        else pattern = \"*\";\n    }\n    if (pattern === \"\") return \"\";\n    var re = \"\";\n    var hasMagic = !!options.nocase;\n    var escaping = false;\n    // ? => one single character\n    var patternListStack = [];\n    var negativeLists = [];\n    var stateChar;\n    var inClass = false;\n    var reClassStart = -1;\n    var classStart = -1;\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n    var patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n     : options.dot ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n    var self = this;\n    function clearStateChar() {\n        if (stateChar) {\n            // we had some state-tracking character\n            // that wasn't consumed by this pass.\n            switch(stateChar){\n                case \"*\":\n                    re += star;\n                    hasMagic = true;\n                    break;\n                case \"?\":\n                    re += qmark;\n                    hasMagic = true;\n                    break;\n                default:\n                    re += \"\\\\\" + stateChar;\n                    break;\n            }\n            self.debug(\"clearStateChar %j %j\", stateChar, re);\n            stateChar = false;\n        }\n    }\n    for(var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++){\n        this.debug(\"%s\t%s %s %j\", pattern, i, re, c);\n        // skip over any that are escaped.\n        if (escaping && reSpecials[c]) {\n            re += \"\\\\\" + c;\n            escaping = false;\n            continue;\n        }\n        switch(c){\n            /* istanbul ignore next */ case \"/\":\n                {\n                    // completely not allowed, even escaped.\n                    // Should already be path-split by now.\n                    return false;\n                }\n            case \"\\\\\":\n                clearStateChar();\n                escaping = true;\n                continue;\n            // the various stateChar values\n            // for the \"extglob\" stuff.\n            case \"?\":\n            case \"*\":\n            case \"+\":\n            case \"@\":\n            case \"!\":\n                this.debug(\"%s\t%s %s %j <-- stateChar\", pattern, i, re, c);\n                // all of those are literals inside a class, except that\n                // the glob [!a] means [^a] in regexp\n                if (inClass) {\n                    this.debug(\"  in class\");\n                    if (c === \"!\" && i === classStart + 1) c = \"^\";\n                    re += c;\n                    continue;\n                }\n                // if we already have a stateChar, then it means\n                // that there was something like ** or +? in there.\n                // Handle the stateChar, then proceed with this one.\n                self.debug(\"call clearStateChar %j\", stateChar);\n                clearStateChar();\n                stateChar = c;\n                // if extglob is disabled, then +(asdf|foo) isn't a thing.\n                // just clear the statechar *now*, rather than even diving into\n                // the patternList stuff.\n                if (options.noext) clearStateChar();\n                continue;\n            case \"(\":\n                if (inClass) {\n                    re += \"(\";\n                    continue;\n                }\n                if (!stateChar) {\n                    re += \"\\\\(\";\n                    continue;\n                }\n                patternListStack.push({\n                    type: stateChar,\n                    start: i - 1,\n                    reStart: re.length,\n                    open: plTypes[stateChar].open,\n                    close: plTypes[stateChar].close\n                });\n                // negation is (?:(?!js)[^/]*)\n                re += stateChar === \"!\" ? \"(?:(?!(?:\" : \"(?:\";\n                this.debug(\"plType %j %j\", stateChar, re);\n                stateChar = false;\n                continue;\n            case \")\":\n                if (inClass || !patternListStack.length) {\n                    re += \"\\\\)\";\n                    continue;\n                }\n                clearStateChar();\n                hasMagic = true;\n                var pl = patternListStack.pop();\n                // negation is (?:(?!js)[^/]*)\n                // The others are (?:<pattern>)<type>\n                re += pl.close;\n                if (pl.type === \"!\") {\n                    negativeLists.push(pl);\n                }\n                pl.reEnd = re.length;\n                continue;\n            case \"|\":\n                if (inClass || !patternListStack.length || escaping) {\n                    re += \"\\\\|\";\n                    escaping = false;\n                    continue;\n                }\n                clearStateChar();\n                re += \"|\";\n                continue;\n            // these are mostly the same in regexp and glob\n            case \"[\":\n                // swallow any state-tracking char before the [\n                clearStateChar();\n                if (inClass) {\n                    re += \"\\\\\" + c;\n                    continue;\n                }\n                inClass = true;\n                classStart = i;\n                reClassStart = re.length;\n                re += c;\n                continue;\n            case \"]\":\n                //  a right bracket shall lose its special\n                //  meaning and represent itself in\n                //  a bracket expression if it occurs\n                //  first in the list.  -- POSIX.2 2.8.3.2\n                if (i === classStart + 1 || !inClass) {\n                    re += \"\\\\\" + c;\n                    escaping = false;\n                    continue;\n                }\n                // handle the case where we left a class open.\n                // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n                // split where the last [ was, make sure we don't have\n                // an invalid re. if so, re-walk the contents of the\n                // would-be class to re-translate any characters that\n                // were passed through as-is\n                // TODO: It would probably be faster to determine this\n                // without a try/catch and a new RegExp, but it's tricky\n                // to do safely.  For now, this is safe and works.\n                var cs = pattern.substring(classStart + 1, i);\n                try {\n                    RegExp(\"[\" + cs + \"]\");\n                } catch (er) {\n                    // not a valid class!\n                    var sp = this.parse(cs, SUBPARSE);\n                    re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0] + \"\\\\]\";\n                    hasMagic = hasMagic || sp[1];\n                    inClass = false;\n                    continue;\n                }\n                // finish up the class.\n                hasMagic = true;\n                inClass = false;\n                re += c;\n                continue;\n            default:\n                // swallow any state char that wasn't consumed\n                clearStateChar();\n                if (escaping) {\n                    // no need\n                    escaping = false;\n                } else if (reSpecials[c] && !(c === \"^\" && inClass)) {\n                    re += \"\\\\\";\n                }\n                re += c;\n        } // switch\n    } // for\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n        // split where the last [ was, and escape it\n        // this is a huge pita.  We now have to re-walk\n        // the contents of the would-be class to re-translate\n        // any characters that were passed through as-is\n        cs = pattern.substr(classStart + 1);\n        sp = this.parse(cs, SUBPARSE);\n        re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0];\n        hasMagic = hasMagic || sp[1];\n    }\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){\n        var tail = re.slice(pl.reStart + pl.open.length);\n        this.debug(\"setting tail\", re, pl);\n        // maybe some even number of \\, then maybe 1 \\, followed by a |\n        tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function(_, $1, $2) {\n            if (!$2) {\n                // the | isn't already escaped, so escape it.\n                $2 = \"\\\\\";\n            }\n            // need to escape all those slashes *again*, without escaping the\n            // one that we need for escaping the | character.  As it works out,\n            // escaping an even number of slashes can be done by simply repeating\n            // it exactly after itself.  That's why this trick works.\n            //\n            // I am sorry that you have to see this.\n            return $1 + $1 + $2 + \"|\";\n        });\n        this.debug(\"tail=%j\\n   %s\", tail, tail, pl, re);\n        var t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;\n        hasMagic = true;\n        re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;\n    }\n    // handle trailing things that only matter at the very end.\n    clearStateChar();\n    if (escaping) {\n        // trailing \\\\\n        re += \"\\\\\\\\\";\n    }\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    var addPatternStart = false;\n    switch(re.charAt(0)){\n        case \"[\":\n        case \".\":\n        case \"(\":\n            addPatternStart = true;\n    }\n    // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n    for(var n = negativeLists.length - 1; n > -1; n--){\n        var nl = negativeLists[n];\n        var nlBefore = re.slice(0, nl.reStart);\n        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n        var nlAfter = re.slice(nl.reEnd);\n        nlLast += nlAfter;\n        // Handle nested stuff like *(*.js|!(*.json)), where open parens\n        // mean that we should *not* include the ) in the bit that is considered\n        // \"after\" the negated section.\n        var openParensBefore = nlBefore.split(\"(\").length - 1;\n        var cleanAfter = nlAfter;\n        for(i = 0; i < openParensBefore; i++){\n            cleanAfter = cleanAfter.replace(/\\)[+*?]?/, \"\");\n        }\n        nlAfter = cleanAfter;\n        var dollar = \"\";\n        if (nlAfter === \"\" && isSub !== SUBPARSE) {\n            dollar = \"$\";\n        }\n        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n        re = newRe;\n    }\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== \"\" && hasMagic) {\n        re = \"(?=.)\" + re;\n    }\n    if (addPatternStart) {\n        re = patternStart + re;\n    }\n    // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n        return [\n            re,\n            hasMagic\n        ];\n    }\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n        return globUnescape(pattern);\n    }\n    var flags = options.nocase ? \"i\" : \"\";\n    try {\n        var regExp = new RegExp(\"^\" + re + \"$\", flags);\n    } catch (er) /* istanbul ignore next - should be impossible */ {\n        // If it was an invalid regular expression, then it can't match\n        // anything.  This trick looks for a character after the end of\n        // the string, which is of course impossible, except in multi-line\n        // mode, but it's not a /m regex.\n        return new RegExp(\"$.\");\n    }\n    regExp._glob = pattern;\n    regExp._src = re;\n    return regExp;\n}\nminimatch.makeRe = function(pattern, options) {\n    return new Minimatch(pattern, options || {}).makeRe();\n};\nMinimatch.prototype.makeRe = makeRe;\nfunction makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    var set = this.set;\n    if (!set.length) {\n        this.regexp = false;\n        return this.regexp;\n    }\n    var options = this.options;\n    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    var flags = options.nocase ? \"i\" : \"\";\n    var re = set.map(function(pattern) {\n        return pattern.map(function(p) {\n            return p === GLOBSTAR ? twoStar : typeof p === \"string\" ? regExpEscape(p) : p._src;\n        }).join(\"\\\\/\");\n    }).join(\"|\");\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = \"^(?:\" + re + \")$\";\n    // can match anything, as long as it's not this.\n    if (this.negate) re = \"^(?!\" + re + \").*$\";\n    try {\n        this.regexp = new RegExp(re, flags);\n    } catch (ex) /* istanbul ignore next - should be impossible */ {\n        this.regexp = false;\n    }\n    return this.regexp;\n}\nminimatch.match = function(list, pattern, options) {\n    options = options || {};\n    var mm = new Minimatch(pattern, options);\n    list = list.filter(function(f) {\n        return mm.match(f);\n    });\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nMinimatch.prototype.match = function match(f, partial) {\n    if (typeof partial === \"undefined\") partial = this.partial;\n    this.debug(\"match\", f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false;\n    if (this.empty) return f === \"\";\n    if (f === \"/\" && partial) return true;\n    var options = this.options;\n    // windows: need to use /, not \\\n    if (path.sep !== \"/\") {\n        f = f.split(path.sep).join(\"/\");\n    }\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit);\n    this.debug(this.pattern, \"split\", f);\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n    var set = this.set;\n    this.debug(this.pattern, \"set\", set);\n    // Find the basename of the path by looking for the last non-empty segment\n    var filename;\n    var i;\n    for(i = f.length - 1; i >= 0; i--){\n        filename = f[i];\n        if (filename) break;\n    }\n    for(i = 0; i < set.length; i++){\n        var pattern = set[i];\n        var file = f;\n        if (options.matchBase && pattern.length === 1) {\n            file = [\n                filename\n            ];\n        }\n        var hit = this.matchOne(file, pattern, partial);\n        if (hit) {\n            if (options.flipNegate) return true;\n            return !this.negate;\n        }\n    }\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false;\n    return this.negate;\n};\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function(file, pattern, partial) {\n    var options = this.options;\n    this.debug(\"matchOne\", {\n        \"this\": this,\n        file: file,\n        pattern: pattern\n    });\n    this.debug(\"matchOne\", file.length, pattern.length);\n    for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n        this.debug(\"matchOne loop\");\n        var p = pattern[pi];\n        var f = file[fi];\n        this.debug(pattern, p, f);\n        // should be impossible.\n        // some invalid regexp stuff in the set.\n        /* istanbul ignore if */ if (p === false) return false;\n        if (p === GLOBSTAR) {\n            this.debug(\"GLOBSTAR\", [\n                pattern,\n                p,\n                f\n            ]);\n            // \"**\"\n            // a/**/b/**/c would match the following:\n            // a/b/x/y/z/c\n            // a/x/y/z/b/c\n            // a/b/x/b/x/c\n            // a/b/c\n            // To do this, take the rest of the pattern after\n            // the **, and see if it would match the file remainder.\n            // If so, return success.\n            // If not, the ** \"swallows\" a segment, and try again.\n            // This is recursively awful.\n            //\n            // a/**/b/**/c matching a/b/x/y/z/c\n            // - a matches a\n            // - doublestar\n            //   - matchOne(b/x/y/z/c, b/**/c)\n            //     - b matches b\n            //     - doublestar\n            //       - matchOne(x/y/z/c, c) -> no\n            //       - matchOne(y/z/c, c) -> no\n            //       - matchOne(z/c, c) -> no\n            //       - matchOne(c, c) yes, hit\n            var fr = fi;\n            var pr = pi + 1;\n            if (pr === pl) {\n                this.debug(\"** at the end\");\n                // a ** at the end will just swallow the rest.\n                // We have found a match.\n                // however, it will not swallow /.x, unless\n                // options.dot is set.\n                // . and .. are *never* matched by **, for explosively\n                // exponential reasons.\n                for(; fi < fl; fi++){\n                    if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                }\n                return true;\n            }\n            // ok, let's see if we can swallow whatever we can.\n            while(fr < fl){\n                var swallowee = file[fr];\n                this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                // XXX remove this slice.  Just pass the start index.\n                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                    this.debug(\"globstar found match!\", fr, fl, swallowee);\n                    // found a match.\n                    return true;\n                } else {\n                    // can't swallow \".\" or \"..\" ever.\n                    // can only swallow \".foo\" when explicitly asked.\n                    if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                        this.debug(\"dot detected!\", file, fr, pattern, pr);\n                        break;\n                    }\n                    // ** swallows a segment, and continue.\n                    this.debug(\"globstar swallow a segment, and continue\");\n                    fr++;\n                }\n            }\n            // no match was found.\n            // However, in partial mode, we can't say this is necessarily over.\n            // If there's more *pattern* left, then\n            /* istanbul ignore if */ if (partial) {\n                // ran out of file\n                this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                if (fr === fl) return true;\n            }\n            return false;\n        }\n        // something other than **\n        // non-magic patterns just have to match exactly\n        // patterns with magic have been turned into regexps.\n        var hit;\n        if (typeof p === \"string\") {\n            hit = f === p;\n            this.debug(\"string match\", p, f, hit);\n        } else {\n            hit = f.match(p);\n            this.debug(\"pattern match\", p, f, hit);\n        }\n        if (!hit) return false;\n    }\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n        // ran out of pattern and filename at the same time.\n        // an exact hit!\n        return true;\n    } else if (fi === fl) {\n        // ran out of file, but still had pattern left.\n        // this is ok if we're doing the match as part of\n        // a glob fs traversal.\n        return partial;\n    } else /* istanbul ignore else */ if (pi === pl) {\n        // ran out of pattern, still have file left.\n        // this is only acceptable if we're on the very last\n        // empty segment of a file with a trailing slash.\n        // a/* should match a/b/\n        return fi === fl - 1 && file[fi] === \"\";\n    }\n    // should be unreachable.\n    /* istanbul ignore next */ throw new Error(\"wtf?\");\n};\n// replace stuff like \\* with *\nfunction globUnescape(s) {\n    return s.replace(/\\\\(.)/g, \"$1\");\n}\nfunction regExpEscape(s) {\n    return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHQztBQUNqQkEsVUFBVUMsU0FBUyxHQUFHQTtBQUV0QixJQUFJQyxPQUFPO0lBQWUsSUFBSTtRQUFFLE9BQU9DLG1CQUFPQSxDQUFDO0lBQVEsRUFBRSxPQUFPQyxHQUFHLENBQUM7QUFBQyxPQUFRO0lBQzNFQyxLQUFLO0FBQ1A7QUFDQUwsVUFBVUssR0FBRyxHQUFHSCxLQUFLRyxHQUFHO0FBRXhCLElBQUlDLFdBQVdOLFVBQVVNLFFBQVEsR0FBR0wsVUFBVUssUUFBUSxHQUFHLENBQUM7QUFDMUQsSUFBSUMsU0FBU0osbUJBQU9BLENBQUM7QUFFckIsSUFBSUssVUFBVTtJQUNaLEtBQUs7UUFBRUMsTUFBTTtRQUFhQyxPQUFPO0lBQVc7SUFDNUMsS0FBSztRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBSztJQUNoQyxLQUFLO1FBQUVELE1BQU07UUFBT0MsT0FBTztJQUFLO0lBQ2hDLEtBQUs7UUFBRUQsTUFBTTtRQUFPQyxPQUFPO0lBQUs7SUFDaEMsS0FBSztRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBSTtBQUNqQztBQUVBLGdDQUFnQztBQUNoQyxpREFBaUQ7QUFDakQsSUFBSUMsUUFBUTtBQUVaLGdDQUFnQztBQUNoQyxJQUFJQyxPQUFPRCxRQUFRO0FBRW5CLDREQUE0RDtBQUM1RCwrREFBK0Q7QUFDL0QsNkNBQTZDO0FBQzdDLElBQUlFLGFBQWE7QUFFakIsa0NBQWtDO0FBQ2xDLDZDQUE2QztBQUM3QyxJQUFJQyxlQUFlO0FBRW5CLGdEQUFnRDtBQUNoRCxJQUFJQyxhQUFhQyxRQUFRO0FBRXpCLHNDQUFzQztBQUN0QyxTQUFTQSxRQUFTQyxDQUFDO0lBQ2pCLE9BQU9BLEVBQUVDLEtBQUssQ0FBQyxJQUFJQyxNQUFNLENBQUMsU0FBVUMsR0FBRyxFQUFFQyxDQUFDO1FBQ3hDRCxHQUFHLENBQUNDLEVBQUUsR0FB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QW9EO0lBQ3BELHlEQUF5RDtJQUN6RCw2QkFBNkI7SUFDN0IseUNBQXlDO0lBRXpDLGdFQUFnRTtJQUNoRSxJQUFJRyxPQUFPRSxNQUFNRCxPQUFPM0MsSUFBSTtRQUMxQixvREFBb0Q7UUFDcEQsZ0JBQWdCO1FBQ2hCLE9BQU87SUFDVCxPQUFPLElBQUkwQyxPQUFPRSxJQUFJO1FBQ3BCLCtDQUErQztRQUMvQyxpREFBaUQ7UUFDakQsdUJBQXVCO1FBQ3ZCLE9BQU8xRjtJQUNULE9BQU8sd0JBQXdCLEdBQUcsSUFBSXlGLE9BQU8zQyxJQUFJO1FBQy9DLDRDQUE0QztRQUM1QyxvREFBb0Q7UUFDcEQsaURBQWlEO1FBQ2pELHdCQUF3QjtRQUN4QixPQUFPLE9BQVE0QyxLQUFLLEtBQU9QLElBQUksQ0FBQ0ssR0FBRyxLQUFLO0lBQzFDO0lBRUEseUJBQXlCO0lBQ3pCLHdCQUF3QixHQUN4QixNQUFNLElBQUlNLE1BQU07QUFDbEI7QUFFQSwrQkFBK0I7QUFDL0IsU0FBU3ZCLGFBQWM3RyxDQUFDO0lBQ3RCLE9BQU9BLEVBQUU4RixPQUFPLENBQUMsVUFBVTtBQUM3QjtBQUVBLFNBQVNxQixhQUFjbkgsQ0FBQztJQUN0QixPQUFPQSxFQUFFOEYsT0FBTyxDQUFDLDRCQUE0QjtBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NkLXRpbWVzaGVldC1hbmFseXplci8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvbWluaW1hdGNoLmpzPzQ4NTAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBtaW5pbWF0Y2hcbm1pbmltYXRjaC5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2hcblxudmFyIHBhdGggPSAoZnVuY3Rpb24gKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgncGF0aCcpIH0gY2F0Y2ggKGUpIHt9fSgpKSB8fCB7XG4gIHNlcDogJy8nXG59XG5taW5pbWF0Y2guc2VwID0gcGF0aC5zZXBcblxudmFyIEdMT0JTVEFSID0gbWluaW1hdGNoLkdMT0JTVEFSID0gTWluaW1hdGNoLkdMT0JTVEFSID0ge31cbnZhciBleHBhbmQgPSByZXF1aXJlKCdicmFjZS1leHBhbnNpb24nKVxuXG52YXIgcGxUeXBlcyA9IHtcbiAgJyEnOiB7IG9wZW46ICcoPzooPyEoPzonLCBjbG9zZTogJykpW14vXSo/KSd9LFxuICAnPyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKT8nIH0sXG4gICcrJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKycgfSxcbiAgJyonOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJykqJyB9LFxuICAnQCc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKScgfVxufVxuXG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgLyB3aGVuIHVzaW5nIG5ldyBSZWdFeHAoKVxudmFyIHFtYXJrID0gJ1teL10nXG5cbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG52YXIgc3RhciA9IHFtYXJrICsgJyo/J1xuXG4vLyAqKiB3aGVuIGRvdHMgYXJlIGFsbG93ZWQuICBBbnl0aGluZyBnb2VzLCBleGNlcHQgLi4gYW5kIC5cbi8vIG5vdCAoXiBvciAvIGZvbGxvd2VkIGJ5IG9uZSBvciB0d28gZG90cyBmb2xsb3dlZCBieSAkIG9yIC8pLFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG52YXIgdHdvU3RhckRvdCA9ICcoPzooPyEoPzpcXFxcXFwvfF4pKD86XFxcXC57MSwyfSkoJHxcXFxcXFwvKSkuKSo/J1xuXG4vLyBub3QgYSBeIG9yIC8gZm9sbG93ZWQgYnkgYSBkb3QsXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbnZhciB0d29TdGFyTm9Eb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKVxcXFwuKS4pKj8nXG5cbi8vIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVzY2FwZWQgaW4gUmVnRXhwLlxudmFyIHJlU3BlY2lhbHMgPSBjaGFyU2V0KCcoKS4qe30rP1tdXiRcXFxcIScpXG5cbi8vIFwiYWJjXCIgLT4geyBhOnRydWUsIGI6dHJ1ZSwgYzp0cnVlIH1cbmZ1bmN0aW9uIGNoYXJTZXQgKHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoJycpLnJlZHVjZShmdW5jdGlvbiAoc2V0LCBjKSB7XG4gICAgc2V0W2NdID0gdHJ1ZVxuICAgIHJldHVybiBzZXRcbiAgfSwge30pXG59XG5cbi8vIG5vcm1hbGl6ZXMgc2xhc2hlcy5cbnZhciBzbGFzaFNwbGl0ID0gL1xcLysvXG5cbm1pbmltYXRjaC5maWx0ZXIgPSBmaWx0ZXJcbmZ1bmN0aW9uIGZpbHRlciAocGF0dGVybiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICByZXR1cm4gZnVuY3Rpb24gKHAsIGksIGxpc3QpIHtcbiAgICByZXR1cm4gbWluaW1hdGNoKHAsIHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0IChhLCBiKSB7XG4gIGIgPSBiIHx8IHt9XG4gIHZhciB0ID0ge31cbiAgT2JqZWN0LmtleXMoYSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHRba10gPSBhW2tdXG4gIH0pXG4gIE9iamVjdC5rZXlzKGIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB0W2tdID0gYltrXVxuICB9KVxuICByZXR1cm4gdFxufVxuXG5taW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmIHx8IHR5cGVvZiBkZWYgIT09ICdvYmplY3QnIHx8ICFPYmplY3Qua2V5cyhkZWYpLmxlbmd0aCkge1xuICAgIHJldHVybiBtaW5pbWF0Y2hcbiAgfVxuXG4gIHZhciBvcmlnID0gbWluaW1hdGNoXG5cbiAgdmFyIG0gPSBmdW5jdGlvbiBtaW5pbWF0Y2ggKHAsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZyhwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uTWluaW1hdGNoID0gZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBvcmlnLk1pbmltYXRjaChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuICBtLk1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLk1pbmltYXRjaFxuICB9XG5cbiAgbS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5maWx0ZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLmRlZmF1bHRzID0gZnVuY3Rpb24gZGVmYXVsdHMgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0ubWFrZVJlID0gZnVuY3Rpb24gbWFrZVJlIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcubWFrZVJlKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5icmFjZUV4cGFuZCA9IGZ1bmN0aW9uIGJyYWNlRXhwYW5kIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuYnJhY2VFeHBhbmQocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLm1hdGNoID0gZnVuY3Rpb24gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5tYXRjaChsaXN0LCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIHJldHVybiBtXG59XG5cbk1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgcmV0dXJuIG1pbmltYXRjaC5kZWZhdWx0cyhkZWYpLk1pbmltYXRjaFxufVxuXG5mdW5jdGlvbiBtaW5pbWF0Y2ggKHAsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICAvLyBzaG9ydGN1dDogY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKVxufVxuXG5mdW5jdGlvbiBNaW5pbWF0Y2ggKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1pbmltYXRjaCkpIHtcbiAgICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICBwYXR0ZXJuID0gcGF0dGVybi50cmltKClcblxuICAvLyB3aW5kb3dzIHN1cHBvcnQ6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAoIW9wdGlvbnMuYWxsb3dXaW5kb3dzRXNjYXBlICYmIHBhdGguc2VwICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zcGxpdChwYXRoLnNlcCkuam9pbignLycpXG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMuc2V0ID0gW11cbiAgdGhpcy5wYXR0ZXJuID0gcGF0dGVyblxuICB0aGlzLnJlZ2V4cCA9IG51bGxcbiAgdGhpcy5uZWdhdGUgPSBmYWxzZVxuICB0aGlzLmNvbW1lbnQgPSBmYWxzZVxuICB0aGlzLmVtcHR5ID0gZmFsc2VcbiAgdGhpcy5wYXJ0aWFsID0gISFvcHRpb25zLnBhcnRpYWxcblxuICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gIHRoaXMubWFrZSgpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7fVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1ha2UgPSBtYWtlXG5mdW5jdGlvbiBtYWtlICgpIHtcbiAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBlbXB0eSBwYXR0ZXJucyBhbmQgY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgdGhpcy5jb21tZW50ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG4gIGlmICghcGF0dGVybikge1xuICAgIHRoaXMuZW1wdHkgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBzdGVwIDE6IGZpZ3VyZSBvdXQgbmVnYXRpb24sIGV0Yy5cbiAgdGhpcy5wYXJzZU5lZ2F0ZSgpXG5cbiAgLy8gc3RlcCAyOiBleHBhbmQgYnJhY2VzXG4gIHZhciBzZXQgPSB0aGlzLmdsb2JTZXQgPSB0aGlzLmJyYWNlRXhwYW5kKClcblxuICBpZiAob3B0aW9ucy5kZWJ1ZykgdGhpcy5kZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkgeyBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cykgfVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gc3RlcCAzOiBub3cgd2UgaGF2ZSBhIHNldCwgc28gdHVybiBlYWNoIG9uZSBpbnRvIGEgc2VyaWVzIG9mIHBhdGgtcG9ydGlvblxuICAvLyBtYXRjaGluZyBwYXR0ZXJucy5cbiAgLy8gVGhlc2Ugd2lsbCBiZSByZWdleHBzLCBleGNlcHQgaW4gdGhlIGNhc2Ugb2YgXCIqKlwiLCB3aGljaCBpc1xuICAvLyBzZXQgdG8gdGhlIEdMT0JTVEFSIG9iamVjdCBmb3IgZ2xvYnN0YXIgYmVoYXZpb3IsXG4gIC8vIGFuZCB3aWxsIG5vdCBjb250YWluIGFueSAvIGNoYXJhY3RlcnNcbiAgc2V0ID0gdGhpcy5nbG9iUGFydHMgPSBzZXQubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuc3BsaXQoc2xhc2hTcGxpdClcbiAgfSlcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGdsb2IgLS0+IHJlZ2V4cHNcbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbiAocywgc2ksIHNldCkge1xuICAgIHJldHVybiBzLm1hcCh0aGlzLnBhcnNlLCB0aGlzKVxuICB9LCB0aGlzKVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gZmlsdGVyIG91dCBldmVyeXRoaW5nIHRoYXQgZGlkbid0IGNvbXBpbGUgcHJvcGVybHkuXG4gIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTFcbiAgfSlcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIHRoaXMuc2V0ID0gc2V0XG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUucGFyc2VOZWdhdGUgPSBwYXJzZU5lZ2F0ZVxuZnVuY3Rpb24gcGFyc2VOZWdhdGUgKCkge1xuICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICB2YXIgbmVnYXRlID0gZmFsc2VcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgdmFyIG5lZ2F0ZU9mZnNldCA9IDBcblxuICBpZiAob3B0aW9ucy5ub25lZ2F0ZSkgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXR0ZXJuLmxlbmd0aFxuICAgIDsgaSA8IGwgJiYgcGF0dGVybi5jaGFyQXQoaSkgPT09ICchJ1xuICAgIDsgaSsrKSB7XG4gICAgbmVnYXRlID0gIW5lZ2F0ZVxuICAgIG5lZ2F0ZU9mZnNldCsrXG4gIH1cblxuICBpZiAobmVnYXRlT2Zmc2V0KSB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cihuZWdhdGVPZmZzZXQpXG4gIHRoaXMubmVnYXRlID0gbmVnYXRlXG59XG5cbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xubWluaW1hdGNoLmJyYWNlRXhwYW5kID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJyYWNlRXhwYW5kKHBhdHRlcm4sIG9wdGlvbnMpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUuYnJhY2VFeHBhbmQgPSBicmFjZUV4cGFuZFxuXG5mdW5jdGlvbiBicmFjZUV4cGFuZCAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE1pbmltYXRjaCkge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gIH1cblxuICBwYXR0ZXJuID0gdHlwZW9mIHBhdHRlcm4gPT09ICd1bmRlZmluZWQnXG4gICAgPyB0aGlzLnBhdHRlcm4gOiBwYXR0ZXJuXG5cbiAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgLy8gVGhhbmtzIHRvIFlldGluZyBMaSA8aHR0cHM6Ly9naXRodWIuY29tL3lldGluZ2xpPiBmb3JcbiAgLy8gaW1wcm92aW5nIHRoaXMgcmVnZXhwIHRvIGF2b2lkIGEgUmVET1MgdnVsbmVyYWJpbGl0eS5cbiAgaWYgKG9wdGlvbnMubm9icmFjZSB8fCAhL1xceyg/Oig/IVxceykuKSpcXH0vLnRlc3QocGF0dGVybikpIHtcbiAgICAvLyBzaG9ydGN1dC4gbm8gbmVlZCB0byBleHBhbmQuXG4gICAgcmV0dXJuIFtwYXR0ZXJuXVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuZChwYXR0ZXJuKVxufVxuXG52YXIgTUFYX1BBVFRFUk5fTEVOR1RIID0gMTAyNCAqIDY0XG52YXIgYXNzZXJ0VmFsaWRQYXR0ZXJuID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGF0dGVybicpXG4gIH1cblxuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfUEFUVEVSTl9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXR0ZXJuIGlzIHRvbyBsb25nJylcbiAgfVxufVxuXG4vLyBwYXJzZSBhIGNvbXBvbmVudCBvZiB0aGUgZXhwYW5kZWQgc2V0LlxuLy8gQXQgdGhpcyBwb2ludCwgbm8gcGF0dGVybiBtYXkgY29udGFpbiBcIi9cIiBpbiBpdFxuLy8gc28gd2UncmUgZ29pbmcgdG8gcmV0dXJuIGEgMmQgYXJyYXksIHdoZXJlIGVhY2ggZW50cnkgaXMgdGhlIGZ1bGxcbi8vIHBhdHRlcm4sIHNwbGl0IG9uICcvJywgYW5kIHRoZW4gdHVybmVkIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24uXG4vLyBBIHJlZ2V4cCBpcyBtYWRlIGF0IHRoZSBlbmQgd2hpY2ggam9pbnMgZWFjaCBhcnJheSB3aXRoIGFuXG4vLyBlc2NhcGVkIC8sIGFuZCBhbm90aGVyIGZ1bGwgb25lIHdoaWNoIGpvaW5zIGVhY2ggcmVnZXhwIHdpdGggfC5cbi8vXG4vLyBGb2xsb3dpbmcgdGhlIGxlYWQgb2YgQmFzaCA0LjEsIG5vdGUgdGhhdCBcIioqXCIgb25seSBoYXMgc3BlY2lhbCBtZWFuaW5nXG4vLyB3aGVuIGl0IGlzIHRoZSAqb25seSogdGhpbmcgaW4gYSBwYXRoIHBvcnRpb24uICBPdGhlcndpc2UsIGFueSBzZXJpZXNcbi8vIG9mICogaXMgZXF1aXZhbGVudCB0byBhIHNpbmdsZSAqLiAgR2xvYnN0YXIgYmVoYXZpb3IgaXMgZW5hYmxlZCBieVxuLy8gZGVmYXVsdCwgYW5kIGNhbiBiZSBkaXNhYmxlZCBieSBzZXR0aW5nIG9wdGlvbnMubm9nbG9ic3Rhci5cbk1pbmltYXRjaC5wcm90b3R5cGUucGFyc2UgPSBwYXJzZVxudmFyIFNVQlBBUlNFID0ge31cbmZ1bmN0aW9uIHBhcnNlIChwYXR0ZXJuLCBpc1N1Yikge1xuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHNob3J0Y3V0c1xuICBpZiAocGF0dGVybiA9PT0gJyoqJykge1xuICAgIGlmICghb3B0aW9ucy5ub2dsb2JzdGFyKVxuICAgICAgcmV0dXJuIEdMT0JTVEFSXG4gICAgZWxzZVxuICAgICAgcGF0dGVybiA9ICcqJ1xuICB9XG4gIGlmIChwYXR0ZXJuID09PSAnJykgcmV0dXJuICcnXG5cbiAgdmFyIHJlID0gJydcbiAgdmFyIGhhc01hZ2ljID0gISFvcHRpb25zLm5vY2FzZVxuICB2YXIgZXNjYXBpbmcgPSBmYWxzZVxuICAvLyA/ID0+IG9uZSBzaW5nbGUgY2hhcmFjdGVyXG4gIHZhciBwYXR0ZXJuTGlzdFN0YWNrID0gW11cbiAgdmFyIG5lZ2F0aXZlTGlzdHMgPSBbXVxuICB2YXIgc3RhdGVDaGFyXG4gIHZhciBpbkNsYXNzID0gZmFsc2VcbiAgdmFyIHJlQ2xhc3NTdGFydCA9IC0xXG4gIHZhciBjbGFzc1N0YXJ0ID0gLTFcbiAgLy8gLiBhbmQgLi4gbmV2ZXIgbWF0Y2ggYW55dGhpbmcgdGhhdCBkb2Vzbid0IHN0YXJ0IHdpdGggLixcbiAgLy8gZXZlbiB3aGVuIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgdmFyIHBhdHRlcm5TdGFydCA9IHBhdHRlcm4uY2hhckF0KDApID09PSAnLicgPyAnJyAvLyBhbnl0aGluZ1xuICAvLyBub3QgKHN0YXJ0IG9yIC8gZm9sbG93ZWQgYnkgLiBvciAuLiBmb2xsb3dlZCBieSAvIG9yIGVuZClcbiAgOiBvcHRpb25zLmRvdCA/ICcoPyEoPzpefFxcXFxcXC8pXFxcXC57MSwyfSg/OiR8XFxcXFxcLykpJ1xuICA6ICcoPyFcXFxcLiknXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGZ1bmN0aW9uIGNsZWFyU3RhdGVDaGFyICgpIHtcbiAgICBpZiAoc3RhdGVDaGFyKSB7XG4gICAgICAvLyB3ZSBoYWQgc29tZSBzdGF0ZS10cmFja2luZyBjaGFyYWN0ZXJcbiAgICAgIC8vIHRoYXQgd2Fzbid0IGNvbnN1bWVkIGJ5IHRoaXMgcGFzcy5cbiAgICAgIHN3aXRjaCAoc3RhdGVDaGFyKSB7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgIHJlICs9IHN0YXJcbiAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgcmUgKz0gcW1hcmtcbiAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBzdGF0ZUNoYXJcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHNlbGYuZGVidWcoJ2NsZWFyU3RhdGVDaGFyICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgIHN0YXRlQ2hhciA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoLCBjXG4gICAgOyAoaSA8IGxlbikgJiYgKGMgPSBwYXR0ZXJuLmNoYXJBdChpKSlcbiAgICA7IGkrKykge1xuICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWonLCBwYXR0ZXJuLCBpLCByZSwgYylcblxuICAgIC8vIHNraXAgb3ZlciBhbnkgdGhhdCBhcmUgZXNjYXBlZC5cbiAgICBpZiAoZXNjYXBpbmcgJiYgcmVTcGVjaWFsc1tjXSkge1xuICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBjYXNlICcvJzoge1xuICAgICAgICAvLyBjb21wbGV0ZWx5IG5vdCBhbGxvd2VkLCBldmVuIGVzY2FwZWQuXG4gICAgICAgIC8vIFNob3VsZCBhbHJlYWR5IGJlIHBhdGgtc3BsaXQgYnkgbm93LlxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgZXNjYXBpbmcgPSB0cnVlXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGUgdmFyaW91cyBzdGF0ZUNoYXIgdmFsdWVzXG4gICAgICAvLyBmb3IgdGhlIFwiZXh0Z2xvYlwiIHN0dWZmLlxuICAgICAgY2FzZSAnPyc6XG4gICAgICBjYXNlICcqJzpcbiAgICAgIGNhc2UgJysnOlxuICAgICAgY2FzZSAnQCc6XG4gICAgICBjYXNlICchJzpcbiAgICAgICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaiA8LS0gc3RhdGVDaGFyJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAgICAgLy8gYWxsIG9mIHRob3NlIGFyZSBsaXRlcmFscyBpbnNpZGUgYSBjbGFzcywgZXhjZXB0IHRoYXRcbiAgICAgICAgLy8gdGhlIGdsb2IgWyFhXSBtZWFucyBbXmFdIGluIHJlZ2V4cFxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHRoaXMuZGVidWcoJyAgaW4gY2xhc3MnKVxuICAgICAgICAgIGlmIChjID09PSAnIScgJiYgaSA9PT0gY2xhc3NTdGFydCArIDEpIGMgPSAnXidcbiAgICAgICAgICByZSArPSBjXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXRlQ2hhciwgdGhlbiBpdCBtZWFuc1xuICAgICAgICAvLyB0aGF0IHRoZXJlIHdhcyBzb21ldGhpbmcgbGlrZSAqKiBvciArPyBpbiB0aGVyZS5cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBzdGF0ZUNoYXIsIHRoZW4gcHJvY2VlZCB3aXRoIHRoaXMgb25lLlxuICAgICAgICBzZWxmLmRlYnVnKCdjYWxsIGNsZWFyU3RhdGVDaGFyICVqJywgc3RhdGVDaGFyKVxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIHN0YXRlQ2hhciA9IGNcbiAgICAgICAgLy8gaWYgZXh0Z2xvYiBpcyBkaXNhYmxlZCwgdGhlbiArKGFzZGZ8Zm9vKSBpc24ndCBhIHRoaW5nLlxuICAgICAgICAvLyBqdXN0IGNsZWFyIHRoZSBzdGF0ZWNoYXIgKm5vdyosIHJhdGhlciB0aGFuIGV2ZW4gZGl2aW5nIGludG9cbiAgICAgICAgLy8gdGhlIHBhdHRlcm5MaXN0IHN0dWZmLlxuICAgICAgICBpZiAob3B0aW9ucy5ub2V4dCkgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnKCc6XG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJygnXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhdGVDaGFyKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBwYXR0ZXJuTGlzdFN0YWNrLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHN0YXRlQ2hhcixcbiAgICAgICAgICBzdGFydDogaSAtIDEsXG4gICAgICAgICAgcmVTdGFydDogcmUubGVuZ3RoLFxuICAgICAgICAgIG9wZW46IHBsVHlwZXNbc3RhdGVDaGFyXS5vcGVuLFxuICAgICAgICAgIGNsb3NlOiBwbFR5cGVzW3N0YXRlQ2hhcl0uY2xvc2VcbiAgICAgICAgfSlcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIHJlICs9IHN0YXRlQ2hhciA9PT0gJyEnID8gJyg/Oig/ISg/OicgOiAnKD86J1xuICAgICAgICB0aGlzLmRlYnVnKCdwbFR5cGUgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHJlICs9ICdcXFxcKSdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgdmFyIHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKVxuICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyFqcylbXi9dKilcbiAgICAgICAgLy8gVGhlIG90aGVycyBhcmUgKD86PHBhdHRlcm4+KTx0eXBlPlxuICAgICAgICByZSArPSBwbC5jbG9zZVxuICAgICAgICBpZiAocGwudHlwZSA9PT0gJyEnKSB7XG4gICAgICAgICAgbmVnYXRpdmVMaXN0cy5wdXNoKHBsKVxuICAgICAgICB9XG4gICAgICAgIHBsLnJlRW5kID0gcmUubGVuZ3RoXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBhdHRlcm5MaXN0U3RhY2subGVuZ3RoIHx8IGVzY2FwaW5nKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFx8J1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICByZSArPSAnfCdcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIC8vIHRoZXNlIGFyZSBtb3N0bHkgdGhlIHNhbWUgaW4gcmVnZXhwIGFuZCBnbG9iXG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUtdHJhY2tpbmcgY2hhciBiZWZvcmUgdGhlIFtcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpbkNsYXNzID0gdHJ1ZVxuICAgICAgICBjbGFzc1N0YXJ0ID0gaVxuICAgICAgICByZUNsYXNzU3RhcnQgPSByZS5sZW5ndGhcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnXSc6XG4gICAgICAgIC8vICBhIHJpZ2h0IGJyYWNrZXQgc2hhbGwgbG9zZSBpdHMgc3BlY2lhbFxuICAgICAgICAvLyAgbWVhbmluZyBhbmQgcmVwcmVzZW50IGl0c2VsZiBpblxuICAgICAgICAvLyAgYSBicmFja2V0IGV4cHJlc3Npb24gaWYgaXQgb2NjdXJzXG4gICAgICAgIC8vICBmaXJzdCBpbiB0aGUgbGlzdC4gIC0tIFBPU0lYLjIgMi44LjMuMlxuICAgICAgICBpZiAoaSA9PT0gY2xhc3NTdGFydCArIDEgfHwgIWluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgbGVmdCBhIGNsYXNzIG9wZW4uXG4gICAgICAgIC8vIFwiW3otYV1cIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW3otYVxcXVwiXG4gICAgICAgIC8vIHNwbGl0IHdoZXJlIHRoZSBsYXN0IFsgd2FzLCBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAvLyBhbiBpbnZhbGlkIHJlLiBpZiBzbywgcmUtd2FsayB0aGUgY29udGVudHMgb2YgdGhlXG4gICAgICAgIC8vIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZSBhbnkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgIC8vIHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXNcbiAgICAgICAgLy8gVE9ETzogSXQgd291bGQgcHJvYmFibHkgYmUgZmFzdGVyIHRvIGRldGVybWluZSB0aGlzXG4gICAgICAgIC8vIHdpdGhvdXQgYSB0cnkvY2F0Y2ggYW5kIGEgbmV3IFJlZ0V4cCwgYnV0IGl0J3MgdHJpY2t5XG4gICAgICAgIC8vIHRvIGRvIHNhZmVseS4gIEZvciBub3csIHRoaXMgaXMgc2FmZSBhbmQgd29ya3MuXG4gICAgICAgIHZhciBjcyA9IHBhdHRlcm4uc3Vic3RyaW5nKGNsYXNzU3RhcnQgKyAxLCBpKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZ0V4cCgnWycgKyBjcyArICddJylcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAvLyBub3QgYSB2YWxpZCBjbGFzcyFcbiAgICAgICAgICB2YXIgc3AgPSB0aGlzLnBhcnNlKGNzLCBTVUJQQVJTRSlcbiAgICAgICAgICByZSA9IHJlLnN1YnN0cigwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdICsgJ1xcXFxdJ1xuICAgICAgICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgc3BbMV1cbiAgICAgICAgICBpbkNsYXNzID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluaXNoIHVwIHRoZSBjbGFzcy5cbiAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICByZSArPSBjXG4gICAgICBjb250aW51ZVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZSBjaGFyIHRoYXQgd2Fzbid0IGNvbnN1bWVkXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICBpZiAoZXNjYXBpbmcpIHtcbiAgICAgICAgICAvLyBubyBuZWVkXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKHJlU3BlY2lhbHNbY11cbiAgICAgICAgICAmJiAhKGMgPT09ICdeJyAmJiBpbkNsYXNzKSkge1xuICAgICAgICAgIHJlICs9ICdcXFxcJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmUgKz0gY1xuXG4gICAgfSAvLyBzd2l0Y2hcbiAgfSAvLyBmb3JcblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgbGVmdCBhIGNsYXNzIG9wZW4uXG4gIC8vIFwiW2FiY1wiIGlzIHZhbGlkLCBlcXVpdmFsZW50IHRvIFwiXFxbYWJjXCJcbiAgaWYgKGluQ2xhc3MpIHtcbiAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgYW5kIGVzY2FwZSBpdFxuICAgIC8vIHRoaXMgaXMgYSBodWdlIHBpdGEuICBXZSBub3cgaGF2ZSB0byByZS13YWxrXG4gICAgLy8gdGhlIGNvbnRlbnRzIG9mIHRoZSB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGVcbiAgICAvLyBhbnkgY2hhcmFjdGVycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXNcbiAgICBjcyA9IHBhdHRlcm4uc3Vic3RyKGNsYXNzU3RhcnQgKyAxKVxuICAgIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXVxuICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgc3BbMV1cbiAgfVxuXG4gIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBoYWQgYSArKCB0aGluZyBhdCB0aGUgKmVuZCpcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIC8vIGVhY2ggcGF0dGVybiBsaXN0IHN0YWNrIGFkZHMgMyBjaGFycywgYW5kIHdlIG5lZWQgdG8gZ28gdGhyb3VnaFxuICAvLyBhbmQgZXNjYXBlIGFueSB8IGNoYXJzIHRoYXQgd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pcyBmb3IgdGhlIHJlZ2V4cC5cbiAgLy8gR28gdGhyb3VnaCBhbmQgZXNjYXBlIHRoZW0sIHRha2luZyBjYXJlIG5vdCB0byBkb3VibGUtZXNjYXBlIGFueVxuICAvLyB8IGNoYXJzIHRoYXQgd2VyZSBhbHJlYWR5IGVzY2FwZWQuXG4gIGZvciAocGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpOyBwbDsgcGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpKSB7XG4gICAgdmFyIHRhaWwgPSByZS5zbGljZShwbC5yZVN0YXJ0ICsgcGwub3Blbi5sZW5ndGgpXG4gICAgdGhpcy5kZWJ1Zygnc2V0dGluZyB0YWlsJywgcmUsIHBsKVxuICAgIC8vIG1heWJlIHNvbWUgZXZlbiBudW1iZXIgb2YgXFwsIHRoZW4gbWF5YmUgMSBcXCwgZm9sbG93ZWQgYnkgYSB8XG4gICAgdGFpbCA9IHRhaWwucmVwbGFjZSgvKCg/OlxcXFx7Mn0pezAsNjR9KShcXFxcPylcXHwvZywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgaWYgKCEkMikge1xuICAgICAgICAvLyB0aGUgfCBpc24ndCBhbHJlYWR5IGVzY2FwZWQsIHNvIGVzY2FwZSBpdC5cbiAgICAgICAgJDIgPSAnXFxcXCdcbiAgICAgIH1cblxuICAgICAgLy8gbmVlZCB0byBlc2NhcGUgYWxsIHRob3NlIHNsYXNoZXMgKmFnYWluKiwgd2l0aG91dCBlc2NhcGluZyB0aGVcbiAgICAgIC8vIG9uZSB0aGF0IHdlIG5lZWQgZm9yIGVzY2FwaW5nIHRoZSB8IGNoYXJhY3Rlci4gIEFzIGl0IHdvcmtzIG91dCxcbiAgICAgIC8vIGVzY2FwaW5nIGFuIGV2ZW4gbnVtYmVyIG9mIHNsYXNoZXMgY2FuIGJlIGRvbmUgYnkgc2ltcGx5IHJlcGVhdGluZ1xuICAgICAgLy8gaXQgZXhhY3RseSBhZnRlciBpdHNlbGYuICBUaGF0J3Mgd2h5IHRoaXMgdHJpY2sgd29ya3MuXG4gICAgICAvL1xuICAgICAgLy8gSSBhbSBzb3JyeSB0aGF0IHlvdSBoYXZlIHRvIHNlZSB0aGlzLlxuICAgICAgcmV0dXJuICQxICsgJDEgKyAkMiArICd8J1xuICAgIH0pXG5cbiAgICB0aGlzLmRlYnVnKCd0YWlsPSVqXFxuICAgJXMnLCB0YWlsLCB0YWlsLCBwbCwgcmUpXG4gICAgdmFyIHQgPSBwbC50eXBlID09PSAnKicgPyBzdGFyXG4gICAgICA6IHBsLnR5cGUgPT09ICc/JyA/IHFtYXJrXG4gICAgICA6ICdcXFxcJyArIHBsLnR5cGVcblxuICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgIHJlID0gcmUuc2xpY2UoMCwgcGwucmVTdGFydCkgKyB0ICsgJ1xcXFwoJyArIHRhaWxcbiAgfVxuXG4gIC8vIGhhbmRsZSB0cmFpbGluZyB0aGluZ3MgdGhhdCBvbmx5IG1hdHRlciBhdCB0aGUgdmVyeSBlbmQuXG4gIGNsZWFyU3RhdGVDaGFyKClcbiAgaWYgKGVzY2FwaW5nKSB7XG4gICAgLy8gdHJhaWxpbmcgXFxcXFxuICAgIHJlICs9ICdcXFxcXFxcXCdcbiAgfVxuXG4gIC8vIG9ubHkgbmVlZCB0byBhcHBseSB0aGUgbm9kb3Qgc3RhcnQgaWYgdGhlIHJlIHN0YXJ0cyB3aXRoXG4gIC8vIHNvbWV0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGNhcHR1cmUgYSBkb3RcbiAgdmFyIGFkZFBhdHRlcm5TdGFydCA9IGZhbHNlXG4gIHN3aXRjaCAocmUuY2hhckF0KDApKSB7XG4gICAgY2FzZSAnWyc6IGNhc2UgJy4nOiBjYXNlICcoJzogYWRkUGF0dGVyblN0YXJ0ID0gdHJ1ZVxuICB9XG5cbiAgLy8gSGFjayB0byB3b3JrIGFyb3VuZCBsYWNrIG9mIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaW4gSlNcbiAgLy8gQSBwYXR0ZXJuIGxpa2U6ICouISh4KS4hKHl8eikgbmVlZHMgdG8gZW5zdXJlIHRoYXQgYSBuYW1lXG4gIC8vIGxpa2UgJ2EueHl6Lnl6JyBkb2Vzbid0IG1hdGNoLiAgU28sIHRoZSBmaXJzdCBuZWdhdGl2ZVxuICAvLyBsb29rYWhlYWQsIGhhcyB0byBsb29rIEFMTCB0aGUgd2F5IGFoZWFkLCB0byB0aGUgZW5kIG9mXG4gIC8vIHRoZSBwYXR0ZXJuLlxuICBmb3IgKHZhciBuID0gbmVnYXRpdmVMaXN0cy5sZW5ndGggLSAxOyBuID4gLTE7IG4tLSkge1xuICAgIHZhciBubCA9IG5lZ2F0aXZlTGlzdHNbbl1cblxuICAgIHZhciBubEJlZm9yZSA9IHJlLnNsaWNlKDAsIG5sLnJlU3RhcnQpXG4gICAgdmFyIG5sRmlyc3QgPSByZS5zbGljZShubC5yZVN0YXJ0LCBubC5yZUVuZCAtIDgpXG4gICAgdmFyIG5sTGFzdCA9IHJlLnNsaWNlKG5sLnJlRW5kIC0gOCwgbmwucmVFbmQpXG4gICAgdmFyIG5sQWZ0ZXIgPSByZS5zbGljZShubC5yZUVuZClcblxuICAgIG5sTGFzdCArPSBubEFmdGVyXG5cbiAgICAvLyBIYW5kbGUgbmVzdGVkIHN0dWZmIGxpa2UgKigqLmpzfCEoKi5qc29uKSksIHdoZXJlIG9wZW4gcGFyZW5zXG4gICAgLy8gbWVhbiB0aGF0IHdlIHNob3VsZCAqbm90KiBpbmNsdWRlIHRoZSApIGluIHRoZSBiaXQgdGhhdCBpcyBjb25zaWRlcmVkXG4gICAgLy8gXCJhZnRlclwiIHRoZSBuZWdhdGVkIHNlY3Rpb24uXG4gICAgdmFyIG9wZW5QYXJlbnNCZWZvcmUgPSBubEJlZm9yZS5zcGxpdCgnKCcpLmxlbmd0aCAtIDFcbiAgICB2YXIgY2xlYW5BZnRlciA9IG5sQWZ0ZXJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3BlblBhcmVuc0JlZm9yZTsgaSsrKSB7XG4gICAgICBjbGVhbkFmdGVyID0gY2xlYW5BZnRlci5yZXBsYWNlKC9cXClbKyo/XT8vLCAnJylcbiAgICB9XG4gICAgbmxBZnRlciA9IGNsZWFuQWZ0ZXJcblxuICAgIHZhciBkb2xsYXIgPSAnJ1xuICAgIGlmIChubEFmdGVyID09PSAnJyAmJiBpc1N1YiAhPT0gU1VCUEFSU0UpIHtcbiAgICAgIGRvbGxhciA9ICckJ1xuICAgIH1cbiAgICB2YXIgbmV3UmUgPSBubEJlZm9yZSArIG5sRmlyc3QgKyBubEFmdGVyICsgZG9sbGFyICsgbmxMYXN0XG4gICAgcmUgPSBuZXdSZVxuICB9XG5cbiAgLy8gaWYgdGhlIHJlIGlzIG5vdCBcIlwiIGF0IHRoaXMgcG9pbnQsIHRoZW4gd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgLy8gaXQgZG9lc24ndCBtYXRjaCBhZ2FpbnN0IGFuIGVtcHR5IHBhdGggcGFydC5cbiAgLy8gT3RoZXJ3aXNlIGEvKiB3aWxsIG1hdGNoIGEvLCB3aGljaCBpdCBzaG91bGQgbm90LlxuICBpZiAocmUgIT09ICcnICYmIGhhc01hZ2ljKSB7XG4gICAgcmUgPSAnKD89LiknICsgcmVcbiAgfVxuXG4gIGlmIChhZGRQYXR0ZXJuU3RhcnQpIHtcbiAgICByZSA9IHBhdHRlcm5TdGFydCArIHJlXG4gIH1cblxuICAvLyBwYXJzaW5nIGp1c3QgYSBwaWVjZSBvZiBhIGxhcmdlciBwYXR0ZXJuLlxuICBpZiAoaXNTdWIgPT09IFNVQlBBUlNFKSB7XG4gICAgcmV0dXJuIFtyZSwgaGFzTWFnaWNdXG4gIH1cblxuICAvLyBza2lwIHRoZSByZWdleHAgZm9yIG5vbi1tYWdpY2FsIHBhdHRlcm5zXG4gIC8vIHVuZXNjYXBlIGFueXRoaW5nIGluIGl0LCB0aG91Z2gsIHNvIHRoYXQgaXQnbGwgYmVcbiAgLy8gYW4gZXhhY3QgbWF0Y2ggYWdhaW5zdCBhIGZpbGUgZXRjLlxuICBpZiAoIWhhc01hZ2ljKSB7XG4gICAgcmV0dXJuIGdsb2JVbmVzY2FwZShwYXR0ZXJuKVxuICB9XG5cbiAgdmFyIGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuICB0cnkge1xuICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKCdeJyArIHJlICsgJyQnLCBmbGFncylcbiAgfSBjYXRjaCAoZXIpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gc2hvdWxkIGJlIGltcG9zc2libGUgKi8ge1xuICAgIC8vIElmIGl0IHdhcyBhbiBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhlbiBpdCBjYW4ndCBtYXRjaFxuICAgIC8vIGFueXRoaW5nLiAgVGhpcyB0cmljayBsb29rcyBmb3IgYSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGVuZCBvZlxuICAgIC8vIHRoZSBzdHJpbmcsIHdoaWNoIGlzIG9mIGNvdXJzZSBpbXBvc3NpYmxlLCBleGNlcHQgaW4gbXVsdGktbGluZVxuICAgIC8vIG1vZGUsIGJ1dCBpdCdzIG5vdCBhIC9tIHJlZ2V4LlxuICAgIHJldHVybiBuZXcgUmVnRXhwKCckLicpXG4gIH1cblxuICByZWdFeHAuX2dsb2IgPSBwYXR0ZXJuXG4gIHJlZ0V4cC5fc3JjID0gcmVcblxuICByZXR1cm4gcmVnRXhwXG59XG5cbm1pbmltYXRjaC5tYWtlUmUgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zIHx8IHt9KS5tYWtlUmUoKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1ha2VSZSA9IG1ha2VSZVxuZnVuY3Rpb24gbWFrZVJlICgpIHtcbiAgaWYgKHRoaXMucmVnZXhwIHx8IHRoaXMucmVnZXhwID09PSBmYWxzZSkgcmV0dXJuIHRoaXMucmVnZXhwXG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgdGhpcy5zZXQgaXMgYSAyZCBhcnJheSBvZiBwYXJ0aWFsXG4gIC8vIHBhdHRlcm4gc3RyaW5ncywgb3IgXCIqKlwiLlxuICAvL1xuICAvLyBJdCdzIGJldHRlciB0byB1c2UgLm1hdGNoKCkuICBUaGlzIGZ1bmN0aW9uIHNob3VsZG4ndFxuICAvLyBiZSB1c2VkLCByZWFsbHksIGJ1dCBpdCdzIHByZXR0eSBjb252ZW5pZW50IHNvbWV0aW1lcyxcbiAgLy8gd2hlbiB5b3UganVzdCB3YW50IHRvIHdvcmsgd2l0aCBhIHJlZ2V4LlxuICB2YXIgc2V0ID0gdGhpcy5zZXRcblxuICBpZiAoIXNldC5sZW5ndGgpIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gICAgcmV0dXJuIHRoaXMucmVnZXhwXG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICB2YXIgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhciA/IHN0YXJcbiAgICA6IG9wdGlvbnMuZG90ID8gdHdvU3RhckRvdFxuICAgIDogdHdvU3Rhck5vRG90XG4gIHZhciBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcblxuICB2YXIgcmUgPSBzZXQubWFwKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gKHAgPT09IEdMT0JTVEFSKSA/IHR3b1N0YXJcbiAgICAgIDogKHR5cGVvZiBwID09PSAnc3RyaW5nJykgPyByZWdFeHBFc2NhcGUocClcbiAgICAgIDogcC5fc3JjXG4gICAgfSkuam9pbignXFxcXFxcLycpXG4gIH0pLmpvaW4oJ3wnKVxuXG4gIC8vIG11c3QgbWF0Y2ggZW50aXJlIHBhdHRlcm5cbiAgLy8gZW5kaW5nIGluIGEgKiBvciAqKiB3aWxsIG1ha2UgaXQgbGVzcyBzdHJpY3QuXG4gIHJlID0gJ14oPzonICsgcmUgKyAnKSQnXG5cbiAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gIGlmICh0aGlzLm5lZ2F0ZSkgcmUgPSAnXig/IScgKyByZSArICcpLiokJ1xuXG4gIHRyeSB7XG4gICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKHJlLCBmbGFncylcbiAgfSBjYXRjaCAoZXgpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gc2hvdWxkIGJlIGltcG9zc2libGUgKi8ge1xuICAgIHRoaXMucmVnZXhwID0gZmFsc2VcbiAgfVxuICByZXR1cm4gdGhpcy5yZWdleHBcbn1cblxubWluaW1hdGNoLm1hdGNoID0gZnVuY3Rpb24gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIG1tID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICBsaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gbW0ubWF0Y2goZilcbiAgfSlcbiAgaWYgKG1tLm9wdGlvbnMubm9udWxsICYmICFsaXN0Lmxlbmd0aCkge1xuICAgIGxpc3QucHVzaChwYXR0ZXJuKVxuICB9XG4gIHJldHVybiBsaXN0XG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoZiwgcGFydGlhbCkge1xuICBpZiAodHlwZW9mIHBhcnRpYWwgPT09ICd1bmRlZmluZWQnKSBwYXJ0aWFsID0gdGhpcy5wYXJ0aWFsXG4gIHRoaXMuZGVidWcoJ21hdGNoJywgZiwgdGhpcy5wYXR0ZXJuKVxuICAvLyBzaG9ydC1jaXJjdWl0IGluIHRoZSBjYXNlIG9mIGJ1c3RlZCB0aGluZ3MuXG4gIC8vIGNvbW1lbnRzLCBldGMuXG4gIGlmICh0aGlzLmNvbW1lbnQpIHJldHVybiBmYWxzZVxuICBpZiAodGhpcy5lbXB0eSkgcmV0dXJuIGYgPT09ICcnXG5cbiAgaWYgKGYgPT09ICcvJyAmJiBwYXJ0aWFsKSByZXR1cm4gdHJ1ZVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gd2luZG93czogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gIGlmIChwYXRoLnNlcCAhPT0gJy8nKSB7XG4gICAgZiA9IGYuc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICB9XG5cbiAgLy8gdHJlYXQgdGhlIHRlc3QgcGF0aCBhcyBhIHNldCBvZiBwYXRocGFydHMuXG4gIGYgPSBmLnNwbGl0KHNsYXNoU3BsaXQpXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc3BsaXQnLCBmKVxuXG4gIC8vIGp1c3QgT05FIG9mIHRoZSBwYXR0ZXJuIHNldHMgaW4gdGhpcy5zZXQgbmVlZHMgdG8gbWF0Y2hcbiAgLy8gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHZhbGlkLiAgSWYgbmVnYXRpbmcsIHRoZW4ganVzdCBvbmVcbiAgLy8gbWF0Y2ggbWVhbnMgdGhhdCB3ZSBoYXZlIGZhaWxlZC5cbiAgLy8gRWl0aGVyIHdheSwgcmV0dXJuIG9uIHRoZSBmaXJzdCBoaXQuXG5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc2V0Jywgc2V0KVxuXG4gIC8vIEZpbmQgdGhlIGJhc2VuYW1lIG9mIHRoZSBwYXRoIGJ5IGxvb2tpbmcgZm9yIHRoZSBsYXN0IG5vbi1lbXB0eSBzZWdtZW50XG4gIHZhciBmaWxlbmFtZVxuICB2YXIgaVxuICBmb3IgKGkgPSBmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZmlsZW5hbWUgPSBmW2ldXG4gICAgaWYgKGZpbGVuYW1lKSBicmVha1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXR0ZXJuID0gc2V0W2ldXG4gICAgdmFyIGZpbGUgPSBmXG4gICAgaWYgKG9wdGlvbnMubWF0Y2hCYXNlICYmIHBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICBmaWxlID0gW2ZpbGVuYW1lXVxuICAgIH1cbiAgICB2YXIgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKVxuICAgIGlmIChoaXQpIHtcbiAgICAgIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gIXRoaXMubmVnYXRlXG4gICAgfVxuICB9XG5cbiAgLy8gZGlkbid0IGdldCBhbnkgaGl0cy4gIHRoaXMgaXMgc3VjY2VzcyBpZiBpdCdzIGEgbmVnYXRpdmVcbiAgLy8gcGF0dGVybiwgZmFpbHVyZSBvdGhlcndpc2UuXG4gIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHJldHVybiBmYWxzZVxuICByZXR1cm4gdGhpcy5uZWdhdGVcbn1cblxuLy8gc2V0IHBhcnRpYWwgdG8gdHJ1ZSB0byB0ZXN0IGlmLCBmb3IgZXhhbXBsZSxcbi8vIFwiL2EvYlwiIG1hdGNoZXMgdGhlIHN0YXJ0IG9mIFwiLyovYi8qL2RcIlxuLy8gUGFydGlhbCBtZWFucywgaWYgeW91IHJ1biBvdXQgb2YgZmlsZSBiZWZvcmUgeW91IHJ1blxuLy8gb3V0IG9mIHBhdHRlcm4sIHRoZW4gdGhhdCdzIGZpbmUsIGFzIGxvbmcgYXMgYWxsXG4vLyB0aGUgcGFydHMgbWF0Y2guXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1hdGNoT25lID0gZnVuY3Rpb24gKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsXG4gICAgeyAndGhpcyc6IHRoaXMsIGZpbGU6IGZpbGUsIHBhdHRlcm46IHBhdHRlcm4gfSlcblxuICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIGZpbGUubGVuZ3RoLCBwYXR0ZXJuLmxlbmd0aClcblxuICBmb3IgKHZhciBmaSA9IDAsXG4gICAgICBwaSA9IDAsXG4gICAgICBmbCA9IGZpbGUubGVuZ3RoLFxuICAgICAgcGwgPSBwYXR0ZXJuLmxlbmd0aFxuICAgICAgOyAoZmkgPCBmbCkgJiYgKHBpIDwgcGwpXG4gICAgICA7IGZpKyssIHBpKyspIHtcbiAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZSBsb29wJylcbiAgICB2YXIgcCA9IHBhdHRlcm5bcGldXG4gICAgdmFyIGYgPSBmaWxlW2ZpXVxuXG4gICAgdGhpcy5kZWJ1ZyhwYXR0ZXJuLCBwLCBmKVxuXG4gICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGUuXG4gICAgLy8gc29tZSBpbnZhbGlkIHJlZ2V4cCBzdHVmZiBpbiB0aGUgc2V0LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXG5cbiAgICBpZiAocCA9PT0gR0xPQlNUQVIpIHtcbiAgICAgIHRoaXMuZGVidWcoJ0dMT0JTVEFSJywgW3BhdHRlcm4sIHAsIGZdKVxuXG4gICAgICAvLyBcIioqXCJcbiAgICAgIC8vIGEvKiovYi8qKi9jIHdvdWxkIG1hdGNoIHRoZSBmb2xsb3dpbmc6XG4gICAgICAvLyBhL2IveC95L3ovY1xuICAgICAgLy8gYS94L3kvei9iL2NcbiAgICAgIC8vIGEvYi94L2IveC9jXG4gICAgICAvLyBhL2IvY1xuICAgICAgLy8gVG8gZG8gdGhpcywgdGFrZSB0aGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlclxuICAgICAgLy8gdGhlICoqLCBhbmQgc2VlIGlmIGl0IHdvdWxkIG1hdGNoIHRoZSBmaWxlIHJlbWFpbmRlci5cbiAgICAgIC8vIElmIHNvLCByZXR1cm4gc3VjY2Vzcy5cbiAgICAgIC8vIElmIG5vdCwgdGhlICoqIFwic3dhbGxvd3NcIiBhIHNlZ21lbnQsIGFuZCB0cnkgYWdhaW4uXG4gICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZWx5IGF3ZnVsLlxuICAgICAgLy9cbiAgICAgIC8vIGEvKiovYi8qKi9jIG1hdGNoaW5nIGEvYi94L3kvei9jXG4gICAgICAvLyAtIGEgbWF0Y2hlcyBhXG4gICAgICAvLyAtIGRvdWJsZXN0YXJcbiAgICAgIC8vICAgLSBtYXRjaE9uZShiL3gveS96L2MsIGIvKiovYylcbiAgICAgIC8vICAgICAtIGIgbWF0Y2hlcyBiXG4gICAgICAvLyAgICAgLSBkb3VibGVzdGFyXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHgveS96L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHkvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh6L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKGMsIGMpIHllcywgaGl0XG4gICAgICB2YXIgZnIgPSBmaVxuICAgICAgdmFyIHByID0gcGkgKyAxXG4gICAgICBpZiAocHIgPT09IHBsKSB7XG4gICAgICAgIHRoaXMuZGVidWcoJyoqIGF0IHRoZSBlbmQnKVxuICAgICAgICAvLyBhICoqIGF0IHRoZSBlbmQgd2lsbCBqdXN0IHN3YWxsb3cgdGhlIHJlc3QuXG4gICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYSBtYXRjaC5cbiAgICAgICAgLy8gaG93ZXZlciwgaXQgd2lsbCBub3Qgc3dhbGxvdyAvLngsIHVubGVzc1xuICAgICAgICAvLyBvcHRpb25zLmRvdCBpcyBzZXQuXG4gICAgICAgIC8vIC4gYW5kIC4uIGFyZSAqbmV2ZXIqIG1hdGNoZWQgYnkgKiosIGZvciBleHBsb3NpdmVseVxuICAgICAgICAvLyBleHBvbmVudGlhbCByZWFzb25zLlxuICAgICAgICBmb3IgKDsgZmkgPCBmbDsgZmkrKykge1xuICAgICAgICAgIGlmIChmaWxlW2ZpXSA9PT0gJy4nIHx8IGZpbGVbZmldID09PSAnLi4nIHx8XG4gICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIGZpbGVbZmldLmNoYXJBdCgwKSA9PT0gJy4nKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gb2ssIGxldCdzIHNlZSBpZiB3ZSBjYW4gc3dhbGxvdyB3aGF0ZXZlciB3ZSBjYW4uXG4gICAgICB3aGlsZSAoZnIgPCBmbCkge1xuICAgICAgICB2YXIgc3dhbGxvd2VlID0gZmlsZVtmcl1cblxuICAgICAgICB0aGlzLmRlYnVnKCdcXG5nbG9ic3RhciB3aGlsZScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwciwgc3dhbGxvd2VlKVxuXG4gICAgICAgIC8vIFhYWCByZW1vdmUgdGhpcyBzbGljZS4gIEp1c3QgcGFzcyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICAgIGlmICh0aGlzLm1hdGNoT25lKGZpbGUuc2xpY2UoZnIpLCBwYXR0ZXJuLnNsaWNlKHByKSwgcGFydGlhbCkpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBmb3VuZCBtYXRjaCEnLCBmciwgZmwsIHN3YWxsb3dlZSlcbiAgICAgICAgICAvLyBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FuJ3Qgc3dhbGxvdyBcIi5cIiBvciBcIi4uXCIgZXZlci5cbiAgICAgICAgICAvLyBjYW4gb25seSBzd2FsbG93IFwiLmZvb1wiIHdoZW4gZXhwbGljaXRseSBhc2tlZC5cbiAgICAgICAgICBpZiAoc3dhbGxvd2VlID09PSAnLicgfHwgc3dhbGxvd2VlID09PSAnLi4nIHx8XG4gICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIHN3YWxsb3dlZS5jaGFyQXQoMCkgPT09ICcuJykpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ2RvdCBkZXRlY3RlZCEnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vICoqIHN3YWxsb3dzIGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIHN3YWxsb3cgYSBzZWdtZW50LCBhbmQgY29udGludWUnKVxuICAgICAgICAgIGZyKytcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBubyBtYXRjaCB3YXMgZm91bmQuXG4gICAgICAvLyBIb3dldmVyLCBpbiBwYXJ0aWFsIG1vZGUsIHdlIGNhbid0IHNheSB0aGlzIGlzIG5lY2Vzc2FyaWx5IG92ZXIuXG4gICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgKnBhdHRlcm4qIGxlZnQsIHRoZW5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgLy8gcmFuIG91dCBvZiBmaWxlXG4gICAgICAgIHRoaXMuZGVidWcoJ1xcbj4+PiBubyBtYXRjaCwgcGFydGlhbD8nLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpXG4gICAgICAgIGlmIChmciA9PT0gZmwpIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBzb21ldGhpbmcgb3RoZXIgdGhhbiAqKlxuICAgIC8vIG5vbi1tYWdpYyBwYXR0ZXJucyBqdXN0IGhhdmUgdG8gbWF0Y2ggZXhhY3RseVxuICAgIC8vIHBhdHRlcm5zIHdpdGggbWFnaWMgaGF2ZSBiZWVuIHR1cm5lZCBpbnRvIHJlZ2V4cHMuXG4gICAgdmFyIGhpdFxuICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhpdCA9IGYgPT09IHBcbiAgICAgIHRoaXMuZGVidWcoJ3N0cmluZyBtYXRjaCcsIHAsIGYsIGhpdClcbiAgICB9IGVsc2Uge1xuICAgICAgaGl0ID0gZi5tYXRjaChwKVxuICAgICAgdGhpcy5kZWJ1ZygncGF0dGVybiBtYXRjaCcsIHAsIGYsIGhpdClcbiAgICB9XG5cbiAgICBpZiAoIWhpdCkgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBOb3RlOiBlbmRpbmcgaW4gLyBtZWFucyB0aGF0IHdlJ2xsIGdldCBhIGZpbmFsIFwiXCJcbiAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybi4gIFRoaXMgY2FuIG9ubHkgbWF0Y2ggYVxuICAvLyBjb3JyZXNwb25kaW5nIFwiXCIgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAgLy8gSWYgdGhlIGZpbGUgZW5kcyBpbiAvLCB0aGVuIGl0IGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gYSBwYXR0ZXJuIHRoYXQgZW5kcyBpbiAvLCB1bmxlc3MgdGhlIHBhdHRlcm4ganVzdFxuICAvLyBkb2Vzbid0IGhhdmUgYW55IG1vcmUgZm9yIGl0LiBCdXQsIGEvYi8gc2hvdWxkICpub3QqXG4gIC8vIG1hdGNoIFwiYS9iLypcIiwgZXZlbiB0aG91Z2ggXCJcIiBtYXRjaGVzIGFnYWluc3QgdGhlXG4gIC8vIFteL10qPyBwYXR0ZXJuLCBleGNlcHQgaW4gcGFydGlhbCBtb2RlLCB3aGVyZSBpdCBtaWdodFxuICAvLyBzaW1wbHkgbm90IGJlIHJlYWNoZWQgeWV0LlxuICAvLyBIb3dldmVyLCBhL2IvIHNob3VsZCBzdGlsbCBzYXRpc2Z5IGEvKlxuXG4gIC8vIG5vdyBlaXRoZXIgd2UgZmVsbCBvZmYgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiwgb3Igd2UncmUgZG9uZS5cbiAgaWYgKGZpID09PSBmbCAmJiBwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4gYW5kIGZpbGVuYW1lIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gYW4gZXhhY3QgaGl0IVxuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoZmkgPT09IGZsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBmaWxlLCBidXQgc3RpbGwgaGFkIHBhdHRlcm4gbGVmdC5cbiAgICAvLyB0aGlzIGlzIG9rIGlmIHdlJ3JlIGRvaW5nIHRoZSBtYXRjaCBhcyBwYXJ0IG9mXG4gICAgLy8gYSBnbG9iIGZzIHRyYXZlcnNhbC5cbiAgICByZXR1cm4gcGFydGlhbFxuICB9IGVsc2UgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi8gaWYgKHBpID09PSBwbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiwgc3RpbGwgaGF2ZSBmaWxlIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvbmx5IGFjY2VwdGFibGUgaWYgd2UncmUgb24gdGhlIHZlcnkgbGFzdFxuICAgIC8vIGVtcHR5IHNlZ21lbnQgb2YgYSBmaWxlIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAgICAvLyBhLyogc2hvdWxkIG1hdGNoIGEvYi9cbiAgICByZXR1cm4gKGZpID09PSBmbCAtIDEpICYmIChmaWxlW2ZpXSA9PT0gJycpXG4gIH1cblxuICAvLyBzaG91bGQgYmUgdW5yZWFjaGFibGUuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHRocm93IG5ldyBFcnJvcignd3RmPycpXG59XG5cbi8vIHJlcGxhY2Ugc3R1ZmYgbGlrZSBcXCogd2l0aCAqXG5mdW5jdGlvbiBnbG9iVW5lc2NhcGUgKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKVxufVxuXG5mdW5jdGlvbiByZWdFeHBFc2NhcGUgKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJtaW5pbWF0Y2giLCJNaW5pbWF0Y2giLCJwYXRoIiwicmVxdWlyZSIsImUiLCJzZXAiLCJHTE9CU1RBUiIsImV4cGFuZCIsInBsVHlwZXMiLCJvcGVuIiwiY2xvc2UiLCJxbWFyayIsInN0YXIiLCJ0d29TdGFyRG90IiwidHdvU3Rhck5vRG90IiwicmVTcGVjaWFscyIsImNoYXJTZXQiLCJzIiwic3BsaXQiLCJyZWR1Y2UiLCJzZXQiLCJjIiwic2xhc2hTcGxpdCIsImZpbHRlciIsInBhdHRlcm4iLCJvcHRpb25zIiwicCIsImkiLCJsaXN0IiwiZXh0IiwiYSIsImIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrIiwiZGVmYXVsdHMiLCJkZWYiLCJsZW5ndGgiLCJvcmlnIiwibSIsIm1ha2VSZSIsImJyYWNlRXhwYW5kIiwibWF0Y2giLCJhc3NlcnRWYWxpZFBhdHRlcm4iLCJub2NvbW1lbnQiLCJjaGFyQXQiLCJ0cmltIiwiYWxsb3dXaW5kb3dzRXNjYXBlIiwiam9pbiIsInJlZ2V4cCIsIm5lZ2F0ZSIsImNvbW1lbnQiLCJlbXB0eSIsInBhcnRpYWwiLCJtYWtlIiwicHJvdG90eXBlIiwiZGVidWciLCJwYXJzZU5lZ2F0ZSIsImdsb2JTZXQiLCJjb25zb2xlIiwiZXJyb3IiLCJhcHBseSIsImFyZ3VtZW50cyIsImdsb2JQYXJ0cyIsIm1hcCIsInNpIiwicGFyc2UiLCJpbmRleE9mIiwibmVnYXRlT2Zmc2V0Iiwibm9uZWdhdGUiLCJsIiwic3Vic3RyIiwibm9icmFjZSIsInRlc3QiLCJNQVhfUEFUVEVSTl9MRU5HVEgiLCJUeXBlRXJyb3IiLCJTVUJQQVJTRSIsImlzU3ViIiwibm9nbG9ic3RhciIsInJlIiwiaGFzTWFnaWMiLCJub2Nhc2UiLCJlc2NhcGluZyIsInBhdHRlcm5MaXN0U3RhY2siLCJuZWdhdGl2ZUxpc3RzIiwic3RhdGVDaGFyIiwiaW5DbGFzcyIsInJlQ2xhc3NTdGFydCIsImNsYXNzU3RhcnQiLCJwYXR0ZXJuU3RhcnQiLCJkb3QiLCJzZWxmIiwiY2xlYXJTdGF0ZUNoYXIiLCJsZW4iLCJub2V4dCIsInB1c2giLCJ0eXBlIiwic3RhcnQiLCJyZVN0YXJ0IiwicGwiLCJwb3AiLCJyZUVuZCIsImNzIiwic3Vic3RyaW5nIiwiUmVnRXhwIiwiZXIiLCJzcCIsInRhaWwiLCJzbGljZSIsInJlcGxhY2UiLCJfIiwiJDEiLCIkMiIsImFkZFBhdHRlcm5TdGFydCIsIm4iLCJubCIsIm5sQmVmb3JlIiwibmxGaXJzdCIsIm5sTGFzdCIsIm5sQWZ0ZXIiLCJvcGVuUGFyZW5zQmVmb3JlIiwiY2xlYW5BZnRlciIsImRvbGxhciIsIm5ld1JlIiwiZ2xvYlVuZXNjYXBlIiwiZmxhZ3MiLCJyZWdFeHAiLCJfZ2xvYiIsIl9zcmMiLCJ0d29TdGFyIiwicmVnRXhwRXNjYXBlIiwiZXgiLCJtbSIsImYiLCJub251bGwiLCJmaWxlbmFtZSIsImZpbGUiLCJtYXRjaEJhc2UiLCJoaXQiLCJtYXRjaE9uZSIsImZsaXBOZWdhdGUiLCJmaSIsInBpIiwiZmwiLCJmciIsInByIiwic3dhbGxvd2VlIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/minimatch.js\n");

/***/ })

};
;