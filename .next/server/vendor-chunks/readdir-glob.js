/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/readdir-glob";
exports.ids = ["vendor-chunks/readdir-glob"];
exports.modules = {

/***/ "(ssr)/./node_modules/readdir-glob/index.js":
/*!********************************************!*\
  !*** ./node_modules/readdir-glob/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = readdirGlob;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\");\nconst { Minimatch } = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/readdir-glob/node_modules/minimatch/minimatch.js\");\nconst { resolve } = __webpack_require__(/*! path */ \"path\");\nfunction readdir(dir, strict) {\n    return new Promise((resolve, reject)=>{\n        fs.readdir(dir, {\n            withFileTypes: true\n        }, (err, files)=>{\n            if (err) {\n                switch(err.code){\n                    case \"ENOTDIR\":\n                        if (strict) {\n                            reject(err);\n                        } else {\n                            resolve([]);\n                        }\n                        break;\n                    case \"ENOTSUP\":\n                    case \"ENOENT\":\n                    case \"ENAMETOOLONG\":\n                    case \"UNKNOWN\":\n                        resolve([]);\n                        break;\n                    case \"ELOOP\":\n                    default:\n                        reject(err);\n                        break;\n                }\n            } else {\n                resolve(files);\n            }\n        });\n    });\n}\nfunction stat(file, followSymlinks) {\n    return new Promise((resolve, reject)=>{\n        const statFunc = followSymlinks ? fs.stat : fs.lstat;\n        statFunc(file, (err, stats)=>{\n            if (err) {\n                switch(err.code){\n                    case \"ENOENT\":\n                        if (followSymlinks) {\n                            // Fallback to lstat to handle broken links as files\n                            resolve(stat(file, false));\n                        } else {\n                            resolve(null);\n                        }\n                        break;\n                    default:\n                        resolve(null);\n                        break;\n                }\n            } else {\n                resolve(stats);\n            }\n        });\n    });\n}\nasync function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {\n    let files = await readdir(path + dir, strict);\n    for (const file of files){\n        let name = file.name;\n        if (name === undefined) {\n            // undefined file.name means the `withFileTypes` options is not supported by node\n            // we have to call the stat function to know if file is directory or not.\n            name = file;\n            useStat = true;\n        }\n        const filename = dir + \"/\" + name;\n        const relative = filename.slice(1); // Remove the leading /\n        const absolute = path + \"/\" + relative;\n        let stats = null;\n        if (useStat || followSymlinks) {\n            stats = await stat(absolute, followSymlinks);\n        }\n        if (!stats && file.name !== undefined) {\n            stats = file;\n        }\n        if (stats === null) {\n            stats = {\n                isDirectory: ()=>false\n            };\n        }\n        if (stats.isDirectory()) {\n            if (!shouldSkip(relative)) {\n                yield {\n                    relative,\n                    absolute,\n                    stats\n                };\n                yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, false);\n            }\n        } else {\n            yield {\n                relative,\n                absolute,\n                stats\n            };\n        }\n    }\n}\nasync function* explore(path, followSymlinks, useStat, shouldSkip) {\n    yield* exploreWalkAsync(\"\", path, followSymlinks, useStat, shouldSkip, true);\n}\nfunction readOptions(options) {\n    return {\n        pattern: options.pattern,\n        dot: !!options.dot,\n        noglobstar: !!options.noglobstar,\n        matchBase: !!options.matchBase,\n        nocase: !!options.nocase,\n        ignore: options.ignore,\n        skip: options.skip,\n        follow: !!options.follow,\n        stat: !!options.stat,\n        nodir: !!options.nodir,\n        mark: !!options.mark,\n        silent: !!options.silent,\n        absolute: !!options.absolute\n    };\n}\nclass ReaddirGlob extends EventEmitter {\n    constructor(cwd, options, cb){\n        super();\n        if (typeof options === \"function\") {\n            cb = options;\n            options = null;\n        }\n        this.options = readOptions(options || {});\n        this.matchers = [];\n        if (this.options.pattern) {\n            const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [\n                this.options.pattern\n            ];\n            this.matchers = matchers.map((m)=>new Minimatch(m, {\n                    dot: this.options.dot,\n                    noglobstar: this.options.noglobstar,\n                    matchBase: this.options.matchBase,\n                    nocase: this.options.nocase\n                }));\n        }\n        this.ignoreMatchers = [];\n        if (this.options.ignore) {\n            const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [\n                this.options.ignore\n            ];\n            this.ignoreMatchers = ignorePatterns.map((ignore)=>new Minimatch(ignore, {\n                    dot: true\n                }));\n        }\n        this.skipMatchers = [];\n        if (this.options.skip) {\n            const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [\n                this.options.skip\n            ];\n            this.skipMatchers = skipPatterns.map((skip)=>new Minimatch(skip, {\n                    dot: true\n                }));\n        }\n        this.iterator = explore(resolve(cwd || \".\"), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));\n        this.paused = false;\n        this.inactive = false;\n        this.aborted = false;\n        if (cb) {\n            this._matches = [];\n            this.on(\"match\", (match)=>this._matches.push(this.options.absolute ? match.absolute : match.relative));\n            this.on(\"error\", (err)=>cb(err));\n            this.on(\"end\", ()=>cb(null, this._matches));\n        }\n        setTimeout(()=>this._next(), 0);\n    }\n    _shouldSkipDirectory(relative) {\n        //console.log(relative, this.skipMatchers.some(m => m.match(relative)));\n        return this.skipMatchers.some((m)=>m.match(relative));\n    }\n    _fileMatches(relative, isDirectory) {\n        const file = relative + (isDirectory ? \"/\" : \"\");\n        return (this.matchers.length === 0 || this.matchers.some((m)=>m.match(file))) && !this.ignoreMatchers.some((m)=>m.match(file)) && (!this.options.nodir || !isDirectory);\n    }\n    _next() {\n        if (!this.paused && !this.aborted) {\n            this.iterator.next().then((obj)=>{\n                if (!obj.done) {\n                    const isDirectory = obj.value.stats.isDirectory();\n                    if (this._fileMatches(obj.value.relative, isDirectory)) {\n                        let relative = obj.value.relative;\n                        let absolute = obj.value.absolute;\n                        if (this.options.mark && isDirectory) {\n                            relative += \"/\";\n                            absolute += \"/\";\n                        }\n                        if (this.options.stat) {\n                            this.emit(\"match\", {\n                                relative,\n                                absolute,\n                                stat: obj.value.stats\n                            });\n                        } else {\n                            this.emit(\"match\", {\n                                relative,\n                                absolute\n                            });\n                        }\n                    }\n                    this._next(this.iterator);\n                } else {\n                    this.emit(\"end\");\n                }\n            }).catch((err)=>{\n                this.abort();\n                this.emit(\"error\", err);\n                if (!err.code && !this.options.silent) {\n                    console.error(err);\n                }\n            });\n        } else {\n            this.inactive = true;\n        }\n    }\n    abort() {\n        this.aborted = true;\n    }\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        this.paused = false;\n        if (this.inactive) {\n            this.inactive = false;\n            this._next();\n        }\n    }\n}\nfunction readdirGlob(pattern, options, cb) {\n    return new ReaddirGlob(pattern, options, cb);\n}\nreaddirGlob.ReaddirGlob = ReaddirGlob;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLE1BQU1DLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ25CLE1BQU0sRUFBRUMsWUFBWSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRUUsU0FBUyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU0sRUFBRUcsT0FBTyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBRTVCLFNBQVNJLFFBQVFDLEdBQUcsRUFBRUMsTUFBTTtJQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0osU0FBU0s7UUFDM0JULEdBQUdLLE9BQU8sQ0FBQ0MsS0FBSztZQUFDSSxlQUFlO1FBQUksR0FBRyxDQUFDQyxLQUFLQztZQUMzQyxJQUFHRCxLQUFLO2dCQUNOLE9BQVFBLElBQUlFLElBQUk7b0JBQ2QsS0FBSzt3QkFDSCxJQUFHTixRQUFROzRCQUNURSxPQUFPRTt3QkFDVCxPQUFPOzRCQUNMUCxRQUFRLEVBQUU7d0JBQ1o7d0JBQ0E7b0JBQ0YsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSEEsUUFBUSxFQUFFO3dCQUNWO29CQUNGLEtBQUs7b0JBQ0w7d0JBQ0VLLE9BQU9FO3dCQUNQO2dCQUNKO1lBQ0YsT0FBTztnQkFDTFAsUUFBUVE7WUFDVjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNFLEtBQUtDLElBQUksRUFBRUMsY0FBYztJQUNoQyxPQUFPLElBQUlSLFFBQVEsQ0FBQ0osU0FBU0s7UUFDM0IsTUFBTVEsV0FBV0QsaUJBQWlCaEIsR0FBR2MsSUFBSSxHQUFHZCxHQUFHa0IsS0FBSztRQUNwREQsU0FBU0YsTUFBTSxDQUFDSixLQUFLUTtZQUNuQixJQUFHUixLQUFLO2dCQUNOLE9BQVFBLElBQUlFLElBQUk7b0JBQ2QsS0FBSzt3QkFDSCxJQUFHRyxnQkFBZ0I7NEJBQ2pCLG9E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Q0FBQ3dDLEtBQUssQ0FBQyxJQUFJLENBQUNYLFFBQVE7Z0JBQzFCLE9BQU87b0JBQ0wsSUFBSSxDQUFDb0IsSUFBSSxDQUFDO2dCQUNaO1lBQ0YsR0FDQ0MsS0FBSyxDQUFDLENBQUNwRTtnQkFDTixJQUFJLENBQUNxRSxLQUFLO2dCQUNWLElBQUksQ0FBQ0YsSUFBSSxDQUFDLFNBQVNuRTtnQkFDbkIsSUFBRyxDQUFDQSxJQUFJRSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUNvQixPQUFPLENBQUNXLE1BQU0sRUFBRTtvQkFDcENxQyxRQUFRQyxLQUFLLENBQUN2RTtnQkFDaEI7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNtRCxRQUFRLEdBQUc7UUFDbEI7SUFDRjtJQUVBa0IsUUFBUTtRQUNOLElBQUksQ0FBQ2pCLE9BQU8sR0FBRztJQUNqQjtJQUVBb0IsUUFBUTtRQUNOLElBQUksQ0FBQ3RCLE1BQU0sR0FBRztJQUNoQjtJQUVBdUIsU0FBUztRQUNQLElBQUksQ0FBQ3ZCLE1BQU0sR0FBRztRQUNkLElBQUcsSUFBSSxDQUFDQyxRQUFRLEVBQUU7WUFDaEIsSUFBSSxDQUFDQSxRQUFRLEdBQUc7WUFDaEIsSUFBSSxDQUFDTyxLQUFLO1FBQ1o7SUFDRjtBQUNGO0FBR0EsU0FBU3RFLFlBQVltQyxPQUFPLEVBQUVELE9BQU8sRUFBRWUsRUFBRTtJQUN2QyxPQUFPLElBQUlILFlBQVlYLFNBQVNELFNBQVNlO0FBQzNDO0FBQ0FqRCxZQUFZOEMsV0FBVyxHQUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NkLXRpbWVzaGVldC1hbmFseXplci8uL25vZGVfbW9kdWxlcy9yZWFkZGlyLWdsb2IvaW5kZXguanM/ZjU0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlYWRkaXJHbG9iO1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCB7IE1pbmltYXRjaCB9ID0gcmVxdWlyZSgnbWluaW1hdGNoJyk7XG5jb25zdCB7IHJlc29sdmUgfSA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuZnVuY3Rpb24gcmVhZGRpcihkaXIsIHN0cmljdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWRkaXIoZGlyLCB7d2l0aEZpbGVUeXBlczogdHJ1ZX0gLChlcnIsIGZpbGVzKSA9PiB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgIGNhc2UgJ0VOT1RESVInOiAgICAgIC8vIE5vdCBhIGRpcmVjdG9yeVxuICAgICAgICAgICAgaWYoc3RyaWN0KSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFTk9UU1VQJzogICAgICAvLyBPcGVyYXRpb24gbm90IHN1cHBvcnRlZFxuICAgICAgICAgIGNhc2UgJ0VOT0VOVCc6ICAgICAgIC8vIE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcbiAgICAgICAgICBjYXNlICdFTkFNRVRPT0xPTkcnOiAvLyBGaWxlbmFtZSB0b28gbG9uZ1xuICAgICAgICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFTE9PUCc6ICAgICAgICAvLyBUb28gbWFueSBsZXZlbHMgb2Ygc3ltYm9saWMgbGlua3NcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShmaWxlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3RhdChmaWxlLCBmb2xsb3dTeW1saW5rcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHN0YXRGdW5jID0gZm9sbG93U3ltbGlua3MgPyBmcy5zdGF0IDogZnMubHN0YXQ7XG4gICAgc3RhdEZ1bmMoZmlsZSwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgY2FzZSAnRU5PRU5UJzpcbiAgICAgICAgICAgIGlmKGZvbGxvd1N5bWxpbmtzKSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGxzdGF0IHRvIGhhbmRsZSBicm9rZW4gbGlua3MgYXMgZmlsZXNcbiAgICAgICAgICAgICAgcmVzb2x2ZShzdGF0KGZpbGUsIGZhbHNlKSk7IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoc3RhdHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIGV4cGxvcmVXYWxrQXN5bmMoZGlyLCBwYXRoLCBmb2xsb3dTeW1saW5rcywgdXNlU3RhdCwgc2hvdWxkU2tpcCwgc3RyaWN0KSB7XG4gIGxldCBmaWxlcyA9IGF3YWl0IHJlYWRkaXIocGF0aCArIGRpciwgc3RyaWN0KTtcbiAgZm9yKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICBsZXQgbmFtZSA9IGZpbGUubmFtZTtcbiAgICBpZihuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHVuZGVmaW5lZCBmaWxlLm5hbWUgbWVhbnMgdGhlIGB3aXRoRmlsZVR5cGVzYCBvcHRpb25zIGlzIG5vdCBzdXBwb3J0ZWQgYnkgbm9kZVxuICAgICAgLy8gd2UgaGF2ZSB0byBjYWxsIHRoZSBzdGF0IGZ1bmN0aW9uIHRvIGtub3cgaWYgZmlsZSBpcyBkaXJlY3Rvcnkgb3Igbm90LlxuICAgICAgbmFtZSA9IGZpbGU7XG4gICAgICB1c2VTdGF0ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZmlsZW5hbWUgPSBkaXIgKyAnLycgKyBuYW1lO1xuICAgIGNvbnN0IHJlbGF0aXZlID0gZmlsZW5hbWUuc2xpY2UoMSk7IC8vIFJlbW92ZSB0aGUgbGVhZGluZyAvXG4gICAgY29uc3QgYWJzb2x1dGUgPSBwYXRoICsgJy8nICsgcmVsYXRpdmU7XG4gICAgbGV0IHN0YXRzID0gbnVsbDtcbiAgICBpZih1c2VTdGF0IHx8IGZvbGxvd1N5bWxpbmtzKSB7XG4gICAgICBzdGF0cyA9IGF3YWl0IHN0YXQoYWJzb2x1dGUsIGZvbGxvd1N5bWxpbmtzKTtcbiAgICB9XG4gICAgaWYoIXN0YXRzICYmIGZpbGUubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGF0cyA9IGZpbGU7XG4gICAgfVxuICAgIGlmKHN0YXRzID09PSBudWxsKSB7XG4gICAgICBzdGF0cyA9IHsgaXNEaXJlY3Rvcnk6ICgpID0+IGZhbHNlIH07XG4gICAgfVxuXG4gICAgaWYoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgaWYoIXNob3VsZFNraXAocmVsYXRpdmUpKSB7XG4gICAgICAgIHlpZWxkIHtyZWxhdGl2ZSwgYWJzb2x1dGUsIHN0YXRzfTtcbiAgICAgICAgeWllbGQqIGV4cGxvcmVXYWxrQXN5bmMoZmlsZW5hbWUsIHBhdGgsIGZvbGxvd1N5bWxpbmtzLCB1c2VTdGF0LCBzaG91bGRTa2lwLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHlpZWxkIHtyZWxhdGl2ZSwgYWJzb2x1dGUsIHN0YXRzfTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiBleHBsb3JlKHBhdGgsIGZvbGxvd1N5bWxpbmtzLCB1c2VTdGF0LCBzaG91bGRTa2lwKSB7XG4gIHlpZWxkKiBleHBsb3JlV2Fsa0FzeW5jKCcnLCBwYXRoLCBmb2xsb3dTeW1saW5rcywgdXNlU3RhdCwgc2hvdWxkU2tpcCwgdHJ1ZSk7XG59XG5cblxuZnVuY3Rpb24gcmVhZE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHBhdHRlcm46IG9wdGlvbnMucGF0dGVybixcbiAgICBkb3Q6ICEhb3B0aW9ucy5kb3QsXG4gICAgbm9nbG9ic3RhcjogISFvcHRpb25zLm5vZ2xvYnN0YXIsXG4gICAgbWF0Y2hCYXNlOiAhIW9wdGlvbnMubWF0Y2hCYXNlLFxuICAgIG5vY2FzZTogISFvcHRpb25zLm5vY2FzZSxcbiAgICBpZ25vcmU6IG9wdGlvbnMuaWdub3JlLFxuICAgIHNraXA6IG9wdGlvbnMuc2tpcCxcblxuICAgIGZvbGxvdzogISFvcHRpb25zLmZvbGxvdyxcbiAgICBzdGF0OiAhIW9wdGlvbnMuc3RhdCxcbiAgICBub2RpcjogISFvcHRpb25zLm5vZGlyLFxuICAgIG1hcms6ICEhb3B0aW9ucy5tYXJrLFxuICAgIHNpbGVudDogISFvcHRpb25zLnNpbGVudCxcbiAgICBhYnNvbHV0ZTogISFvcHRpb25zLmFic29sdXRlXG4gIH07XG59XG5cbmNsYXNzIFJlYWRkaXJHbG9iIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoY3dkLCBvcHRpb25zLCBjYikge1xuICAgIHN1cGVyKCk7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IHJlYWRPcHRpb25zKG9wdGlvbnMgfHzCoHt9KTtcbiAgXG4gICAgdGhpcy5tYXRjaGVycyA9IFtdO1xuICAgIGlmKHRoaXMub3B0aW9ucy5wYXR0ZXJuKSB7XG4gICAgICBjb25zdCBtYXRjaGVycyA9IEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnBhdHRlcm4pID8gdGhpcy5vcHRpb25zLnBhdHRlcm4gOiBbdGhpcy5vcHRpb25zLnBhdHRlcm5dO1xuICAgICAgdGhpcy5tYXRjaGVycyA9IG1hdGNoZXJzLm1hcCggbSA9PlxuICAgICAgICBuZXcgTWluaW1hdGNoKG0sIHtcbiAgICAgICAgICBkb3Q6IHRoaXMub3B0aW9ucy5kb3QsXG4gICAgICAgICAgbm9nbG9ic3Rhcjp0aGlzLm9wdGlvbnMubm9nbG9ic3RhcixcbiAgICAgICAgICBtYXRjaEJhc2U6dGhpcy5vcHRpb25zLm1hdGNoQmFzZSxcbiAgICAgICAgICBub2Nhc2U6dGhpcy5vcHRpb25zLm5vY2FzZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIFxuICAgIHRoaXMuaWdub3JlTWF0Y2hlcnMgPSBbXTtcbiAgICBpZih0aGlzLm9wdGlvbnMuaWdub3JlKSB7XG4gICAgICBjb25zdCBpZ25vcmVQYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmlnbm9yZSkgPyB0aGlzLm9wdGlvbnMuaWdub3JlIDogW3RoaXMub3B0aW9ucy5pZ25vcmVdO1xuICAgICAgdGhpcy5pZ25vcmVNYXRjaGVycyA9IGlnbm9yZVBhdHRlcm5zLm1hcCggaWdub3JlID0+XG4gICAgICAgIG5ldyBNaW5pbWF0Y2goaWdub3JlLCB7ZG90OiB0cnVlfSlcbiAgICAgICk7XG4gICAgfVxuICBcbiAgICB0aGlzLnNraXBNYXRjaGVycyA9IFtdO1xuICAgIGlmKHRoaXMub3B0aW9ucy5za2lwKSB7XG4gICAgICBjb25zdCBza2lwUGF0dGVybnMgPSBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5za2lwKSA/IHRoaXMub3B0aW9ucy5za2lwIDogW3RoaXMub3B0aW9ucy5za2lwXTtcbiAgICAgIHRoaXMuc2tpcE1hdGNoZXJzID0gc2tpcFBhdHRlcm5zLm1hcCggc2tpcCA9PlxuICAgICAgICBuZXcgTWluaW1hdGNoKHNraXAsIHtkb3Q6IHRydWV9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLml0ZXJhdG9yID0gZXhwbG9yZShyZXNvbHZlKGN3ZCB8fCAnLicpLCB0aGlzLm9wdGlvbnMuZm9sbG93LCB0aGlzLm9wdGlvbnMuc3RhdCwgdGhpcy5fc2hvdWxkU2tpcERpcmVjdG9yeS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgXG4gICAgaWYoY2IpIHtcbiAgICAgIHRoaXMuX21hdGNoZXMgPSBbXTsgXG4gICAgICB0aGlzLm9uKCdtYXRjaCcsIG1hdGNoID0+IHRoaXMuX21hdGNoZXMucHVzaCh0aGlzLm9wdGlvbnMuYWJzb2x1dGUgPyBtYXRjaC5hYnNvbHV0ZSA6IG1hdGNoLnJlbGF0aXZlKSk7XG4gICAgICB0aGlzLm9uKCdlcnJvcicsIGVyciA9PiBjYihlcnIpKTtcbiAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IGNiKG51bGwsIHRoaXMuX21hdGNoZXMpKTtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCAoKSA9PiB0aGlzLl9uZXh0KCksIDApO1xuICB9XG5cbiAgX3Nob3VsZFNraXBEaXJlY3RvcnkocmVsYXRpdmUpIHtcbiAgICAvL2NvbnNvbGUubG9nKHJlbGF0aXZlLCB0aGlzLnNraXBNYXRjaGVycy5zb21lKG0gPT4gbS5tYXRjaChyZWxhdGl2ZSkpKTtcbiAgICByZXR1cm4gdGhpcy5za2lwTWF0Y2hlcnMuc29tZShtID0+IG0ubWF0Y2gocmVsYXRpdmUpKTtcbiAgfVxuXG4gIF9maWxlTWF0Y2hlcyhyZWxhdGl2ZSwgaXNEaXJlY3RvcnkpIHtcbiAgICBjb25zdCBmaWxlID0gcmVsYXRpdmUgKyAoaXNEaXJlY3RvcnkgPyAnLycgOiAnJyk7XG4gICAgcmV0dXJuICh0aGlzLm1hdGNoZXJzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLm1hdGNoZXJzLnNvbWUobSA9PiBtLm1hdGNoKGZpbGUpKSlcbiAgICAgICYmICF0aGlzLmlnbm9yZU1hdGNoZXJzLnNvbWUobSA9PiBtLm1hdGNoKGZpbGUpKVxuICAgICAgJiYgKCF0aGlzLm9wdGlvbnMubm9kaXIgfHwgIWlzRGlyZWN0b3J5KTtcbiAgfVxuXG4gIF9uZXh0KCkge1xuICAgIGlmKCF0aGlzLnBhdXNlZCAmJiAhdGhpcy5hYm9ydGVkKSB7XG4gICAgICB0aGlzLml0ZXJhdG9yLm5leHQoKVxuICAgICAgLnRoZW4oKG9iaik9PiB7XG4gICAgICAgIGlmKCFvYmouZG9uZSkge1xuICAgICAgICAgIGNvbnN0IGlzRGlyZWN0b3J5ID0gb2JqLnZhbHVlLnN0YXRzLmlzRGlyZWN0b3J5KCk7XG4gICAgICAgICAgaWYodGhpcy5fZmlsZU1hdGNoZXMob2JqLnZhbHVlLnJlbGF0aXZlLCBpc0RpcmVjdG9yeSApKSB7XG4gICAgICAgICAgICBsZXQgcmVsYXRpdmUgPSBvYmoudmFsdWUucmVsYXRpdmU7XG4gICAgICAgICAgICBsZXQgYWJzb2x1dGUgPSBvYmoudmFsdWUuYWJzb2x1dGU7XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMubWFyayAmJiBpc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICByZWxhdGl2ZSArPSAnLyc7XG4gICAgICAgICAgICAgIGFic29sdXRlICs9ICcvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zdGF0KSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWF0Y2gnLCB7cmVsYXRpdmUsIGFic29sdXRlLCBzdGF0Om9iai52YWx1ZS5zdGF0c30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtYXRjaCcsIHtyZWxhdGl2ZSwgYWJzb2x1dGV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbmV4dCh0aGlzLml0ZXJhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgaWYoIWVyci5jb2RlICYmICF0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHJlc3VtZSgpIHtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIGlmKHRoaXMuaW5hY3RpdmUpIHtcbiAgICAgIHRoaXMuaW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25leHQoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkZGlyR2xvYihwYXR0ZXJuLCBvcHRpb25zLCBjYikge1xuICByZXR1cm4gbmV3IFJlYWRkaXJHbG9iKHBhdHRlcm4sIG9wdGlvbnMsIGNiKTtcbn1cbnJlYWRkaXJHbG9iLlJlYWRkaXJHbG9iID0gUmVhZGRpckdsb2I7Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZWFkZGlyR2xvYiIsImZzIiwicmVxdWlyZSIsIkV2ZW50RW1pdHRlciIsIk1pbmltYXRjaCIsInJlc29sdmUiLCJyZWFkZGlyIiwiZGlyIiwic3RyaWN0IiwiUHJvbWlzZSIsInJlamVjdCIsIndpdGhGaWxlVHlwZXMiLCJlcnIiLCJmaWxlcyIsImNvZGUiLCJzdGF0IiwiZmlsZSIsImZvbGxvd1N5bWxpbmtzIiwic3RhdEZ1bmMiLCJsc3RhdCIsInN0YXRzIiwiZXhwbG9yZVdhbGtBc3luYyIsInBhdGgiLCJ1c2VTdGF0Iiwic2hvdWxkU2tpcCIsIm5hbWUiLCJ1bmRlZmluZWQiLCJmaWxlbmFtZSIsInJlbGF0aXZlIiwic2xpY2UiLCJhYnNvbHV0ZSIsImlzRGlyZWN0b3J5IiwiZXhwbG9yZSIsInJlYWRPcHRpb25zIiwib3B0aW9ucyIsInBhdHRlcm4iLCJkb3QiLCJub2dsb2JzdGFyIiwibWF0Y2hCYXNlIiwibm9jYXNlIiwiaWdub3JlIiwic2tpcCIsImZvbGxvdyIsIm5vZGlyIiwibWFyayIsInNpbGVudCIsIlJlYWRkaXJHbG9iIiwiY29uc3RydWN0b3IiLCJjd2QiLCJjYiIsIm1hdGNoZXJzIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwibSIsImlnbm9yZU1hdGNoZXJzIiwiaWdub3JlUGF0dGVybnMiLCJza2lwTWF0Y2hlcnMiLCJza2lwUGF0dGVybnMiLCJpdGVyYXRvciIsIl9zaG91bGRTa2lwRGlyZWN0b3J5IiwiYmluZCIsInBhdXNlZCIsImluYWN0aXZlIiwiYWJvcnRlZCIsIl9tYXRjaGVzIiwib24iLCJtYXRjaCIsInB1c2giLCJzZXRUaW1lb3V0IiwiX25leHQiLCJzb21lIiwiX2ZpbGVNYXRjaGVzIiwibGVuZ3RoIiwibmV4dCIsInRoZW4iLCJvYmoiLCJkb25lIiwidmFsdWUiLCJlbWl0IiwiY2F0Y2giLCJhYm9ydCIsImNvbnNvbGUiLCJlcnJvciIsInBhdXNlIiwicmVzdW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readdir-glob/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readdir-glob/node_modules/brace-expansion/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readdir-glob/node_modules/brace-expansion/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var balanced = __webpack_require__(/*! balanced-match */ \"(ssr)/./node_modules/balanced-match/index.js\");\nmodule.exports = expandTop;\nvar escSlash = \"\\x00SLASH\" + Math.random() + \"\\x00\";\nvar escOpen = \"\\x00OPEN\" + Math.random() + \"\\x00\";\nvar escClose = \"\\x00CLOSE\" + Math.random() + \"\\x00\";\nvar escComma = \"\\x00COMMA\" + Math.random() + \"\\x00\";\nvar escPeriod = \"\\x00PERIOD\" + Math.random() + \"\\x00\";\nfunction numeric(str) {\n    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str.split(\"\\\\\\\\\").join(escSlash).split(\"\\\\{\").join(escOpen).split(\"\\\\}\").join(escClose).split(\"\\\\,\").join(escComma).split(\"\\\\.\").join(escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str.split(escSlash).join(\"\\\\\").split(escOpen).join(\"{\").split(escClose).join(\"}\").split(escComma).join(\",\").split(escPeriod).join(\".\");\n}\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n    if (!str) return [\n        \"\"\n    ];\n    var parts = [];\n    var m = balanced(\"{\", \"}\", str);\n    if (!m) return str.split(\",\");\n    var pre = m.pre;\n    var body = m.body;\n    var post = m.post;\n    var p = pre.split(\",\");\n    p[p.length - 1] += \"{\" + body + \"}\";\n    var postParts = parseCommaParts(post);\n    if (post.length) {\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nfunction expandTop(str) {\n    if (!str) return [];\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.substr(0, 2) === \"{}\") {\n        str = \"\\\\{\\\\}\" + str.substr(2);\n    }\n    return expand(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return \"{\" + str + \"}\";\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand(str, isTop) {\n    var expansions = [];\n    var m = balanced(\"{\", \"}\", str);\n    if (!m) return [\n        str\n    ];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    var pre = m.pre;\n    var post = m.post.length ? expand(m.post, false) : [\n        \"\"\n    ];\n    if (/\\$$/.test(m.pre)) {\n        for(var k = 0; k < post.length; k++){\n            var expansion = pre + \"{\" + m.body + \"}\" + post[k];\n            expansions.push(expansion);\n        }\n    } else {\n        var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        var isSequence = isNumericSequence || isAlphaSequence;\n        var isOptions = m.body.indexOf(\",\") >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,.*\\}/)) {\n                str = m.pre + \"{\" + m.body + escClose + m.post;\n                return expand(str);\n            }\n            return [\n                str\n            ];\n        }\n        var n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        } else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand(n[0], false).map(embrace);\n                if (n.length === 1) {\n                    return post.map(function(p) {\n                        return m.pre + n[0] + p;\n                    });\n                }\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        var N;\n        if (isSequence) {\n            var x = numeric(n[0]);\n            var y = numeric(n[1]);\n            var width = Math.max(n[0].length, n[1].length);\n            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n            var test = lte;\n            var reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            var pad = n.some(isPadded);\n            N = [];\n            for(var i = x; test(i, y); i += incr){\n                var c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === \"\\\\\") c = \"\";\n                } else {\n                    c = String(i);\n                    if (pad) {\n                        var need = width - c.length;\n                        if (need > 0) {\n                            var z = new Array(need + 1).join(\"0\");\n                            if (i < 0) c = \"-\" + z + c.slice(1);\n                            else c = z + c;\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        } else {\n            N = [];\n            for(var j = 0; j < n.length; j++){\n                N.push.apply(N, expand(n[j], false));\n            }\n        }\n        for(var j = 0; j < N.length; j++){\n            for(var k = 0; k < post.length; k++){\n                var expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) expansions.push(expansion);\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsV0FBV0MsbUJBQU9BLENBQUM7QUFFdkJDLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsV0FBVyxjQUFVQyxLQUFLQyxNQUFNLEtBQUc7QUFDdkMsSUFBSUMsVUFBVSxhQUFTRixLQUFLQyxNQUFNLEtBQUc7QUFDckMsSUFBSUUsV0FBVyxjQUFVSCxLQUFLQyxNQUFNLEtBQUc7QUFDdkMsSUFBSUcsV0FBVyxjQUFVSixLQUFLQyxNQUFNLEtBQUc7QUFDdkMsSUFBSUksWUFBWSxlQUFXTCxLQUFLQyxNQUFNLEtBQUc7QUFFekMsU0FBU0ssUUFBUUMsR0FBRztJQUNsQixPQUFPQyxTQUFTRCxLQUFLLE9BQU9BLE1BQ3hCQyxTQUFTRCxLQUFLLE1BQ2RBLElBQUlFLFVBQVUsQ0FBQztBQUNyQjtBQUVBLFNBQVNDLGFBQWFILEdBQUc7SUFDdkIsT0FBT0EsSUFBSUksS0FBSyxDQUFDLFFBQVFDLElBQUksQ0FBQ2IsVUFDbkJZLEtBQUssQ0FBQyxPQUFPQyxJQUFJLENBQUNWLFNBQ2xCUyxLQUFLLENBQUMsT0FBT0MsSUFBSSxDQUFDVCxVQUNsQlEsS0FBSyxDQUFDLE9BQU9DLElBQUksQ0FBQ1IsVUFDbEJPLEtBQUssQ0FBQyxPQUFPQyxJQUFJLENBQUNQO0FBQy9CO0FBRUEsU0FBU1EsZUFBZU4sR0FBRztJQUN6QixPQUFPQSxJQUFJSSxLQUFLLENBQUNaLFVBQVVhLElBQUksQ0FBQyxNQUNyQkQsS0FBSyxDQUFDVCxTQUFTVSxJQUFJLENBQUMsS0FDcEJELEtBQUssQ0FBQ1IsVUFBVVMsSUFBSSxDQUFDLEtBQ3JCRCxLQUFLLENBQUNQLFVBQVVRLElBQUksQ0FBQyxLQUNyQkQsS0FBSyxDQUFDTixXQUFXTyxJQUFJLENBQUM7QUFDbkM7QUFHQSxvREFBb0Q7QUFDcEQsd0RBQXdEO0FBQ3hE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Q0FBQ2dCO1lBQ3BCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9GO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZC10aW1lc2hlZXQtYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanM/MWZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFsYW5jZWQgPSByZXF1aXJlKCdiYWxhbmNlZC1tYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cGFuZFRvcDtcblxudmFyIGVzY1NsYXNoID0gJ1xcMFNMQVNIJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY09wZW4gPSAnXFwwT1BFTicrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDbG9zZSA9ICdcXDBDTE9TRScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDb21tYSA9ICdcXDBDT01NQScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NQZXJpb2QgPSAnXFwwUEVSSU9EJytNYXRoLnJhbmRvbSgpKydcXDAnO1xuXG5mdW5jdGlvbiBudW1lcmljKHN0cikge1xuICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCkgPT0gc3RyXG4gICAgPyBwYXJzZUludChzdHIsIDEwKVxuICAgIDogc3RyLmNoYXJDb2RlQXQoMCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnXFxcXFxcXFwnKS5qb2luKGVzY1NsYXNoKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxceycpLmpvaW4oZXNjT3BlbilcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXH0nKS5qb2luKGVzY0Nsb3NlKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLCcpLmpvaW4oZXNjQ29tbWEpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwuJykuam9pbihlc2NQZXJpb2QpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdChlc2NTbGFzaCkuam9pbignXFxcXCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjT3Blbikuam9pbigneycpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ2xvc2UpLmpvaW4oJ30nKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0NvbW1hKS5qb2luKCcsJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NQZXJpb2QpLmpvaW4oJy4nKTtcbn1cblxuXG4vLyBCYXNpY2FsbHkganVzdCBzdHIuc3BsaXQoXCIsXCIpLCBidXQgaGFuZGxpbmcgY2FzZXNcbi8vIHdoZXJlIHdlIGhhdmUgbmVzdGVkIGJyYWNlZCBzZWN0aW9ucywgd2hpY2ggc2hvdWxkIGJlXG4vLyB0cmVhdGVkIGFzIGluZGl2aWR1YWwgbWVtYmVycywgbGlrZSB7YSx7YixjfSxkfVxuZnVuY3Rpb24gcGFyc2VDb21tYVBhcnRzKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gWycnXTtcblxuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcblxuICBpZiAoIW0pXG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnLCcpO1xuXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIGJvZHkgPSBtLmJvZHk7XG4gIHZhciBwb3N0ID0gbS5wb3N0O1xuICB2YXIgcCA9IHByZS5zcGxpdCgnLCcpO1xuXG4gIHBbcC5sZW5ndGgtMV0gKz0gJ3snICsgYm9keSArICd9JztcbiAgdmFyIHBvc3RQYXJ0cyA9IHBhcnNlQ29tbWFQYXJ0cyhwb3N0KTtcbiAgaWYgKHBvc3QubGVuZ3RoKSB7XG4gICAgcFtwLmxlbmd0aC0xXSArPSBwb3N0UGFydHMuc2hpZnQoKTtcbiAgICBwLnB1c2guYXBwbHkocCwgcG9zdFBhcnRzKTtcbiAgfVxuXG4gIHBhcnRzLnB1c2guYXBwbHkocGFydHMsIHApO1xuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuZnVuY3Rpb24gZXhwYW5kVG9wKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gW107XG5cbiAgLy8gSSBkb24ndCBrbm93IHdoeSBCYXNoIDQuMyBkb2VzIHRoaXMsIGJ1dCBpdCBkb2VzLlxuICAvLyBBbnl0aGluZyBzdGFydGluZyB3aXRoIHt9IHdpbGwgaGF2ZSB0aGUgZmlyc3QgdHdvIGJ5dGVzIHByZXNlcnZlZFxuICAvLyBidXQgKm9ubHkqIGF0IHRoZSB0b3AgbGV2ZWwsIHNvIHt9LGF9YiB3aWxsIG5vdCBleHBhbmQgdG8gYW55dGhpbmcsXG4gIC8vIGJ1dCBhe30sYn1jIHdpbGwgYmUgZXhwYW5kZWQgdG8gW2F9YyxhYmNdLlxuICAvLyBPbmUgY291bGQgYXJndWUgdGhhdCB0aGlzIGlzIGEgYnVnIGluIEJhc2gsIGJ1dCBzaW5jZSB0aGUgZ29hbCBvZlxuICAvLyB0aGlzIG1vZHVsZSBpcyB0byBtYXRjaCBCYXNoJ3MgcnVsZXMsIHdlIGVzY2FwZSBhIGxlYWRpbmcge31cbiAgaWYgKHN0ci5zdWJzdHIoMCwgMikgPT09ICd7fScpIHtcbiAgICBzdHIgPSAnXFxcXHtcXFxcfScgKyBzdHIuc3Vic3RyKDIpO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZChlc2NhcGVCcmFjZXMoc3RyKSwgdHJ1ZSkubWFwKHVuZXNjYXBlQnJhY2VzKTtcbn1cblxuZnVuY3Rpb24gZW1icmFjZShzdHIpIHtcbiAgcmV0dXJuICd7JyArIHN0ciArICd9Jztcbn1cbmZ1bmN0aW9uIGlzUGFkZGVkKGVsKSB7XG4gIHJldHVybiAvXi0/MFxcZC8udGVzdChlbCk7XG59XG5cbmZ1bmN0aW9uIGx0ZShpLCB5KSB7XG4gIHJldHVybiBpIDw9IHk7XG59XG5mdW5jdGlvbiBndGUoaSwgeSkge1xuICByZXR1cm4gaSA+PSB5O1xufVxuXG5mdW5jdGlvbiBleHBhbmQoc3RyLCBpc1RvcCkge1xuICB2YXIgZXhwYW5zaW9ucyA9IFtdO1xuXG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG4gIGlmICghbSkgcmV0dXJuIFtzdHJdO1xuXG4gIC8vIG5vIG5lZWQgdG8gZXhwYW5kIHByZSwgc2luY2UgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSBmcmVlIG9mIGJyYWNlLXNldHNcbiAgdmFyIHByZSA9IG0ucHJlO1xuICB2YXIgcG9zdCA9IG0ucG9zdC5sZW5ndGhcbiAgICA/IGV4cGFuZChtLnBvc3QsIGZhbHNlKVxuICAgIDogWycnXTtcblxuICBpZiAoL1xcJCQvLnRlc3QobS5wcmUpKSB7ICAgIFxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSsgJ3snICsgbS5ib2R5ICsgJ30nICsgcG9zdFtrXTtcbiAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXNOdW1lcmljU2VxdWVuY2UgPSAvXi0/XFxkK1xcLlxcLi0/XFxkKyg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICAgIHZhciBpc0FscGhhU2VxdWVuY2UgPSAvXlthLXpBLVpdXFwuXFwuW2EtekEtWl0oPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgICB2YXIgaXNTZXF1ZW5jZSA9IGlzTnVtZXJpY1NlcXVlbmNlIHx8IGlzQWxwaGFTZXF1ZW5jZTtcbiAgICB2YXIgaXNPcHRpb25zID0gbS5ib2R5LmluZGV4T2YoJywnKSA+PSAwO1xuICAgIGlmICghaXNTZXF1ZW5jZSAmJiAhaXNPcHRpb25zKSB7XG4gICAgICAvLyB7YX0sYn1cbiAgICAgIGlmIChtLnBvc3QubWF0Y2goLywuKlxcfS8pKSB7XG4gICAgICAgIHN0ciA9IG0ucHJlICsgJ3snICsgbS5ib2R5ICsgZXNjQ2xvc2UgKyBtLnBvc3Q7XG4gICAgICAgIHJldHVybiBleHBhbmQoc3RyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbc3RyXTtcbiAgICB9XG5cbiAgICB2YXIgbjtcbiAgICBpZiAoaXNTZXF1ZW5jZSkge1xuICAgICAgbiA9IG0uYm9keS5zcGxpdCgvXFwuXFwuLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBwYXJzZUNvbW1hUGFydHMobS5ib2R5KTtcbiAgICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB4e3thLGJ9fXkgPT0+IHh7YX15IHh7Yn15XG4gICAgICAgIG4gPSBleHBhbmQoblswXSwgZmFsc2UpLm1hcChlbWJyYWNlKTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc3QubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBtLnByZSArIG5bMF0gKyBwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgbiBpcyB0aGUgcGFydHMsIGFuZCB3ZSBrbm93IGl0J3Mgbm90IGEgY29tbWEgc2V0XG4gICAgLy8gd2l0aCBhIHNpbmdsZSBlbnRyeS5cbiAgICB2YXIgTjtcblxuICAgIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgICB2YXIgeCA9IG51bWVyaWMoblswXSk7XG4gICAgICB2YXIgeSA9IG51bWVyaWMoblsxXSk7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLm1heChuWzBdLmxlbmd0aCwgblsxXS5sZW5ndGgpXG4gICAgICB2YXIgaW5jciA9IG4ubGVuZ3RoID09IDNcbiAgICAgICAgPyBNYXRoLmFicyhudW1lcmljKG5bMl0pKVxuICAgICAgICA6IDE7XG4gICAgICB2YXIgdGVzdCA9IGx0ZTtcbiAgICAgIHZhciByZXZlcnNlID0geSA8IHg7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICBpbmNyICo9IC0xO1xuICAgICAgICB0ZXN0ID0gZ3RlO1xuICAgICAgfVxuICAgICAgdmFyIHBhZCA9IG4uc29tZShpc1BhZGRlZCk7XG5cbiAgICAgIE4gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IHg7IHRlc3QoaSwgeSk7IGkgKz0gaW5jcikge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgaWYgKGlzQWxwaGFTZXF1ZW5jZSkge1xuICAgICAgICAgIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpXG4gICAgICAgICAgICBjID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYyA9IFN0cmluZyhpKTtcbiAgICAgICAgICBpZiAocGFkKSB7XG4gICAgICAgICAgICB2YXIgbmVlZCA9IHdpZHRoIC0gYy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobmVlZCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHogPSBuZXcgQXJyYXkobmVlZCArIDEpLmpvaW4oJzAnKTtcbiAgICAgICAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgICAgIGMgPSAnLScgKyB6ICsgYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGMgPSB6ICsgYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTi5wdXNoKGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBOID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbi5sZW5ndGg7IGorKykge1xuICAgICAgICBOLnB1c2guYXBwbHkoTiwgZXhwYW5kKG5bal0sIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBOLmxlbmd0aDsgaisrKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSArIE5bal0gKyBwb3N0W2tdO1xuICAgICAgICBpZiAoIWlzVG9wIHx8IGlzU2VxdWVuY2UgfHwgZXhwYW5zaW9uKVxuICAgICAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHBhbnNpb25zO1xufVxuXG4iXSwibmFtZXMiOlsiYmFsYW5jZWQiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImV4cGFuZFRvcCIsImVzY1NsYXNoIiwiTWF0aCIsInJhbmRvbSIsImVzY09wZW4iLCJlc2NDbG9zZSIsImVzY0NvbW1hIiwiZXNjUGVyaW9kIiwibnVtZXJpYyIsInN0ciIsInBhcnNlSW50IiwiY2hhckNvZGVBdCIsImVzY2FwZUJyYWNlcyIsInNwbGl0Iiwiam9pbiIsInVuZXNjYXBlQnJhY2VzIiwicGFyc2VDb21tYVBhcnRzIiwicGFydHMiLCJtIiwicHJlIiwiYm9keSIsInBvc3QiLCJwIiwibGVuZ3RoIiwicG9zdFBhcnRzIiwic2hpZnQiLCJwdXNoIiwiYXBwbHkiLCJzdWJzdHIiLCJleHBhbmQiLCJtYXAiLCJlbWJyYWNlIiwiaXNQYWRkZWQiLCJlbCIsInRlc3QiLCJsdGUiLCJpIiwieSIsImd0ZSIsImlzVG9wIiwiZXhwYW5zaW9ucyIsImsiLCJleHBhbnNpb24iLCJpc051bWVyaWNTZXF1ZW5jZSIsImlzQWxwaGFTZXF1ZW5jZSIsImlzU2VxdWVuY2UiLCJpc09wdGlvbnMiLCJpbmRleE9mIiwibWF0Y2giLCJuIiwiTiIsIngiLCJ3aWR0aCIsIm1heCIsImluY3IiLCJhYnMiLCJyZXZlcnNlIiwicGFkIiwic29tZSIsImMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJuZWVkIiwieiIsIkFycmF5Iiwic2xpY2UiLCJqIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readdir-glob/node_modules/brace-expansion/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readdir-glob/node_modules/minimatch/lib/path.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readdir-glob/node_modules/minimatch/lib/path.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("const isWindows = typeof process === \"object\" && process && process.platform === \"win32\";\nmodule.exports = isWindows ? {\n    sep: \"\\\\\"\n} : {\n    sep: \"/\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZC10aW1lc2hlZXQtYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvbGliL3BhdGguanM/ZjRkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc1dpbmRvd3MgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2VzcyAmJlxuICBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG5tb2R1bGUuZXhwb3J0cyA9IGlzV2luZG93cyA/IHsgc2VwOiAnXFxcXCcgfSA6IHsgc2VwOiAnLycgfVxuIl0sIm5hbWVzIjpbImlzV2luZG93cyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZXAiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFlBQVksT0FBT0MsWUFBWSxZQUNuQ0EsV0FDQUEsUUFBUUMsUUFBUSxLQUFLO0FBQ3ZCQyxPQUFPQyxPQUFPLEdBQUdKLFlBQVk7SUFBRUssS0FBSztBQUFLLElBQUk7SUFBRUEsS0FBSztBQUFJIiwiZmlsZSI6Iihzc3IpLy4vbm9kZV9tb2R1bGVzL3JlYWRkaXItZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2xpYi9wYXRoLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readdir-glob/node_modules/minimatch/lib/path.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readdir-glob/node_modules/minimatch/minimatch.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readdir-glob/node_modules/minimatch/minimatch.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const minimatch = module.exports = (p, pattern, options = {})=>{\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nmodule.exports = minimatch;\nconst path = __webpack_require__(/*! ./lib/path.js */ \"(ssr)/./node_modules/readdir-glob/node_modules/minimatch/lib/path.js\");\nminimatch.sep = path.sep;\nconst GLOBSTAR = Symbol(\"globstar **\");\nminimatch.GLOBSTAR = GLOBSTAR;\nconst expand = __webpack_require__(/*! brace-expansion */ \"(ssr)/./node_modules/readdir-glob/node_modules/brace-expansion/index.js\");\nconst plTypes = {\n    \"!\": {\n        open: \"(?:(?!(?:\",\n        close: \"))[^/]*?)\"\n    },\n    \"?\": {\n        open: \"(?:\",\n        close: \")?\"\n    },\n    \"+\": {\n        open: \"(?:\",\n        close: \")+\"\n    },\n    \"*\": {\n        open: \"(?:\",\n        close: \")*\"\n    },\n    \"@\": {\n        open: \"(?:\",\n        close: \")\"\n    }\n};\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = \"[^/]\";\n// * => any number of characters\nconst star = qmark + \"*?\";\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\n// \"abc\" -> { a:true, b:true, c:true }\nconst charSet = (s)=>s.split(\"\").reduce((set, c)=>{\n        set[c] = true;\n        return set;\n    }, {});\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet(\"().*{}+?[]^$\\\\!\");\n// characters that indicate we have to add the pattern start\nconst addPatternStartSet = charSet(\"[.(\");\n// normalizes slashes.\nconst slashSplit = /\\/+/;\nminimatch.filter = (pattern, options = {})=>(p, i, list)=>minimatch(p, pattern, options);\nconst ext = (a, b = {})=>{\n    const t = {};\n    Object.keys(a).forEach((k)=>t[k] = a[k]);\n    Object.keys(b).forEach((k)=>t[k] = b[k]);\n    return t;\n};\nminimatch.defaults = (def)=>{\n    if (!def || typeof def !== \"object\" || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options)=>orig(p, pattern, ext(def, options));\n    m.Minimatch = class Minimatch extends orig.Minimatch {\n        constructor(pattern, options){\n            super(pattern, ext(def, options));\n        }\n    };\n    m.Minimatch.defaults = (options)=>orig.defaults(ext(def, options)).Minimatch;\n    m.filter = (pattern, options)=>orig.filter(pattern, ext(def, options));\n    m.defaults = (options)=>orig.defaults(ext(def, options));\n    m.makeRe = (pattern, options)=>orig.makeRe(pattern, ext(def, options));\n    m.braceExpand = (pattern, options)=>orig.braceExpand(pattern, ext(def, options));\n    m.match = (list, pattern, options)=>orig.match(list, pattern, ext(def, options));\n    return m;\n};\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = (pattern, options)=>braceExpand(pattern, options);\nconst braceExpand = (pattern, options = {})=>{\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [\n            pattern\n        ];\n    }\n    return expand(pattern);\n};\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern)=>{\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"invalid pattern\");\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError(\"pattern is too long\");\n    }\n};\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst SUBPARSE = Symbol(\"subparse\");\nminimatch.makeRe = (pattern, options)=>new Minimatch(pattern, options || {}).makeRe();\nminimatch.match = (list, pattern, options = {})=>{\n    const mm = new Minimatch(pattern, options);\n    list = list.filter((f)=>mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\n// replace stuff like \\* with *\nconst globUnescape = (s)=>s.replace(/\\\\(.)/g, \"$1\");\nconst charUnescape = (s)=>s.replace(/\\\\([^-\\]])/g, \"$1\");\nconst regExpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\nconst braExpEscape = (s)=>s.replace(/[[\\]\\\\]/g, \"\\\\$&\");\nclass Minimatch {\n    constructor(pattern, options){\n        assertValidPattern(pattern);\n        if (!options) options = {};\n        this.options = options;\n        this.set = [];\n        this.pattern = pattern;\n        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, \"/\");\n        }\n        this.regexp = null;\n        this.negate = false;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        // make the set of regexps etc.\n        this.make();\n    }\n    debug() {}\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === \"#\") {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        let set = this.globSet = this.braceExpand();\n        if (options.debug) this.debug = (...args)=>console.error(...args);\n        this.debug(this.pattern, set);\n        // step 3: now we have a set, so turn each one into a series of path-portion\n        // matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        set = this.globParts = set.map((s)=>s.split(slashSplit));\n        this.debug(this.pattern, set);\n        // glob --> regexps\n        set = set.map((s, si, set)=>s.map(this.parse, this));\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        set = set.filter((s)=>s.indexOf(false) === -1);\n        this.debug(this.pattern, set);\n        this.set = set;\n    }\n    parseNegate() {\n        if (this.options.nonegate) return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for(let i = 0; i < pattern.length && pattern.charAt(i) === \"!\"; i++){\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset) this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial) {\n        var options = this.options;\n        this.debug(\"matchOne\", {\n            \"this\": this,\n            file: file,\n            pattern: pattern\n        });\n        this.debug(\"matchOne\", file.length, pattern.length);\n        for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n            this.debug(\"matchOne loop\");\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* istanbul ignore if */ if (p === false) return false;\n            if (p === GLOBSTAR) {\n                this.debug(\"GLOBSTAR\", [\n                    pattern,\n                    p,\n                    f\n                ]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug(\"** at the end\");\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for(; fi < fl; fi++){\n                        if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while(fr < fl){\n                    var swallowee = file[fr];\n                    this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug(\"globstar found match!\", fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    } else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                            this.debug(\"dot detected!\", file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug(\"globstar swallow a segment, and continue\");\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                // If there's more *pattern* left, then\n                /* istanbul ignore if */ if (partial) {\n                    // ran out of file\n                    this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                    if (fr === fl) return true;\n                }\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            var hit;\n            if (typeof p === \"string\") {\n                hit = f === p;\n                this.debug(\"string match\", p, f, hit);\n            } else {\n                hit = f.match(p);\n                this.debug(\"pattern match\", p, f, hit);\n            }\n            if (!hit) return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        } else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        } else /* istanbul ignore else */ if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === \"\";\n        }\n        // should be unreachable.\n        /* istanbul ignore next */ throw new Error(\"wtf?\");\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern, isSub) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === \"**\") {\n            if (!options.noglobstar) return GLOBSTAR;\n            else pattern = \"*\";\n        }\n        if (pattern === \"\") return \"\";\n        let re = \"\";\n        let hasMagic = false;\n        let escaping = false;\n        // ? => one single character\n        const patternListStack = [];\n        const negativeLists = [];\n        let stateChar;\n        let inClass = false;\n        let reClassStart = -1;\n        let classStart = -1;\n        let cs;\n        let pl;\n        let sp;\n        // . and .. never match anything that doesn't start with .,\n        // even when options.dot is set.  However, if the pattern\n        // starts with ., then traversal patterns can match.\n        let dotTravAllowed = pattern.charAt(0) === \".\";\n        let dotFileAllowed = options.dot || dotTravAllowed;\n        const patternStart = ()=>dotTravAllowed ? \"\" : dotFileAllowed ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n        const subPatternStart = (p)=>p.charAt(0) === \".\" ? \"\" : options.dot ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n        const clearStateChar = ()=>{\n            if (stateChar) {\n                // we had some state-tracking character\n                // that wasn't consumed by this pass.\n                switch(stateChar){\n                    case \"*\":\n                        re += star;\n                        hasMagic = true;\n                        break;\n                    case \"?\":\n                        re += qmark;\n                        hasMagic = true;\n                        break;\n                    default:\n                        re += \"\\\\\" + stateChar;\n                        break;\n                }\n                this.debug(\"clearStateChar %j %j\", stateChar, re);\n                stateChar = false;\n            }\n        };\n        for(let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++){\n            this.debug(\"%s\t%s %s %j\", pattern, i, re, c);\n            // skip over any that are escaped.\n            if (escaping) {\n                /* istanbul ignore next - completely not allowed, even escaped. */ if (c === \"/\") {\n                    return false;\n                }\n                if (reSpecials[c]) {\n                    re += \"\\\\\";\n                }\n                re += c;\n                escaping = false;\n                continue;\n            }\n            switch(c){\n                /* istanbul ignore next */ case \"/\":\n                    {\n                        // Should already be path-split by now.\n                        return false;\n                    }\n                case \"\\\\\":\n                    if (inClass && pattern.charAt(i + 1) === \"-\") {\n                        re += c;\n                        continue;\n                    }\n                    clearStateChar();\n                    escaping = true;\n                    continue;\n                // the various stateChar values\n                // for the \"extglob\" stuff.\n                case \"?\":\n                case \"*\":\n                case \"+\":\n                case \"@\":\n                case \"!\":\n                    this.debug(\"%s\t%s %s %j <-- stateChar\", pattern, i, re, c);\n                    // all of those are literals inside a class, except that\n                    // the glob [!a] means [^a] in regexp\n                    if (inClass) {\n                        this.debug(\"  in class\");\n                        if (c === \"!\" && i === classStart + 1) c = \"^\";\n                        re += c;\n                        continue;\n                    }\n                    // if we already have a stateChar, then it means\n                    // that there was something like ** or +? in there.\n                    // Handle the stateChar, then proceed with this one.\n                    this.debug(\"call clearStateChar %j\", stateChar);\n                    clearStateChar();\n                    stateChar = c;\n                    // if extglob is disabled, then +(asdf|foo) isn't a thing.\n                    // just clear the statechar *now*, rather than even diving into\n                    // the patternList stuff.\n                    if (options.noext) clearStateChar();\n                    continue;\n                case \"(\":\n                    {\n                        if (inClass) {\n                            re += \"(\";\n                            continue;\n                        }\n                        if (!stateChar) {\n                            re += \"\\\\(\";\n                            continue;\n                        }\n                        const plEntry = {\n                            type: stateChar,\n                            start: i - 1,\n                            reStart: re.length,\n                            open: plTypes[stateChar].open,\n                            close: plTypes[stateChar].close\n                        };\n                        this.debug(this.pattern, \"\t\", plEntry);\n                        patternListStack.push(plEntry);\n                        // negation is (?:(?!(?:js)(?:<rest>))[^/]*)\n                        re += plEntry.open;\n                        // next entry starts with a dot maybe?\n                        if (plEntry.start === 0 && plEntry.type !== \"!\") {\n                            dotTravAllowed = true;\n                            re += subPatternStart(pattern.slice(i + 1));\n                        }\n                        this.debug(\"plType %j %j\", stateChar, re);\n                        stateChar = false;\n                        continue;\n                    }\n                case \")\":\n                    {\n                        const plEntry = patternListStack[patternListStack.length - 1];\n                        if (inClass || !plEntry) {\n                            re += \"\\\\)\";\n                            continue;\n                        }\n                        patternListStack.pop();\n                        // closing an extglob\n                        clearStateChar();\n                        hasMagic = true;\n                        pl = plEntry;\n                        // negation is (?:(?!js)[^/]*)\n                        // The others are (?:<pattern>)<type>\n                        re += pl.close;\n                        if (pl.type === \"!\") {\n                            negativeLists.push(Object.assign(pl, {\n                                reEnd: re.length\n                            }));\n                        }\n                        continue;\n                    }\n                case \"|\":\n                    {\n                        const plEntry = patternListStack[patternListStack.length - 1];\n                        if (inClass || !plEntry) {\n                            re += \"\\\\|\";\n                            continue;\n                        }\n                        clearStateChar();\n                        re += \"|\";\n                        // next subpattern can start with a dot?\n                        if (plEntry.start === 0 && plEntry.type !== \"!\") {\n                            dotTravAllowed = true;\n                            re += subPatternStart(pattern.slice(i + 1));\n                        }\n                        continue;\n                    }\n                // these are mostly the same in regexp and glob\n                case \"[\":\n                    // swallow any state-tracking char before the [\n                    clearStateChar();\n                    if (inClass) {\n                        re += \"\\\\\" + c;\n                        continue;\n                    }\n                    inClass = true;\n                    classStart = i;\n                    reClassStart = re.length;\n                    re += c;\n                    continue;\n                case \"]\":\n                    //  a right bracket shall lose its special\n                    //  meaning and represent itself in\n                    //  a bracket expression if it occurs\n                    //  first in the list.  -- POSIX.2 2.8.3.2\n                    if (i === classStart + 1 || !inClass) {\n                        re += \"\\\\\" + c;\n                        continue;\n                    }\n                    // split where the last [ was, make sure we don't have\n                    // an invalid re. if so, re-walk the contents of the\n                    // would-be class to re-translate any characters that\n                    // were passed through as-is\n                    // TODO: It would probably be faster to determine this\n                    // without a try/catch and a new RegExp, but it's tricky\n                    // to do safely.  For now, this is safe and works.\n                    cs = pattern.substring(classStart + 1, i);\n                    try {\n                        RegExp(\"[\" + braExpEscape(charUnescape(cs)) + \"]\");\n                        // looks good, finish up the class.\n                        re += c;\n                    } catch (er) {\n                        // out of order ranges in JS are errors, but in glob syntax,\n                        // they're just a range that matches nothing.\n                        re = re.substring(0, reClassStart) + \"(?:$.)\" // match nothing ever\n                        ;\n                    }\n                    hasMagic = true;\n                    inClass = false;\n                    continue;\n                default:\n                    // swallow any state char that wasn't consumed\n                    clearStateChar();\n                    if (reSpecials[c] && !(c === \"^\" && inClass)) {\n                        re += \"\\\\\";\n                    }\n                    re += c;\n                    break;\n            } // switch\n        } // for\n        // handle the case where we left a class open.\n        // \"[abc\" is valid, equivalent to \"\\[abc\"\n        if (inClass) {\n            // split where the last [ was, and escape it\n            // this is a huge pita.  We now have to re-walk\n            // the contents of the would-be class to re-translate\n            // any characters that were passed through as-is\n            cs = pattern.slice(classStart + 1);\n            sp = this.parse(cs, SUBPARSE);\n            re = re.substring(0, reClassStart) + \"\\\\[\" + sp[0];\n            hasMagic = hasMagic || sp[1];\n        }\n        // handle the case where we had a +( thing at the *end*\n        // of the pattern.\n        // each pattern list stack adds 3 chars, and we need to go through\n        // and escape any | chars that were passed through as-is for the regexp.\n        // Go through and escape them, taking care not to double-escape any\n        // | chars that were already escaped.\n        for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){\n            let tail;\n            tail = re.slice(pl.reStart + pl.open.length);\n            this.debug(\"setting tail\", re, pl);\n            // maybe some even number of \\, then maybe 1 \\, followed by a |\n            tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2)=>{\n                /* istanbul ignore else - should already be done */ if (!$2) {\n                    // the | isn't already escaped, so escape it.\n                    $2 = \"\\\\\";\n                }\n                // need to escape all those slashes *again*, without escaping the\n                // one that we need for escaping the | character.  As it works out,\n                // escaping an even number of slashes can be done by simply repeating\n                // it exactly after itself.  That's why this trick works.\n                //\n                // I am sorry that you have to see this.\n                return $1 + $1 + $2 + \"|\";\n            });\n            this.debug(\"tail=%j\\n   %s\", tail, tail, pl, re);\n            const t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;\n            hasMagic = true;\n            re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;\n        }\n        // handle trailing things that only matter at the very end.\n        clearStateChar();\n        if (escaping) {\n            // trailing \\\\\n            re += \"\\\\\\\\\";\n        }\n        // only need to apply the nodot start if the re starts with\n        // something that could conceivably capture a dot\n        const addPatternStart = addPatternStartSet[re.charAt(0)];\n        // Hack to work around lack of negative lookbehind in JS\n        // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n        // like 'a.xyz.yz' doesn't match.  So, the first negative\n        // lookahead, has to look ALL the way ahead, to the end of\n        // the pattern.\n        for(let n = negativeLists.length - 1; n > -1; n--){\n            const nl = negativeLists[n];\n            const nlBefore = re.slice(0, nl.reStart);\n            const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n            let nlAfter = re.slice(nl.reEnd);\n            const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;\n            // Handle nested stuff like *(*.js|!(*.json)), where open parens\n            // mean that we should *not* include the ) in the bit that is considered\n            // \"after\" the negated section.\n            const closeParensBefore = nlBefore.split(\")\").length;\n            const openParensBefore = nlBefore.split(\"(\").length - closeParensBefore;\n            let cleanAfter = nlAfter;\n            for(let i = 0; i < openParensBefore; i++){\n                cleanAfter = cleanAfter.replace(/\\)[+*?]?/, \"\");\n            }\n            nlAfter = cleanAfter;\n            const dollar = nlAfter === \"\" && isSub !== SUBPARSE ? \"(?:$|\\\\/)\" : \"\";\n            re = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n        }\n        // if the re is not \"\" at this point, then we need to make sure\n        // it doesn't match against an empty path part.\n        // Otherwise a/* will match a/, which it should not.\n        if (re !== \"\" && hasMagic) {\n            re = \"(?=.)\" + re;\n        }\n        if (addPatternStart) {\n            re = patternStart() + re;\n        }\n        // parsing just a piece of a larger pattern.\n        if (isSub === SUBPARSE) {\n            return [\n                re,\n                hasMagic\n            ];\n        }\n        // if it's nocase, and the lcase/uppercase don't match, it's magic\n        if (options.nocase && !hasMagic) {\n            hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();\n        }\n        // skip the regexp for non-magical patterns\n        // unescape anything in it, though, so that it'll be\n        // an exact match against a file etc.\n        if (!hasMagic) {\n            return globUnescape(pattern);\n        }\n        const flags = options.nocase ? \"i\" : \"\";\n        try {\n            return Object.assign(new RegExp(\"^\" + re + \"$\", flags), {\n                _glob: pattern,\n                _src: re\n            });\n        } catch (er) /* istanbul ignore next - should be impossible */ {\n            // If it was an invalid regular expression, then it can't match\n            // anything.  This trick looks for a character after the end of\n            // the string, which is of course impossible, except in multi-line\n            // mode, but it's not a /m regex.\n            return new RegExp(\"$.\");\n        }\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false) return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n        const flags = options.nocase ? \"i\" : \"\";\n        // coalesce globstars and regexpify non-globstar patterns\n        // if it's the only item, then we just do one twoStar\n        // if it's the first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if it's the last, append (\\/twoStar|) to previous\n        // if it's in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set.map((pattern)=>{\n            pattern = pattern.map((p)=>typeof p === \"string\" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set, p)=>{\n                if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {\n                    set.push(p);\n                }\n                return set;\n            }, []);\n            pattern.forEach((p, i)=>{\n                if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {\n                    return;\n                }\n                if (i === 0) {\n                    if (pattern.length > 1) {\n                        pattern[i + 1] = \"(?:\\\\/|\" + twoStar + \"\\\\/)?\" + pattern[i + 1];\n                    } else {\n                        pattern[i] = twoStar;\n                    }\n                } else if (i === pattern.length - 1) {\n                    pattern[i - 1] += \"(?:\\\\/|\" + twoStar + \")?\";\n                } else {\n                    pattern[i - 1] += \"(?:\\\\/|\\\\/\" + twoStar + \"\\\\/)\" + pattern[i + 1];\n                    pattern[i + 1] = GLOBSTAR;\n                }\n            });\n            return pattern.filter((p)=>p !== GLOBSTAR).join(\"/\");\n        }).join(\"|\");\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = \"^(?:\" + re + \")$\";\n        // can match anything, as long as it's not this.\n        if (this.negate) re = \"^(?!\" + re + \").*$\";\n        try {\n            this.regexp = new RegExp(re, flags);\n        } catch (ex) /* istanbul ignore next - should be impossible */ {\n            this.regexp = false;\n        }\n        return this.regexp;\n    }\n    match(f, partial = this.partial) {\n        this.debug(\"match\", f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) return false;\n        if (this.empty) return f === \"\";\n        if (f === \"/\" && partial) return true;\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (path.sep !== \"/\") {\n            f = f.split(path.sep).join(\"/\");\n        }\n        // treat the test path as a set of pathparts.\n        f = f.split(slashSplit);\n        this.debug(this.pattern, \"split\", f);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, \"set\", set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename;\n        for(let i = f.length - 1; i >= 0; i--){\n            filename = f[i];\n            if (filename) break;\n        }\n        for(let i = 0; i < set.length; i++){\n            const pattern = set[i];\n            let file = f;\n            if (options.matchBase && pattern.length === 1) {\n                file = [\n                    filename\n                ];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) return true;\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) return false;\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\nminimatch.Minimatch = Minimatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvbWluaW1hdGNoLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFlBQVlDLE9BQU9DLE9BQU8sR0FBRyxDQUFDQyxHQUFHQyxTQUFTQyxVQUFVLENBQUMsQ0FBQztJQUMxREMsbUJBQW1CRjtJQUVuQixvQ0FBb0M7SUFDcEMsSUFBSSxDQUFDQyxRQUFRRSxTQUFTLElBQUlILFFBQVFJLE1BQU0sQ0FBQyxPQUFPLEtBQUs7UUFDbkQsT0FBTztJQUNUO0lBRUEsT0FBTyxJQUFJQyxVQUFVTCxTQUFTQyxTQUFTSyxLQUFLLENBQUNQO0FBQy9DO0FBRUFGLE9BQU9DLE9BQU8sR0FBR0Y7QUFFakIsTUFBTVcsT0FBT0MsbUJBQU9BLENBQUM7QUFDckJaLFVBQVVhLEdBQUcsR0FBR0YsS0FBS0UsR0FBRztBQUV4QixNQUFNQyxXQUFXQyxPQUFPO0FBQ3hCZixVQUFVYyxRQUFRLEdBQUdBO0FBQ3JCLE1BQU1FLFNBQVNKLG1CQUFPQSxDQUFDO0FBRXZCLE1BQU1LLFVBQVU7SUFDZCxLQUFLO1FBQUVDLE1BQU07UUFBYUMsT0FBTztJQUFXO0lBQzVDLEtBQUs7UUFBRUQsTUFBTTtRQUFPQyxPQUFPO0lBQUs7SUFDaEMsS0FBSztRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBSztJQUNoQyxLQUFLO1FBQUVELE1BQU07UUFBT0MsT0FBTztJQUFLO0lBQ2hDLEtBQUs7UUFBRUQsTUFBTTtRQUFPQyxPQUFPO0lBQUk7QUFDakM7QUFFQSxnQ0FBZ0M7QUFDaEMsaURBQWlEO0FBQ2pELE1BQU1DLFFBQVE7QUFFZCxnQ0FBZ0M7QUFDaEMsTUFBTUMsT0FBT0QsUUFBUTtBQUVyQiw0REFBNEQ7QUFDNUQsK0RBQStEO0FBQy9ELDZDQUE2QztBQUM3QyxNQUFNRSxhQUFhO0FBRW5CLGtDQUFrQztBQUNsQyw2Q0FBNkM7QUFDN0MsTUFBTUMsZUFBZTtBQUVyQixzQ0FBc0M7QUFDdEMsTUFB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QUFLLEdBQUc7Z0JBQzdDMkMsT0FBTztvQkFBQ2dFO2lCQUFTO1lBQ25CO1lBQ0EsTUFBTXZELE1BQU0sSUFBSSxDQUFDVixRQUFRLENBQUNDLE1BQU1yRixTQUFTb0U7WUFDekMsSUFBSTBCLEtBQUs7Z0JBQ1AsSUFBSTdGLFFBQVFzSixVQUFVLEVBQUUsT0FBTztnQkFDL0IsT0FBTyxDQUFDLElBQUksQ0FBQ3RGLE1BQU07WUFDckI7UUFDRjtRQUVBLDJEQUEyRDtRQUMzRCw4QkFBOEI7UUFDOUIsSUFBSWhFLFFBQVFzSixVQUFVLEVBQUUsT0FBTztRQUMvQixPQUFPLElBQUksQ0FBQ3RGLE1BQU07SUFDcEI7SUFFQSxPQUFPekIsU0FBVUMsR0FBRyxFQUFFO1FBQ3BCLE9BQU83QyxVQUFVNEMsUUFBUSxDQUFDQyxLQUFLcEMsU0FBUztJQUMxQztBQUNGO0FBRUFULFVBQVVTLFNBQVMsR0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jZC10aW1lc2hlZXQtYW5hbHl6ZXIvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvbWluaW1hdGNoLmpzP2IwNjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbWluaW1hdGNoID0gbW9kdWxlLmV4cG9ydHMgPSAocCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIC8vIHNob3J0Y3V0OiBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1hdGNoKHApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWluaW1hdGNoXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCcuL2xpYi9wYXRoLmpzJylcbm1pbmltYXRjaC5zZXAgPSBwYXRoLnNlcFxuXG5jb25zdCBHTE9CU1RBUiA9IFN5bWJvbCgnZ2xvYnN0YXIgKionKVxubWluaW1hdGNoLkdMT0JTVEFSID0gR0xPQlNUQVJcbmNvbnN0IGV4cGFuZCA9IHJlcXVpcmUoJ2JyYWNlLWV4cGFuc2lvbicpXG5cbmNvbnN0IHBsVHlwZXMgPSB7XG4gICchJzogeyBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6ICcpKVteL10qPyknfSxcbiAgJz8nOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAnKyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgJ0AnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbn1cblxuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbmNvbnN0IHFtYXJrID0gJ1teL10nXG5cbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG5jb25zdCBzdGFyID0gcW1hcmsgKyAnKj8nXG5cbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXFxcLykpLikqPydcblxuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG5jb25zdCB0d29TdGFyTm9Eb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKVxcXFwuKS4pKj8nXG5cbi8vIFwiYWJjXCIgLT4geyBhOnRydWUsIGI6dHJ1ZSwgYzp0cnVlIH1cbmNvbnN0IGNoYXJTZXQgPSBzID0+IHMuc3BsaXQoJycpLnJlZHVjZSgoc2V0LCBjKSA9PiB7XG4gIHNldFtjXSA9IHRydWVcbiAgcmV0dXJuIHNldFxufSwge30pXG5cbi8vIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVzY2FwZWQgaW4gUmVnRXhwLlxuY29uc3QgcmVTcGVjaWFscyA9IGNoYXJTZXQoJygpLip7fSs/W11eJFxcXFwhJylcblxuLy8gY2hhcmFjdGVycyB0aGF0IGluZGljYXRlIHdlIGhhdmUgdG8gYWRkIHRoZSBwYXR0ZXJuIHN0YXJ0XG5jb25zdCBhZGRQYXR0ZXJuU3RhcnRTZXQgPSBjaGFyU2V0KCdbLignKVxuXG4vLyBub3JtYWxpemVzIHNsYXNoZXMuXG5jb25zdCBzbGFzaFNwbGl0ID0gL1xcLysvXG5cbm1pbmltYXRjaC5maWx0ZXIgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PlxuICAocCwgaSwgbGlzdCkgPT4gbWluaW1hdGNoKHAsIHBhdHRlcm4sIG9wdGlvbnMpXG5cbmNvbnN0IGV4dCA9IChhLCBiID0ge30pID0+IHtcbiAgY29uc3QgdCA9IHt9XG4gIE9iamVjdC5rZXlzKGEpLmZvckVhY2goayA9PiB0W2tdID0gYVtrXSlcbiAgT2JqZWN0LmtleXMoYikuZm9yRWFjaChrID0+IHRba10gPSBiW2tdKVxuICByZXR1cm4gdFxufVxuXG5taW5pbWF0Y2guZGVmYXVsdHMgPSBkZWYgPT4ge1xuICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWluaW1hdGNoXG4gIH1cblxuICBjb25zdCBvcmlnID0gbWluaW1hdGNoXG5cbiAgY29uc3QgbSA9IChwLCBwYXR0ZXJuLCBvcHRpb25zKSA9PiBvcmlnKHAsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICBtLk1pbmltYXRjaCA9IGNsYXNzIE1pbmltYXRjaCBleHRlbmRzIG9yaWcuTWluaW1hdGNoIHtcbiAgICBjb25zdHJ1Y3RvciAocGF0dGVybiwgb3B0aW9ucykge1xuICAgICAgc3VwZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gICAgfVxuICB9XG4gIG0uTWluaW1hdGNoLmRlZmF1bHRzID0gb3B0aW9ucyA9PiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKS5NaW5pbWF0Y2hcbiAgbS5maWx0ZXIgPSAocGF0dGVybiwgb3B0aW9ucykgPT4gb3JpZy5maWx0ZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIG0uZGVmYXVsdHMgPSBvcHRpb25zID0+IG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpXG4gIG0ubWFrZVJlID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IG9yaWcubWFrZVJlKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICBtLmJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IG9yaWcuYnJhY2VFeHBhbmQocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIG0ubWF0Y2ggPSAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykgPT4gb3JpZy5tYXRjaChsaXN0LCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcblxuICByZXR1cm4gbVxufVxuXG5cblxuXG5cbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xubWluaW1hdGNoLmJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IGJyYWNlRXhwYW5kKHBhdHRlcm4sIG9wdGlvbnMpXG5cbmNvbnN0IGJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICAvLyBUaGFua3MgdG8gWWV0aW5nIExpIDxodHRwczovL2dpdGh1Yi5jb20veWV0aW5nbGk+IGZvclxuICAvLyBpbXByb3ZpbmcgdGhpcyByZWdleHAgdG8gYXZvaWQgYSBSZURPUyB2dWxuZXJhYmlsaXR5LlxuICBpZiAob3B0aW9ucy5ub2JyYWNlIHx8ICEvXFx7KD86KD8hXFx7KS4pKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgIC8vIHNob3J0Y3V0LiBubyBuZWVkIHRvIGV4cGFuZC5cbiAgICByZXR1cm4gW3BhdHRlcm5dXG4gIH1cblxuICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pXG59XG5cbmNvbnN0IE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NFxuY29uc3QgYXNzZXJ0VmFsaWRQYXR0ZXJuID0gcGF0dGVybiA9PiB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhdHRlcm4nKVxuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX1BBVFRFUk5fTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpXG4gIH1cbn1cblxuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5jb25zdCBTVUJQQVJTRSA9IFN5bWJvbCgnc3VicGFyc2UnKVxuXG5taW5pbWF0Y2gubWFrZVJlID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+XG4gIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcblxubWluaW1hdGNoLm1hdGNoID0gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKGYgPT4gbW0ubWF0Y2goZikpXG4gIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICBsaXN0LnB1c2gocGF0dGVybilcbiAgfVxuICByZXR1cm4gbGlzdFxufVxuXG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuY29uc3QgZ2xvYlVuZXNjYXBlID0gcyA9PiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbmNvbnN0IGNoYXJVbmVzY2FwZSA9IHMgPT4gcy5yZXBsYWNlKC9cXFxcKFteLVxcXV0pL2csICckMScpXG5jb25zdCByZWdFeHBFc2NhcGUgPSBzID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKVxuY29uc3QgYnJhRXhwRXNjYXBlID0gcyA9PiBzLnJlcGxhY2UoL1tbXFxdXFxcXF0vZywgJ1xcXFwkJicpXG5cbmNsYXNzIE1pbmltYXRjaCB7XG4gIGNvbnN0cnVjdG9yIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuc2V0ID0gW11cbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuXG4gICAgdGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSA9ICEhb3B0aW9ucy53aW5kb3dzUGF0aHNOb0VzY2FwZSB8fFxuICAgICAgb3B0aW9ucy5hbGxvd1dpbmRvd3NFc2NhcGUgPT09IGZhbHNlXG4gICAgaWYgKHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICAgIHRoaXMucGF0dGVybiA9IHRoaXMucGF0dGVybi5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICB9XG4gICAgdGhpcy5yZWdleHAgPSBudWxsXG4gICAgdGhpcy5uZWdhdGUgPSBmYWxzZVxuICAgIHRoaXMuY29tbWVudCA9IGZhbHNlXG4gICAgdGhpcy5lbXB0eSA9IGZhbHNlXG4gICAgdGhpcy5wYXJ0aWFsID0gISFvcHRpb25zLnBhcnRpYWxcblxuICAgIC8vIG1ha2UgdGhlIHNldCBvZiByZWdleHBzIGV0Yy5cbiAgICB0aGlzLm1ha2UoKVxuICB9XG5cbiAgZGVidWcgKCkge31cblxuICBtYWtlICgpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gICAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gICAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICB0aGlzLmNvbW1lbnQgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICB0aGlzLmVtcHR5ID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gICAgdGhpcy5wYXJzZU5lZ2F0ZSgpXG5cbiAgICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgICBsZXQgc2V0ID0gdGhpcy5nbG9iU2V0ID0gdGhpcy5icmFjZUV4cGFuZCgpXG5cbiAgICBpZiAob3B0aW9ucy5kZWJ1ZykgdGhpcy5kZWJ1ZyA9ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKC4uLmFyZ3MpXG5cbiAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gICAgLy8gc3RlcCAzOiBub3cgd2UgaGF2ZSBhIHNldCwgc28gdHVybiBlYWNoIG9uZSBpbnRvIGEgc2VyaWVzIG9mIHBhdGgtcG9ydGlvblxuICAgIC8vIG1hdGNoaW5nIHBhdHRlcm5zLlxuICAgIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgICAvLyBzZXQgdG8gdGhlIEdMT0JTVEFSIG9iamVjdCBmb3IgZ2xvYnN0YXIgYmVoYXZpb3IsXG4gICAgLy8gYW5kIHdpbGwgbm90IGNvbnRhaW4gYW55IC8gY2hhcmFjdGVyc1xuICAgIHNldCA9IHRoaXMuZ2xvYlBhcnRzID0gc2V0Lm1hcChzID0+IHMuc3BsaXQoc2xhc2hTcGxpdCkpXG5cbiAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gICAgLy8gZ2xvYiAtLT4gcmVnZXhwc1xuICAgIHNldCA9IHNldC5tYXAoKHMsIHNpLCBzZXQpID0+IHMubWFwKHRoaXMucGFyc2UsIHRoaXMpKVxuXG4gICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAgIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICAgIHNldCA9IHNldC5maWx0ZXIocyA9PiBzLmluZGV4T2YoZmFsc2UpID09PSAtMSlcblxuICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgICB0aGlzLnNldCA9IHNldFxuICB9XG5cbiAgcGFyc2VOZWdhdGUgKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubm9uZWdhdGUpIHJldHVyblxuXG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICAgIGxldCBuZWdhdGUgPSBmYWxzZVxuICAgIGxldCBuZWdhdGVPZmZzZXQgPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISc7IGkrKykge1xuICAgICAgbmVnYXRlID0gIW5lZ2F0ZVxuICAgICAgbmVnYXRlT2Zmc2V0KytcbiAgICB9XG5cbiAgICBpZiAobmVnYXRlT2Zmc2V0KSB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKG5lZ2F0ZU9mZnNldClcbiAgICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZVxuICB9XG5cbiAgLy8gc2V0IHBhcnRpYWwgdG8gdHJ1ZSB0byB0ZXN0IGlmLCBmb3IgZXhhbXBsZSxcbiAgLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4gIC8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbiAgLy8gb3V0IG9mIHBhdHRlcm4sIHRoZW4gdGhhdCdzIGZpbmUsIGFzIGxvbmcgYXMgYWxsXG4gIC8vIHRoZSBwYXJ0cyBtYXRjaC5cbiAgbWF0Y2hPbmUgKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLFxuICAgICAgeyAndGhpcyc6IHRoaXMsIGZpbGU6IGZpbGUsIHBhdHRlcm46IHBhdHRlcm4gfSlcblxuICAgIHRoaXMuZGVidWcoJ21hdGNoT25lJywgZmlsZS5sZW5ndGgsIHBhdHRlcm4ubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgZmkgPSAwLFxuICAgICAgICBwaSA9IDAsXG4gICAgICAgIGZsID0gZmlsZS5sZW5ndGgsXG4gICAgICAgIHBsID0gcGF0dGVybi5sZW5ndGhcbiAgICAgICAgOyAoZmkgPCBmbCkgJiYgKHBpIDwgcGwpXG4gICAgICAgIDsgZmkrKywgcGkrKykge1xuICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpXG4gICAgICB2YXIgcCA9IHBhdHRlcm5bcGldXG4gICAgICB2YXIgZiA9IGZpbGVbZmldXG5cbiAgICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZilcblxuICAgICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGUuXG4gICAgICAvLyBzb21lIGludmFsaWQgcmVnZXhwIHN0dWZmIGluIHRoZSBzZXQuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSlcblxuICAgICAgICAvLyBcIioqXCJcbiAgICAgICAgLy8gYS8qKi9iLyoqL2Mgd291bGQgbWF0Y2ggdGhlIGZvbGxvd2luZzpcbiAgICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgICAgLy8gYS94L3kvei9iL2NcbiAgICAgICAgLy8gYS9iL3gvYi94L2NcbiAgICAgICAgLy8gYS9iL2NcbiAgICAgICAgLy8gVG8gZG8gdGhpcywgdGFrZSB0aGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlclxuICAgICAgICAvLyB0aGUgKiosIGFuZCBzZWUgaWYgaXQgd291bGQgbWF0Y2ggdGhlIGZpbGUgcmVtYWluZGVyLlxuICAgICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAgIC8vIElmIG5vdCwgdGhlICoqIFwic3dhbGxvd3NcIiBhIHNlZ21lbnQsIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgIC8vIFRoaXMgaXMgcmVjdXJzaXZlbHkgYXdmdWwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGEvKiovYi8qKi9jIG1hdGNoaW5nIGEvYi94L3kvei9jXG4gICAgICAgIC8vIC0gYSBtYXRjaGVzIGFcbiAgICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAgIC8vICAgLSBtYXRjaE9uZShiL3gveS96L2MsIGIvKiovYylcbiAgICAgICAgLy8gICAgIC0gYiBtYXRjaGVzIGJcbiAgICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHgveS96L2MsIGMpIC0+IG5vXG4gICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeS96L2MsIGMpIC0+IG5vXG4gICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKGMsIGMpIHllcywgaGl0XG4gICAgICAgIHZhciBmciA9IGZpXG4gICAgICAgIHZhciBwciA9IHBpICsgMVxuICAgICAgICBpZiAocHIgPT09IHBsKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpXG4gICAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAvLyBob3dldmVyLCBpdCB3aWxsIG5vdCBzd2FsbG93IC8ueCwgdW5sZXNzXG4gICAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAgIC8vIC4gYW5kIC4uIGFyZSAqbmV2ZXIqIG1hdGNoZWQgYnkgKiosIGZvciBleHBsb3NpdmVseVxuICAgICAgICAgIC8vIGV4cG9uZW50aWFsIHJlYXNvbnMuXG4gICAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICAgIGlmIChmaWxlW2ZpXSA9PT0gJy4nIHx8IGZpbGVbZmldID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgICB3aGlsZSAoZnIgPCBmbCkge1xuICAgICAgICAgIHZhciBzd2FsbG93ZWUgPSBmaWxlW2ZyXVxuXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSlcblxuICAgICAgICAgIC8vIFhYWCByZW1vdmUgdGhpcyBzbGljZS4gIEp1c3QgcGFzcyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpXG4gICAgICAgICAgICAvLyBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2FuJ3Qgc3dhbGxvdyBcIi5cIiBvciBcIi4uXCIgZXZlci5cbiAgICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8IHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIHN3YWxsb3dlZS5jaGFyQXQoMCkgPT09ICcuJykpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gKiogc3dhbGxvd3MgYSBzZWdtZW50LCBhbmQgY29udGludWUuXG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJylcbiAgICAgICAgICAgIGZyKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBtYXRjaCB3YXMgZm91bmQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlICpwYXR0ZXJuKiBsZWZ0LCB0aGVuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICAgIHRoaXMuZGVidWcoJ1xcbj4+PiBubyBtYXRjaCwgcGFydGlhbD8nLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpXG4gICAgICAgICAgaWYgKGZyID09PSBmbCkgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAgIC8vIG5vbi1tYWdpYyBwYXR0ZXJucyBqdXN0IGhhdmUgdG8gbWF0Y2ggZXhhY3RseVxuICAgICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICAgIHZhciBoaXRcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGl0ID0gZiA9PT0gcFxuICAgICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaXQgPSBmLm1hdGNoKHApXG4gICAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgICB9XG5cbiAgICAgIGlmICghaGl0KSByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBOb3RlOiBlbmRpbmcgaW4gLyBtZWFucyB0aGF0IHdlJ2xsIGdldCBhIGZpbmFsIFwiXCJcbiAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLiAgVGhpcyBjYW4gb25seSBtYXRjaCBhXG4gICAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gICAgLy8gSWYgdGhlIGZpbGUgZW5kcyBpbiAvLCB0aGVuIGl0IGNhbiBvbmx5IG1hdGNoIGFcbiAgICAvLyBhIHBhdHRlcm4gdGhhdCBlbmRzIGluIC8sIHVubGVzcyB0aGUgcGF0dGVybiBqdXN0XG4gICAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAgIC8vIG1hdGNoIFwiYS9iLypcIiwgZXZlbiB0aG91Z2ggXCJcIiBtYXRjaGVzIGFnYWluc3QgdGhlXG4gICAgLy8gW14vXSo/IHBhdHRlcm4sIGV4Y2VwdCBpbiBwYXJ0aWFsIG1vZGUsIHdoZXJlIGl0IG1pZ2h0XG4gICAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgICAvLyBIb3dldmVyLCBhL2IvIHNob3VsZCBzdGlsbCBzYXRpc2Z5IGEvKlxuXG4gICAgLy8gbm93IGVpdGhlciB3ZSBmZWxsIG9mZiB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLCBvciB3ZSdyZSBkb25lLlxuICAgIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4gYW5kIGZpbGVuYW1lIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAvLyBhbiBleGFjdCBoaXQhXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoZmkgPT09IGZsKSB7XG4gICAgICAvLyByYW4gb3V0IG9mIGZpbGUsIGJ1dCBzdGlsbCBoYWQgcGF0dGVybiBsZWZ0LlxuICAgICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgICAgLy8gYSBnbG9iIGZzIHRyYXZlcnNhbC5cbiAgICAgIHJldHVybiBwYXJ0aWFsXG4gICAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChwaSA9PT0gcGwpIHtcbiAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiwgc3RpbGwgaGF2ZSBmaWxlIGxlZnQuXG4gICAgICAvLyB0aGlzIGlzIG9ubHkgYWNjZXB0YWJsZSBpZiB3ZSdyZSBvbiB0aGUgdmVyeSBsYXN0XG4gICAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgICAvLyBhLyogc2hvdWxkIG1hdGNoIGEvYi9cbiAgICAgIHJldHVybiAoZmkgPT09IGZsIC0gMSkgJiYgKGZpbGVbZmldID09PSAnJylcbiAgICB9XG5cbiAgICAvLyBzaG91bGQgYmUgdW5yZWFjaGFibGUuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKVxuICB9XG5cbiAgYnJhY2VFeHBhbmQgKCkge1xuICAgIHJldHVybiBicmFjZUV4cGFuZCh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIHBhcnNlIChwYXR0ZXJuLCBpc1N1Yikge1xuICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gICAgLy8gc2hvcnRjdXRzXG4gICAgaWYgKHBhdHRlcm4gPT09ICcqKicpIHtcbiAgICAgIGlmICghb3B0aW9ucy5ub2dsb2JzdGFyKVxuICAgICAgICByZXR1cm4gR0xPQlNUQVJcbiAgICAgIGVsc2VcbiAgICAgICAgcGF0dGVybiA9ICcqJ1xuICAgIH1cbiAgICBpZiAocGF0dGVybiA9PT0gJycpIHJldHVybiAnJ1xuXG4gICAgbGV0IHJlID0gJydcbiAgICBsZXQgaGFzTWFnaWMgPSBmYWxzZVxuICAgIGxldCBlc2NhcGluZyA9IGZhbHNlXG4gICAgLy8gPyA9PiBvbmUgc2luZ2xlIGNoYXJhY3RlclxuICAgIGNvbnN0IHBhdHRlcm5MaXN0U3RhY2sgPSBbXVxuICAgIGNvbnN0IG5lZ2F0aXZlTGlzdHMgPSBbXVxuICAgIGxldCBzdGF0ZUNoYXJcbiAgICBsZXQgaW5DbGFzcyA9IGZhbHNlXG4gICAgbGV0IHJlQ2xhc3NTdGFydCA9IC0xXG4gICAgbGV0IGNsYXNzU3RhcnQgPSAtMVxuICAgIGxldCBjc1xuICAgIGxldCBwbFxuICAgIGxldCBzcFxuICAgIC8vIC4gYW5kIC4uIG5ldmVyIG1hdGNoIGFueXRoaW5nIHRoYXQgZG9lc24ndCBzdGFydCB3aXRoIC4sXG4gICAgLy8gZXZlbiB3aGVuIG9wdGlvbnMuZG90IGlzIHNldC4gIEhvd2V2ZXIsIGlmIHRoZSBwYXR0ZXJuXG4gICAgLy8gc3RhcnRzIHdpdGggLiwgdGhlbiB0cmF2ZXJzYWwgcGF0dGVybnMgY2FuIG1hdGNoLlxuICAgIGxldCBkb3RUcmF2QWxsb3dlZCA9IHBhdHRlcm4uY2hhckF0KDApID09PSAnLidcbiAgICBsZXQgZG90RmlsZUFsbG93ZWQgPSBvcHRpb25zLmRvdCB8fCBkb3RUcmF2QWxsb3dlZFxuICAgIGNvbnN0IHBhdHRlcm5TdGFydCA9ICgpID0+XG4gICAgICBkb3RUcmF2QWxsb3dlZFxuICAgICAgICA/ICcnXG4gICAgICAgIDogZG90RmlsZUFsbG93ZWRcbiAgICAgICAgPyAnKD8hKD86XnxcXFxcLylcXFxcLnsxLDJ9KD86JHxcXFxcLykpJ1xuICAgICAgICA6ICcoPyFcXFxcLiknXG4gICAgY29uc3Qgc3ViUGF0dGVyblN0YXJ0ID0gKHApID0+XG4gICAgICBwLmNoYXJBdCgwKSA9PT0gJy4nXG4gICAgICAgID8gJydcbiAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICA/ICcoPyEoPzpefFxcXFwvKVxcXFwuezEsMn0oPzokfFxcXFwvKSknXG4gICAgICAgIDogJyg/IVxcXFwuKSdcblxuXG4gICAgY29uc3QgY2xlYXJTdGF0ZUNoYXIgPSAoKSA9PiB7XG4gICAgICBpZiAoc3RhdGVDaGFyKSB7XG4gICAgICAgIC8vIHdlIGhhZCBzb21lIHN0YXRlLXRyYWNraW5nIGNoYXJhY3RlclxuICAgICAgICAvLyB0aGF0IHdhc24ndCBjb25zdW1lZCBieSB0aGlzIHBhc3MuXG4gICAgICAgIHN3aXRjaCAoc3RhdGVDaGFyKSB7XG4gICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICByZSArPSBzdGFyXG4gICAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgICAgcmUgKz0gcW1hcmtcbiAgICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlICs9ICdcXFxcJyArIHN0YXRlQ2hhclxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZygnY2xlYXJTdGF0ZUNoYXIgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBjOyAoaSA8IHBhdHRlcm4ubGVuZ3RoKSAmJiAoYyA9IHBhdHRlcm4uY2hhckF0KGkpKTsgaSsrKSB7XG4gICAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAgIC8vIHNraXAgb3ZlciBhbnkgdGhhdCBhcmUgZXNjYXBlZC5cbiAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIGNvbXBsZXRlbHkgbm90IGFsbG93ZWQsIGV2ZW4gZXNjYXBlZC4gKi9cbiAgICAgICAgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlU3BlY2lhbHNbY10pIHtcbiAgICAgICAgICByZSArPSAnXFxcXCdcbiAgICAgICAgfVxuICAgICAgICByZSArPSBjXG4gICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGNhc2UgJy8nOiB7XG4gICAgICAgICAgLy8gU2hvdWxkIGFscmVhZHkgYmUgcGF0aC1zcGxpdCBieSBub3cuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgICBpZiAoaW5DbGFzcyAmJiBwYXR0ZXJuLmNoYXJBdChpICsgMSkgPT09ICctJykge1xuICAgICAgICAgICAgcmUgKz0gY1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgICAgZXNjYXBpbmcgPSB0cnVlXG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgLy8gdGhlIHZhcmlvdXMgc3RhdGVDaGFyIHZhbHVlc1xuICAgICAgICAvLyBmb3IgdGhlIFwiZXh0Z2xvYlwiIHN0dWZmLlxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaiA8LS0gc3RhdGVDaGFyJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAgICAgICAvLyBhbGwgb2YgdGhvc2UgYXJlIGxpdGVyYWxzIGluc2lkZSBhIGNsYXNzLCBleGNlcHQgdGhhdFxuICAgICAgICAgIC8vIHRoZSBnbG9iIFshYV0gbWVhbnMgW15hXSBpbiByZWdleHBcbiAgICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnICBpbiBjbGFzcycpXG4gICAgICAgICAgICBpZiAoYyA9PT0gJyEnICYmIGkgPT09IGNsYXNzU3RhcnQgKyAxKSBjID0gJ14nXG4gICAgICAgICAgICByZSArPSBjXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXRlQ2hhciwgdGhlbiBpdCBtZWFuc1xuICAgICAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIHNvbWV0aGluZyBsaWtlICoqIG9yICs/IGluIHRoZXJlLlxuICAgICAgICAgIC8vIEhhbmRsZSB0aGUgc3RhdGVDaGFyLCB0aGVuIHByb2NlZWQgd2l0aCB0aGlzIG9uZS5cbiAgICAgICAgICB0aGlzLmRlYnVnKCdjYWxsIGNsZWFyU3RhdGVDaGFyICVqJywgc3RhdGVDaGFyKVxuICAgICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgICBzdGF0ZUNoYXIgPSBjXG4gICAgICAgICAgLy8gaWYgZXh0Z2xvYiBpcyBkaXNhYmxlZCwgdGhlbiArKGFzZGZ8Zm9vKSBpc24ndCBhIHRoaW5nLlxuICAgICAgICAgIC8vIGp1c3QgY2xlYXIgdGhlIHN0YXRlY2hhciAqbm93KiwgcmF0aGVyIHRoYW4gZXZlbiBkaXZpbmcgaW50b1xuICAgICAgICAgIC8vIHRoZSBwYXR0ZXJuTGlzdCBzdHVmZi5cbiAgICAgICAgICBpZiAob3B0aW9ucy5ub2V4dCkgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgJygnOiB7XG4gICAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICAgIHJlICs9ICcoJ1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXN0YXRlQ2hhcikge1xuICAgICAgICAgICAgcmUgKz0gJ1xcXFwoJ1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwbEVudHJ5ID0ge1xuICAgICAgICAgICAgdHlwZTogc3RhdGVDaGFyLFxuICAgICAgICAgICAgc3RhcnQ6IGkgLSAxLFxuICAgICAgICAgICAgcmVTdGFydDogcmUubGVuZ3RoLFxuICAgICAgICAgICAgb3BlbjogcGxUeXBlc1tzdGF0ZUNoYXJdLm9wZW4sXG4gICAgICAgICAgICBjbG9zZTogcGxUeXBlc1tzdGF0ZUNoYXJdLmNsb3NlLFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ1xcdCcsIHBsRW50cnkpXG4gICAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wdXNoKHBsRW50cnkpXG4gICAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hKD86anMpKD86PHJlc3Q+KSlbXi9dKilcbiAgICAgICAgICByZSArPSBwbEVudHJ5Lm9wZW5cbiAgICAgICAgICAvLyBuZXh0IGVudHJ5IHN0YXJ0cyB3aXRoIGEgZG90IG1heWJlP1xuICAgICAgICAgIGlmIChwbEVudHJ5LnN0YXJ0ID09PSAwICYmIHBsRW50cnkudHlwZSAhPT0gJyEnKSB7XG4gICAgICAgICAgICBkb3RUcmF2QWxsb3dlZCA9IHRydWVcbiAgICAgICAgICAgIHJlICs9IHN1YlBhdHRlcm5TdGFydChwYXR0ZXJuLnNsaWNlKGkgKyAxKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kZWJ1ZygncGxUeXBlICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlICcpJzoge1xuICAgICAgICAgIGNvbnN0IHBsRW50cnkgPSBwYXR0ZXJuTGlzdFN0YWNrW3BhdHRlcm5MaXN0U3RhY2subGVuZ3RoIC0gMV1cbiAgICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGxFbnRyeSkge1xuICAgICAgICAgICAgcmUgKz0gJ1xcXFwpJ1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wb3AoKVxuXG4gICAgICAgICAgLy8gY2xvc2luZyBhbiBleHRnbG9iXG4gICAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICAgIHBsID0gcGxFbnRyeVxuICAgICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICAgIC8vIFRoZSBvdGhlcnMgYXJlICg/OjxwYXR0ZXJuPik8dHlwZT5cbiAgICAgICAgICByZSArPSBwbC5jbG9zZVxuICAgICAgICAgIGlmIChwbC50eXBlID09PSAnIScpIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlTGlzdHMucHVzaChPYmplY3QuYXNzaWduKHBsLCB7IHJlRW5kOiByZS5sZW5ndGggfSkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlICd8Jzoge1xuICAgICAgICAgIGNvbnN0IHBsRW50cnkgPSBwYXR0ZXJuTGlzdFN0YWNrW3BhdHRlcm5MaXN0U3RhY2subGVuZ3RoIC0gMV1cbiAgICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGxFbnRyeSkge1xuICAgICAgICAgICAgcmUgKz0gJ1xcXFx8J1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgICAgcmUgKz0gJ3wnXG4gICAgICAgICAgLy8gbmV4dCBzdWJwYXR0ZXJuIGNhbiBzdGFydCB3aXRoIGEgZG90P1xuICAgICAgICAgIGlmIChwbEVudHJ5LnN0YXJ0ID09PSAwICYmIHBsRW50cnkudHlwZSAhPT0gJyEnKSB7XG4gICAgICAgICAgICBkb3RUcmF2QWxsb3dlZCA9IHRydWVcbiAgICAgICAgICAgIHJlICs9IHN1YlBhdHRlcm5TdGFydChwYXR0ZXJuLnNsaWNlKGkgKyAxKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXNlIGFyZSBtb3N0bHkgdGhlIHNhbWUgaW4gcmVnZXhwIGFuZCBnbG9iXG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlLXRyYWNraW5nIGNoYXIgYmVmb3JlIHRoZSBbXG4gICAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5DbGFzcyA9IHRydWVcbiAgICAgICAgICBjbGFzc1N0YXJ0ID0gaVxuICAgICAgICAgIHJlQ2xhc3NTdGFydCA9IHJlLmxlbmd0aFxuICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAvLyAgYSByaWdodCBicmFja2V0IHNoYWxsIGxvc2UgaXRzIHNwZWNpYWxcbiAgICAgICAgICAvLyAgbWVhbmluZyBhbmQgcmVwcmVzZW50IGl0c2VsZiBpblxuICAgICAgICAgIC8vICBhIGJyYWNrZXQgZXhwcmVzc2lvbiBpZiBpdCBvY2N1cnNcbiAgICAgICAgICAvLyAgZmlyc3QgaW4gdGhlIGxpc3QuICAtLSBQT1NJWC4yIDIuOC4zLjJcbiAgICAgICAgICBpZiAoaSA9PT0gY2xhc3NTdGFydCArIDEgfHwgIWluQ2xhc3MpIHtcbiAgICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gYW4gaW52YWxpZCByZS4gaWYgc28sIHJlLXdhbGsgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgIC8vIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZSBhbnkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgICAgLy8gd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgICAgICAgIC8vIFRPRE86IEl0IHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAgIC8vIHdpdGhvdXQgYSB0cnkvY2F0Y2ggYW5kIGEgbmV3IFJlZ0V4cCwgYnV0IGl0J3MgdHJpY2t5XG4gICAgICAgICAgLy8gdG8gZG8gc2FmZWx5LiAgRm9yIG5vdywgdGhpcyBpcyBzYWZlIGFuZCB3b3Jrcy5cbiAgICAgICAgICBjcyA9IHBhdHRlcm4uc3Vic3RyaW5nKGNsYXNzU3RhcnQgKyAxLCBpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWdFeHAoJ1snICsgYnJhRXhwRXNjYXBlKGNoYXJVbmVzY2FwZShjcykpICsgJ10nKVxuICAgICAgICAgICAgLy8gbG9va3MgZ29vZCwgZmluaXNoIHVwIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgICAgLy8gb3V0IG9mIG9yZGVyIHJhbmdlcyBpbiBKUyBhcmUgZXJyb3JzLCBidXQgaW4gZ2xvYiBzeW50YXgsXG4gICAgICAgICAgICAvLyB0aGV5J3JlIGp1c3QgYSByYW5nZSB0aGF0IG1hdGNoZXMgbm90aGluZy5cbiAgICAgICAgICAgIHJlID0gcmUuc3Vic3RyaW5nKDAsIHJlQ2xhc3NTdGFydCkgKyAnKD86JC4pJyAvLyBtYXRjaCBub3RoaW5nIGV2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZSBjaGFyIHRoYXQgd2Fzbid0IGNvbnN1bWVkXG4gICAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgICAgaWYgKHJlU3BlY2lhbHNbY10gJiYgIShjID09PSAnXicgJiYgaW5DbGFzcykpIHtcbiAgICAgICAgICAgIHJlICs9ICdcXFxcJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgICBicmVha1xuXG4gICAgICB9IC8vIHN3aXRjaFxuICAgIH0gLy8gZm9yXG5cbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgbGVmdCBhIGNsYXNzIG9wZW4uXG4gICAgLy8gXCJbYWJjXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFthYmNcIlxuICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgYW5kIGVzY2FwZSBpdFxuICAgICAgLy8gdGhpcyBpcyBhIGh1Z2UgcGl0YS4gIFdlIG5vdyBoYXZlIHRvIHJlLXdhbGtcbiAgICAgIC8vIHRoZSBjb250ZW50cyBvZiB0aGUgd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlXG4gICAgICAvLyBhbnkgY2hhcmFjdGVycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXNcbiAgICAgIGNzID0gcGF0dGVybi5zbGljZShjbGFzc1N0YXJ0ICsgMSlcbiAgICAgIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgICByZSA9IHJlLnN1YnN0cmluZygwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdXG4gICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGhhZCBhICsoIHRoaW5nIGF0IHRoZSAqZW5kKlxuICAgIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICAgIC8vIGVhY2ggcGF0dGVybiBsaXN0IHN0YWNrIGFkZHMgMyBjaGFycywgYW5kIHdlIG5lZWQgdG8gZ28gdGhyb3VnaFxuICAgIC8vIGFuZCBlc2NhcGUgYW55IHwgY2hhcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzIGZvciB0aGUgcmVnZXhwLlxuICAgIC8vIEdvIHRocm91Z2ggYW5kIGVzY2FwZSB0aGVtLCB0YWtpbmcgY2FyZSBub3QgdG8gZG91YmxlLWVzY2FwZSBhbnlcbiAgICAvLyB8IGNoYXJzIHRoYXQgd2VyZSBhbHJlYWR5IGVzY2FwZWQuXG4gICAgZm9yIChwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCk7IHBsOyBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCkpIHtcbiAgICAgIGxldCB0YWlsXG4gICAgICB0YWlsID0gcmUuc2xpY2UocGwucmVTdGFydCArIHBsLm9wZW4ubGVuZ3RoKVxuICAgICAgdGhpcy5kZWJ1Zygnc2V0dGluZyB0YWlsJywgcmUsIHBsKVxuICAgICAgLy8gbWF5YmUgc29tZSBldmVuIG51bWJlciBvZiBcXCwgdGhlbiBtYXliZSAxIFxcLCBmb2xsb3dlZCBieSBhIHxcbiAgICAgIHRhaWwgPSB0YWlsLnJlcGxhY2UoLygoPzpcXFxcezJ9KXswLDY0fSkoXFxcXD8pXFx8L2csIChfLCAkMSwgJDIpID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBzaG91bGQgYWxyZWFkeSBiZSBkb25lICovXG4gICAgICAgIGlmICghJDIpIHtcbiAgICAgICAgICAvLyB0aGUgfCBpc24ndCBhbHJlYWR5IGVzY2FwZWQsIHNvIGVzY2FwZSBpdC5cbiAgICAgICAgICAkMiA9ICdcXFxcJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmVlZCB0byBlc2NhcGUgYWxsIHRob3NlIHNsYXNoZXMgKmFnYWluKiwgd2l0aG91dCBlc2NhcGluZyB0aGVcbiAgICAgICAgLy8gb25lIHRoYXQgd2UgbmVlZCBmb3IgZXNjYXBpbmcgdGhlIHwgY2hhcmFjdGVyLiAgQXMgaXQgd29ya3Mgb3V0LFxuICAgICAgICAvLyBlc2NhcGluZyBhbiBldmVuIG51bWJlciBvZiBzbGFzaGVzIGNhbiBiZSBkb25lIGJ5IHNpbXBseSByZXBlYXRpbmdcbiAgICAgICAgLy8gaXQgZXhhY3RseSBhZnRlciBpdHNlbGYuICBUaGF0J3Mgd2h5IHRoaXMgdHJpY2sgd29ya3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEkgYW0gc29ycnkgdGhhdCB5b3UgaGF2ZSB0byBzZWUgdGhpcy5cbiAgICAgICAgcmV0dXJuICQxICsgJDEgKyAkMiArICd8J1xuICAgICAgfSlcblxuICAgICAgdGhpcy5kZWJ1ZygndGFpbD0lalxcbiAgICVzJywgdGFpbCwgdGFpbCwgcGwsIHJlKVxuICAgICAgY29uc3QgdCA9IHBsLnR5cGUgPT09ICcqJyA/IHN0YXJcbiAgICAgICAgOiBwbC50eXBlID09PSAnPycgPyBxbWFya1xuICAgICAgICA6ICdcXFxcJyArIHBsLnR5cGVcblxuICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICByZSA9IHJlLnNsaWNlKDAsIHBsLnJlU3RhcnQpICsgdCArICdcXFxcKCcgKyB0YWlsXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHRyYWlsaW5nIHRoaW5ncyB0aGF0IG9ubHkgbWF0dGVyIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAvLyB0cmFpbGluZyBcXFxcXG4gICAgICByZSArPSAnXFxcXFxcXFwnXG4gICAgfVxuXG4gICAgLy8gb25seSBuZWVkIHRvIGFwcGx5IHRoZSBub2RvdCBzdGFydCBpZiB0aGUgcmUgc3RhcnRzIHdpdGhcbiAgICAvLyBzb21ldGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBjYXB0dXJlIGEgZG90XG4gICAgY29uc3QgYWRkUGF0dGVyblN0YXJ0ID0gYWRkUGF0dGVyblN0YXJ0U2V0W3JlLmNoYXJBdCgwKV1cblxuICAgIC8vIEhhY2sgdG8gd29yayBhcm91bmQgbGFjayBvZiBuZWdhdGl2ZSBsb29rYmVoaW5kIGluIEpTXG4gICAgLy8gQSBwYXR0ZXJuIGxpa2U6ICouISh4KS4hKHl8eikgbmVlZHMgdG8gZW5zdXJlIHRoYXQgYSBuYW1lXG4gICAgLy8gbGlrZSAnYS54eXoueXonIGRvZXNuJ3QgbWF0Y2guICBTbywgdGhlIGZpcnN0IG5lZ2F0aXZlXG4gICAgLy8gbG9va2FoZWFkLCBoYXMgdG8gbG9vayBBTEwgdGhlIHdheSBhaGVhZCwgdG8gdGhlIGVuZCBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuLlxuICAgIGZvciAobGV0IG4gPSBuZWdhdGl2ZUxpc3RzLmxlbmd0aCAtIDE7IG4gPiAtMTsgbi0tKSB7XG4gICAgICBjb25zdCBubCA9IG5lZ2F0aXZlTGlzdHNbbl1cblxuICAgICAgY29uc3QgbmxCZWZvcmUgPSByZS5zbGljZSgwLCBubC5yZVN0YXJ0KVxuICAgICAgY29uc3QgbmxGaXJzdCA9IHJlLnNsaWNlKG5sLnJlU3RhcnQsIG5sLnJlRW5kIC0gOClcbiAgICAgIGxldCBubEFmdGVyID0gcmUuc2xpY2UobmwucmVFbmQpXG4gICAgICBjb25zdCBubExhc3QgPSByZS5zbGljZShubC5yZUVuZCAtIDgsIG5sLnJlRW5kKSArIG5sQWZ0ZXJcblxuICAgICAgLy8gSGFuZGxlIG5lc3RlZCBzdHVmZiBsaWtlICooKi5qc3whKCouanNvbikpLCB3aGVyZSBvcGVuIHBhcmVuc1xuICAgICAgLy8gbWVhbiB0aGF0IHdlIHNob3VsZCAqbm90KiBpbmNsdWRlIHRoZSApIGluIHRoZSBiaXQgdGhhdCBpcyBjb25zaWRlcmVkXG4gICAgICAvLyBcImFmdGVyXCIgdGhlIG5lZ2F0ZWQgc2VjdGlvbi5cbiAgICAgIGNvbnN0IGNsb3NlUGFyZW5zQmVmb3JlID0gbmxCZWZvcmUuc3BsaXQoJyknKS5sZW5ndGhcbiAgICAgIGNvbnN0IG9wZW5QYXJlbnNCZWZvcmUgPSBubEJlZm9yZS5zcGxpdCgnKCcpLmxlbmd0aCAtIGNsb3NlUGFyZW5zQmVmb3JlXG4gICAgICBsZXQgY2xlYW5BZnRlciA9IG5sQWZ0ZXJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BlblBhcmVuc0JlZm9yZTsgaSsrKSB7XG4gICAgICAgIGNsZWFuQWZ0ZXIgPSBjbGVhbkFmdGVyLnJlcGxhY2UoL1xcKVsrKj9dPy8sICcnKVxuICAgICAgfVxuICAgICAgbmxBZnRlciA9IGNsZWFuQWZ0ZXJcblxuICAgICAgY29uc3QgZG9sbGFyID0gbmxBZnRlciA9PT0gJycgJiYgaXNTdWIgIT09IFNVQlBBUlNFID8gJyg/OiR8XFxcXC8pJyA6ICcnXG5cbiAgICAgIHJlID0gbmxCZWZvcmUgKyBubEZpcnN0ICsgbmxBZnRlciArIGRvbGxhciArIG5sTGFzdFxuICAgIH1cblxuICAgIC8vIGlmIHRoZSByZSBpcyBub3QgXCJcIiBhdCB0aGlzIHBvaW50LCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gICAgLy8gaXQgZG9lc24ndCBtYXRjaCBhZ2FpbnN0IGFuIGVtcHR5IHBhdGggcGFydC5cbiAgICAvLyBPdGhlcndpc2UgYS8qIHdpbGwgbWF0Y2ggYS8sIHdoaWNoIGl0IHNob3VsZCBub3QuXG4gICAgaWYgKHJlICE9PSAnJyAmJiBoYXNNYWdpYykge1xuICAgICAgcmUgPSAnKD89LiknICsgcmVcbiAgICB9XG5cbiAgICBpZiAoYWRkUGF0dGVyblN0YXJ0KSB7XG4gICAgICByZSA9IHBhdHRlcm5TdGFydCgpICsgcmVcbiAgICB9XG5cbiAgICAvLyBwYXJzaW5nIGp1c3QgYSBwaWVjZSBvZiBhIGxhcmdlciBwYXR0ZXJuLlxuICAgIGlmIChpc1N1YiA9PT0gU1VCUEFSU0UpIHtcbiAgICAgIHJldHVybiBbcmUsIGhhc01hZ2ljXVxuICAgIH1cblxuICAgIC8vIGlmIGl0J3Mgbm9jYXNlLCBhbmQgdGhlIGxjYXNlL3VwcGVyY2FzZSBkb24ndCBtYXRjaCwgaXQncyBtYWdpY1xuICAgIGlmIChvcHRpb25zLm5vY2FzZSAmJiAhaGFzTWFnaWMpIHtcbiAgICAgIGhhc01hZ2ljID0gcGF0dGVybi50b1VwcGVyQ2FzZSgpICE9PSBwYXR0ZXJuLnRvTG93ZXJDYXNlKClcbiAgICB9XG5cbiAgICAvLyBza2lwIHRoZSByZWdleHAgZm9yIG5vbi1tYWdpY2FsIHBhdHRlcm5zXG4gICAgLy8gdW5lc2NhcGUgYW55dGhpbmcgaW4gaXQsIHRob3VnaCwgc28gdGhhdCBpdCdsbCBiZVxuICAgIC8vIGFuIGV4YWN0IG1hdGNoIGFnYWluc3QgYSBmaWxlIGV0Yy5cbiAgICBpZiAoIWhhc01hZ2ljKSB7XG4gICAgICByZXR1cm4gZ2xvYlVuZXNjYXBlKHBhdHRlcm4pXG4gICAgfVxuXG4gICAgY29uc3QgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBSZWdFeHAoJ14nICsgcmUgKyAnJCcsIGZsYWdzKSwge1xuICAgICAgICBfZ2xvYjogcGF0dGVybixcbiAgICAgICAgX3NyYzogcmUsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVyKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICAgIC8vIElmIGl0IHdhcyBhbiBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhlbiBpdCBjYW4ndCBtYXRjaFxuICAgICAgLy8gYW55dGhpbmcuICBUaGlzIHRyaWNrIGxvb2tzIGZvciBhIGNoYXJhY3RlciBhZnRlciB0aGUgZW5kIG9mXG4gICAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAgIC8vIG1vZGUsIGJ1dCBpdCdzIG5vdCBhIC9tIHJlZ2V4LlxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJyQuJylcbiAgICB9XG4gIH1cblxuICBtYWtlUmUgKCkge1xuICAgIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgdGhpcy5zZXQgaXMgYSAyZCBhcnJheSBvZiBwYXJ0aWFsXG4gICAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gICAgLy9cbiAgICAvLyBJdCdzIGJldHRlciB0byB1c2UgLm1hdGNoKCkuICBUaGlzIGZ1bmN0aW9uIHNob3VsZG4ndFxuICAgIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAgIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgICBjb25zdCBzZXQgPSB0aGlzLnNldFxuXG4gICAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gICAgICByZXR1cm4gdGhpcy5yZWdleHBcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gICAgY29uc3QgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhciA/IHN0YXJcbiAgICAgIDogb3B0aW9ucy5kb3QgPyB0d29TdGFyRG90XG4gICAgICA6IHR3b1N0YXJOb0RvdFxuICAgIGNvbnN0IGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuXG4gICAgLy8gY29hbGVzY2UgZ2xvYnN0YXJzIGFuZCByZWdleHBpZnkgbm9uLWdsb2JzdGFyIHBhdHRlcm5zXG4gICAgLy8gaWYgaXQncyB0aGUgb25seSBpdGVtLCB0aGVuIHdlIGp1c3QgZG8gb25lIHR3b1N0YXJcbiAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCwgYW5kIHRoZXJlIGFyZSBtb3JlLCBwcmVwZW5kIChcXC98dHdvU3RhclxcLyk/IHRvIG5leHRcbiAgICAvLyBpZiBpdCdzIHRoZSBsYXN0LCBhcHBlbmQgKFxcL3R3b1N0YXJ8KSB0byBwcmV2aW91c1xuICAgIC8vIGlmIGl0J3MgaW4gdGhlIG1pZGRsZSwgYXBwZW5kIChcXC98XFwvdHdvU3RhclxcLykgdG8gcHJldmlvdXNcbiAgICAvLyB0aGVuIGZpbHRlciBvdXQgR0xPQlNUQVIgc3ltYm9sc1xuICAgIGxldCByZSA9IHNldC5tYXAocGF0dGVybiA9PiB7XG4gICAgICBwYXR0ZXJuID0gcGF0dGVybi5tYXAocCA9PlxuICAgICAgICB0eXBlb2YgcCA9PT0gJ3N0cmluZycgPyByZWdFeHBFc2NhcGUocClcbiAgICAgICAgOiBwID09PSBHTE9CU1RBUiA/IEdMT0JTVEFSXG4gICAgICAgIDogcC5fc3JjXG4gICAgICApLnJlZHVjZSgoc2V0LCBwKSA9PiB7XG4gICAgICAgIGlmICghKHNldFtzZXQubGVuZ3RoIC0gMV0gPT09IEdMT0JTVEFSICYmIHAgPT09IEdMT0JTVEFSKSkge1xuICAgICAgICAgIHNldC5wdXNoKHApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFxuICAgICAgfSwgW10pXG4gICAgICBwYXR0ZXJuLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKHAgIT09IEdMT0JTVEFSIHx8IHBhdHRlcm5baS0xXSA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBhdHRlcm5baSsxXSA9ICcoPzpcXFxcXFwvfCcgKyB0d29TdGFyICsgJ1xcXFxcXC8pPycgKyBwYXR0ZXJuW2krMV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0dGVybltpXSA9IHR3b1N0YXJcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gcGF0dGVybi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcGF0dGVybltpLTFdICs9ICcoPzpcXFxcXFwvfCcgKyB0d29TdGFyICsgJyk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdHRlcm5baS0xXSArPSAnKD86XFxcXFxcL3xcXFxcXFwvJyArIHR3b1N0YXIgKyAnXFxcXFxcLyknICsgcGF0dGVybltpKzFdXG4gICAgICAgICAgcGF0dGVybltpKzFdID0gR0xPQlNUQVJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiBwYXR0ZXJuLmZpbHRlcihwID0+IHAgIT09IEdMT0JTVEFSKS5qb2luKCcvJylcbiAgICB9KS5qb2luKCd8JylcblxuICAgIC8vIG11c3QgbWF0Y2ggZW50aXJlIHBhdHRlcm5cbiAgICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gICAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gICAgaWYgKHRoaXMubmVnYXRlKSByZSA9ICdeKD8hJyArIHJlICsgJykuKiQnXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKHJlLCBmbGFncylcbiAgICB9IGNhdGNoIChleCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBzaG91bGQgYmUgaW1wb3NzaWJsZSAqLyB7XG4gICAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG5cbiAgbWF0Y2ggKGYsIHBhcnRpYWwgPSB0aGlzLnBhcnRpYWwpIHtcbiAgICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybilcbiAgICAvLyBzaG9ydC1jaXJjdWl0IGluIHRoZSBjYXNlIG9mIGJ1c3RlZCB0aGluZ3MuXG4gICAgLy8gY29tbWVudHMsIGV0Yy5cbiAgICBpZiAodGhpcy5jb21tZW50KSByZXR1cm4gZmFsc2VcbiAgICBpZiAodGhpcy5lbXB0eSkgcmV0dXJuIGYgPT09ICcnXG5cbiAgICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHJldHVybiB0cnVlXG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgICAvLyB3aW5kb3dzOiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgICAgZiA9IGYuc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICAgIH1cblxuICAgIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICAgIGYgPSBmLnNwbGl0KHNsYXNoU3BsaXQpXG4gICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGYpXG5cbiAgICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gICAgLy8gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHZhbGlkLiAgSWYgbmVnYXRpbmcsIHRoZW4ganVzdCBvbmVcbiAgICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAgIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuXG4gICAgY29uc3Qgc2V0ID0gdGhpcy5zZXRcbiAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldClcblxuICAgIC8vIEZpbmQgdGhlIGJhc2VuYW1lIG9mIHRoZSBwYXRoIGJ5IGxvb2tpbmcgZm9yIHRoZSBsYXN0IG5vbi1lbXB0eSBzZWdtZW50XG4gICAgbGV0IGZpbGVuYW1lXG4gICAgZm9yIChsZXQgaSA9IGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGZpbGVuYW1lID0gZltpXVxuICAgICAgaWYgKGZpbGVuYW1lKSBicmVha1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gc2V0W2ldXG4gICAgICBsZXQgZmlsZSA9IGZcbiAgICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBmaWxlID0gW2ZpbGVuYW1lXVxuICAgICAgfVxuICAgICAgY29uc3QgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKVxuICAgICAgaWYgKGhpdCkge1xuICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gdHJ1ZVxuICAgICAgICByZXR1cm4gIXRoaXMubmVnYXRlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGlkbid0IGdldCBhbnkgaGl0cy4gIHRoaXMgaXMgc3VjY2VzcyBpZiBpdCdzIGEgbmVnYXRpdmVcbiAgICAvLyBwYXR0ZXJuLCBmYWlsdXJlIG90aGVyd2lzZS5cbiAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gdGhpcy5uZWdhdGVcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0cyAoZGVmKSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaC5kZWZhdWx0cyhkZWYpLk1pbmltYXRjaFxuICB9XG59XG5cbm1pbmltYXRjaC5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2hcbiJdLCJuYW1lcyI6WyJtaW5pbWF0Y2giLCJtb2R1bGUiLCJleHBvcnRzIiwicCIsInBhdHRlcm4iLCJvcHRpb25zIiwiYXNzZXJ0VmFsaWRQYXR0ZXJuIiwibm9jb21tZW50IiwiY2hhckF0IiwiTWluaW1hdGNoIiwibWF0Y2giLCJwYXRoIiwicmVxdWlyZSIsInNlcCIsIkdMT0JTVEFSIiwiU3ltYm9sIiwiZXhwYW5kIiwicGxUeXBlcyIsIm9wZW4iLCJjbG9zZSIsInFtYXJrIiwic3RhciIsInR3b1N0YXJEb3QiLCJ0d29TdGFyTm9Eb3QiLCJjaGFyU2V0IiwicyIsInNwbGl0IiwicmVkdWNlIiwic2V0IiwiYyIsInJlU3BlY2lhbHMiLCJhZGRQYXR0ZXJuU3RhcnRTZXQiLCJzbGFzaFNwbGl0IiwiZmlsdGVyIiwiaSIsImxpc3QiLCJleHQiLCJhIiwiYiIsInQiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkZWZhdWx0cyIsImRlZiIsImxlbmd0aCIsIm9yaWciLCJtIiwiY29uc3RydWN0b3IiLCJtYWtlUmUiLCJicmFjZUV4cGFuZCIsIm5vYnJhY2UiLCJ0ZXN0IiwiTUFYX1BBVFRFUk5fTEVOR1RIIiwiVHlwZUVycm9yIiwiU1VCUEFSU0UiLCJtbSIsImYiLCJub251bGwiLCJwdXNoIiwiZ2xvYlVuZXNjYXBlIiwicmVwbGFjZSIsImNoYXJVbmVzY2FwZSIsInJlZ0V4cEVzY2FwZSIsImJyYUV4cEVzY2FwZSIsIndpbmRvd3NQYXRoc05vRXNjYXBlIiwiYWxsb3dXaW5kb3dzRXNjYXBlIiwicmVnZXhwIiwibmVnYXRlIiwiY29tbWVudCIsImVtcHR5IiwicGFydGlhbCIsIm1ha2UiLCJkZWJ1ZyIsInBhcnNlTmVnYXRlIiwiZ2xvYlNldCIsImFyZ3MiLCJjb25zb2xlIiwiZXJyb3IiLCJnbG9iUGFydHMiLCJtYXAiLCJzaSIsInBhcnNlIiwiaW5kZXhPZiIsIm5vbmVnYXRlIiwibmVnYXRlT2Zmc2V0Iiwic2xpY2UiLCJtYXRjaE9uZSIsImZpbGUiLCJmaSIsInBpIiwiZmwiLCJwbCIsImZyIiwicHIiLCJkb3QiLCJzd2FsbG93ZWUiLCJoaXQiLCJFcnJvciIsImlzU3ViIiwibm9nbG9ic3RhciIsInJlIiwiaGFzTWFnaWMiLCJlc2NhcGluZyIsInBhdHRlcm5MaXN0U3RhY2siLCJuZWdhdGl2ZUxpc3RzIiwic3RhdGVDaGFyIiwiaW5DbGFzcyIsInJlQ2xhc3NTdGFydCIsImNsYXNzU3RhcnQiLCJjcyIsInNwIiwiZG90VHJhdkFsbG93ZWQiLCJkb3RGaWxlQWxsb3dlZCIsInBhdHRlcm5TdGFydCIsInN1YlBhdHRlcm5TdGFydCIsImNsZWFyU3RhdGVDaGFyIiwibm9leHQiLCJwbEVudHJ5IiwidHlwZSIsInN0YXJ0IiwicmVTdGFydCIsInBvcCIsImFzc2lnbiIsInJlRW5kIiwic3Vic3RyaW5nIiwiUmVnRXhwIiwiZXIiLCJ0YWlsIiwiXyIsIiQxIiwiJDIiLCJhZGRQYXR0ZXJuU3RhcnQiLCJuIiwibmwiLCJubEJlZm9yZSIsIm5sRmlyc3QiLCJubEFmdGVyIiwibmxMYXN0IiwiY2xvc2VQYXJlbnNCZWZvcmUiLCJvcGVuUGFyZW5zQmVmb3JlIiwiY2xlYW5BZnRlciIsImRvbGxhciIsIm5vY2FzZSIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJmbGFncyIsIl9nbG9iIiwiX3NyYyIsInR3b1N0YXIiLCJqb2luIiwiZXgiLCJmaWxlbmFtZSIsIm1hdGNoQmFzZSIsImZsaXBOZWdhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readdir-glob/node_modules/minimatch/minimatch.js\n");

/***/ })

};
;