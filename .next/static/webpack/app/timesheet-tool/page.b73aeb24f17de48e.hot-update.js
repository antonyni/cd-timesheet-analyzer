"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/timesheet-tool/page",{

/***/ "(app-pages-browser)/./src/helpers/initializeHoursWorkedMap.jsx":
/*!**************************************************!*\
  !*** ./src/helpers/initializeHoursWorkedMap.jsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst initializeHoursWorkedMap = (hoursWorkedMap, simplifiedSchedule)=>{\n    Object.keys(simplifiedSchedule).forEach((weekName)=>{\n        if (!hoursWorkedMap[weekName]) {\n            hoursWorkedMap[weekName] = {\n                total: {\n                    totalHoursWorked: 0,\n                    totalHoursScheduled: 0,\n                    percentageAcceptedNumbers: {\n                        numberBelowPercentageAccepted: 0,\n                        totalNumberOfPercentages: 0\n                    }\n                },\n                interns: {}\n            };\n        }\n        Object.keys(simplifiedSchedule[weekName].interns).forEach((intern)=>{\n            const decimalHoursScheduled = simplifiedSchedule[weekName].interns[intern];\n            const normalHoursScheduled = decimalToHours(decimalHoursScheduled);\n            hoursWorkedMap[weekName].total.percentageAcceptedNumbers.totalNumberOfPercentages++;\n            if (weekName != \"total\") {\n                hoursWorkedMap.total.total.percentageAcceptedNumbers.totalNumberOfPercentages++;\n            }\n            if (!hoursWorkedMap[weekName].interns[intern]) {\n                hoursWorkedMap[weekName].interns[intern] = {};\n            }\n            const currIntern = hoursWorkedMap[weekName].interns[intern];\n            currIntern.normalHoursWorked = \"00:00\";\n            currIntern.normalHoursScheduled = normalHoursScheduled;\n            currIntern.percentageDifference = 0;\n        });\n        hoursWorkedMap[weekName].total.totalHoursScheduled = simplifiedSchedule[weekName].totalHoursScheduled;\n    });\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (initializeHoursWorkedMap);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9oZWxwZXJzL2luaXRpYWxpemVIb3Vyc1dvcmtlZE1hcC5qc3giLCJtYXBwaW5ncyI6IjtBQUNBLE1BQU1BLDJCQUEyQixDQUFDQyxnQkFBZ0JDO0lBQzlDQyxPQUFPQyxJQUFJLENBQUNGLG9CQUFvQkcsT0FBTyxDQUFDLENBQUNDO1FBQ3JDLElBQUksQ0FBQ0wsY0FBYyxDQUFDSyxTQUFTLEVBQUU7WUFDM0JMLGNBQWMsQ0FBQ0ssU0FBUyxHQUFHO2dCQUN2QkMsT0FBTztvQkFDSEMsa0JBQWtCO29CQUNsQkMscUJBQXFCO29CQUNyQkMsMkJBQTJCO3dCQUN2QkMsK0JBQStCO3dCQUMvQkMsMEJBQTBCO29CQUM5QjtnQkFDSjtnQkFDQUMsU0FBUyxDQUVUO1lBQ0o7UUFDSjtRQUVBVixPQUFPQyxJQUFJLENBQUNGLGtCQUFrQixDQUFDSSxTQUFTLENBQUNPLE9BQU8sRUFBRVIsT0FBTyxDQUFDLENBQUNTO1lBQ3ZELE1BQU1DLHdCQUF3QmIsa0JBQWtCLENBQUNJLFNBQVMsQ0FBQ08sT0FBTyxDQUFDQyxPQUFPO1lBQzFFLE1BQU1FLHVCQUF1QkMsZUFBZUY7WUFDNUNkLGNBQWMsQ0FBQ0ssU0FBUyxDQUFDQyxLQUFLLENBQUNHLHlCQUF5QixDQUFDRSx3QkFBd0I7WUFDakYsSUFBSU4sWUFBWSxTQUFTO2dCQUNyQkwsZUFBZU0sS0FBSyxDQUFDQSxLQUFLLENBQUNHLHlCQUF5QixDQUFDRSx3QkFBd0I7WUFDakY7WUFFQSxJQUFJLENBQUNYLGNBQWMsQ0FBQ0ssU0FBUyxDQUFDTyxPQUFPLENBQUNDLE9BQU8sRUFBRTtnQkFDM0NiLGNBQWMsQ0FBQ0ssU0FBUyxDQUFDTyxPQUFPLENBQUNDLE9BQU8sR0FBRyxDQUFDO1lBQ2hEO1lBRUEsTUFBTUksYUFBYWpCLGNBQWMsQ0FBQ0ssU0FBUyxDQUFDTyxPQUFPLENBQUNDLE9BQU87WUFDM0RJLFdBQVdDLGlCQUFpQixHQUFHO1lBQy9CRCxXQUFXRixvQkFBb0IsR0FBR0E7WUFDbENFLFdBQVdFLG9CQUFvQixHQUFHO1FBQ3RDO1FBQ0FuQixjQUFjLENBQUNLLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDRSxtQkFBbUIsR0FBR1Asa0JBQWtCLENBQUNJLFNBQVMsQ0FBQ0csbUJBQW1CO0lBQ3pHO0FBQ0o7QUFFQSwrREFBZVQsd0JBQXdCQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9oZWxwZXJzL2luaXRpYWxpemVIb3Vyc1dvcmtlZE1hcC5qc3g/YmEwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IGluaXRpYWxpemVIb3Vyc1dvcmtlZE1hcCA9IChob3Vyc1dvcmtlZE1hcCwgc2ltcGxpZmllZFNjaGVkdWxlKSA9PiB7XG4gICAgT2JqZWN0LmtleXMoc2ltcGxpZmllZFNjaGVkdWxlKS5mb3JFYWNoKCh3ZWVrTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXSkge1xuICAgICAgICAgICAgaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdID0ge1xuICAgICAgICAgICAgICAgIHRvdGFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsSG91cnNXb3JrZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsSG91cnNTY2hlZHVsZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2VBY2NlcHRlZE51bWJlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlckJlbG93UGVyY2VudGFnZUFjY2VwdGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxOdW1iZXJPZlBlcmNlbnRhZ2VzOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJuczoge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHNpbXBsaWZpZWRTY2hlZHVsZVt3ZWVrTmFtZV0uaW50ZXJucykuZm9yRWFjaCgoaW50ZXJuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFsSG91cnNTY2hlZHVsZWQgPSBzaW1wbGlmaWVkU2NoZWR1bGVbd2Vla05hbWVdLmludGVybnNbaW50ZXJuXTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbEhvdXJzU2NoZWR1bGVkID0gZGVjaW1hbFRvSG91cnMoZGVjaW1hbEhvdXJzU2NoZWR1bGVkKTtcbiAgICAgICAgICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbC5wZXJjZW50YWdlQWNjZXB0ZWROdW1iZXJzLnRvdGFsTnVtYmVyT2ZQZXJjZW50YWdlcysrO1xuICAgICAgICAgICAgaWYgKHdlZWtOYW1lICE9IFwidG90YWxcIikge1xuICAgICAgICAgICAgICAgIGhvdXJzV29ya2VkTWFwLnRvdGFsLnRvdGFsLnBlcmNlbnRhZ2VBY2NlcHRlZE51bWJlcnMudG90YWxOdW1iZXJPZlBlcmNlbnRhZ2VzKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdLmludGVybnNbaW50ZXJuXSkge1xuICAgICAgICAgICAgICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS5pbnRlcm5zW2ludGVybl0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY3VyckludGVybiA9IGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS5pbnRlcm5zW2ludGVybl07XG4gICAgICAgICAgICBjdXJySW50ZXJuLm5vcm1hbEhvdXJzV29ya2VkID0gXCIwMDowMFwiO1xuICAgICAgICAgICAgY3VyckludGVybi5ub3JtYWxIb3Vyc1NjaGVkdWxlZCA9IG5vcm1hbEhvdXJzU2NoZWR1bGVkO1xuICAgICAgICAgICAgY3VyckludGVybi5wZXJjZW50YWdlRGlmZmVyZW5jZSA9IDA7XG4gICAgICAgIH0pXG4gICAgICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbC50b3RhbEhvdXJzU2NoZWR1bGVkID0gc2ltcGxpZmllZFNjaGVkdWxlW3dlZWtOYW1lXS50b3RhbEhvdXJzU2NoZWR1bGVkO1xuICAgIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRpYWxpemVIb3Vyc1dvcmtlZE1hcDsiXSwibmFtZXMiOlsiaW5pdGlhbGl6ZUhvdXJzV29ya2VkTWFwIiwiaG91cnNXb3JrZWRNYXAiLCJzaW1wbGlmaWVkU2NoZWR1bGUiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsIndlZWtOYW1lIiwidG90YWwiLCJ0b3RhbEhvdXJzV29ya2VkIiwidG90YWxIb3Vyc1NjaGVkdWxlZCIsInBlcmNlbnRhZ2VBY2NlcHRlZE51bWJlcnMiLCJudW1iZXJCZWxvd1BlcmNlbnRhZ2VBY2NlcHRlZCIsInRvdGFsTnVtYmVyT2ZQZXJjZW50YWdlcyIsImludGVybnMiLCJpbnRlcm4iLCJkZWNpbWFsSG91cnNTY2hlZHVsZWQiLCJub3JtYWxIb3Vyc1NjaGVkdWxlZCIsImRlY2ltYWxUb0hvdXJzIiwiY3VyckludGVybiIsIm5vcm1hbEhvdXJzV29ya2VkIiwicGVyY2VudGFnZURpZmZlcmVuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/helpers/initializeHoursWorkedMap.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/helpers/makeTimeSheetAnalysis.jsx":
/*!***********************************************!*\
  !*** ./src/helpers/makeTimeSheetAnalysis.jsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var exceljs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! exceljs */ \"(app-pages-browser)/./node_modules/exceljs/dist/exceljs.min.js\");\n/* harmony import */ var exceljs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(exceljs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hoursToDecimal */ \"(app-pages-browser)/./src/helpers/hoursToDecimal.jsx\");\n/* harmony import */ var _getDateFromString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getDateFromString */ \"(app-pages-browser)/./src/helpers/getDateFromString.jsx\");\n/* harmony import */ var _decimalToHours__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./decimalToHours */ \"(app-pages-browser)/./src/helpers/decimalToHours.jsx\");\n/* harmony import */ var _getWeekBefore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWeekBefore */ \"(app-pages-browser)/./src/helpers/getWeekBefore.jsx\");\n/* harmony import */ var _initializeHoursWorkedMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./initializeHoursWorkedMap */ \"(app-pages-browser)/./src/helpers/initializeHoursWorkedMap.jsx\");\n/* harmony import */ var _populateHoursWorkedMap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./populateHoursWorkedMap */ \"(app-pages-browser)/./src/helpers/populateHoursWorkedMap.jsx\");\n\n\n\n\n\n\n\n\nconst makeTimesheetAnalysis = (timesheetExcel, simplifiedSchedule, percentageAccepted, taMap)=>{\n    const workbook = new exceljs__WEBPACK_IMPORTED_MODULE_0__.Workbook();\n    if (!taMap) {\n        taMap = {};\n    }\n    const hoursWorkedMap = {\n        total: {\n            total: {\n                totalHoursWorked: 0,\n                totalHoursScheduled: 0,\n                percentageAcceptedNumbers: {\n                    numberBelowPercentageAccepted: 0,\n                    totalNumberOfPercentages: 0\n                }\n            },\n            interns: {}\n        }\n    };\n    (0,_initializeHoursWorkedMap__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(hoursWorkedMap, simplifiedSchedule);\n    (0,_populateHoursWorkedMap__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(timesheetExcel, hoursWorkedMap, simplifiedSchedule, percentageAccepted);\n    processChangeFromPreviousWeek(hoursWorkedMap);\n    console.log(hoursWorkedMap[\"1-1-2024 to 1-7-2024\"][\"interns\"]);\n    makeSheets(workbook, hoursWorkedMap, percentageAccepted, taMap);\n    workbook.xlsx.writeBuffer().then((data)=>{\n        const blob = new Blob([\n            data\n        ]);\n        file_saver__WEBPACK_IMPORTED_MODULE_1__.saveAs(blob, \"Timesheet Analysis.xlsx\");\n    });\n};\nconst setUpNewSheet = (weekName, workbook, percentageAccepted)=>{\n    const sheet = workbook.addWorksheet(weekName);\n    sheet.views = [\n        {}\n    ];\n    sheet.properties.defaultColWidth = 15;\n    sheet.properties.defaultRowHeight = 20;\n    setUpColumns(sheet, percentageAccepted);\n    return sheet;\n};\nconst setUpColumns = (worksheet, percentageAccepted)=>{\n    const firstName = worksheet.getColumn(1);\n    firstName.header = \"First Name\";\n    firstName.key = \"firstName\";\n    const lastName = worksheet.getColumn(2);\n    lastName.header = \"Last Name\";\n    lastName.key = \"lastName\";\n    const hoursWorked = worksheet.getColumn(3);\n    hoursWorked.header = \"Hours Worked\";\n    hoursWorked.key = \"hoursWorked\";\n    const hoursScheduled = worksheet.getColumn(4);\n    hoursScheduled.header = \"Hours Scheduled\";\n    hoursScheduled.key = \"hoursScheduled\";\n    const percentWorked = worksheet.getColumn(5);\n    percentWorked.header = \"Percent Worked\";\n    percentWorked.key = \"percentWorked\";\n    const changeFromPreviousWeek = worksheet.getColumn(6);\n    changeFromPreviousWeek.header = \"Percent Change from Last Week\";\n    changeFromPreviousWeek.key = \"changeFromPreviousWeek\";\n    changeFromPreviousWeek.width = 25;\n    const taAssigned = worksheet.getColumn(7);\n    taAssigned.header = \"TA\";\n    taAssigned.key = \"ta\";\n    const percentAboveAccepted = worksheet.getColumn(8);\n    percentAboveAccepted.header = \"Percentage above \" + percentageAccepted;\n    percentAboveAccepted.key = \"percentAboveAccepeted\";\n    percentAboveAccepted.width = 20;\n    const totalWorked = worksheet.getColumn(9);\n    totalWorked.header = \"Total Worked\";\n    totalWorked.key = \"totalWorked\";\n    const totalScheduled = worksheet.getColumn(10);\n    totalScheduled.header = \"Total Scheduled\";\n    totalScheduled.key = \"totalScheduled\";\n    const totalPercentWorked = worksheet.getColumn(11);\n    totalPercentWorked.header = \"Percent Worked\";\n    totalPercentWorked.key = \"totalPercentWorked\";\n    const totalPercentChange = worksheet.getColumn(12);\n    totalPercentChange.header = \"Total Percent Change from Last Week\";\n    totalPercentChange.key = \"totalPercentChange\";\n    totalPercentChange.width = 30;\n};\nconst makeSheets = (workbook, hoursWorkedMap, percentageAccepted, taMap)=>{\n    Object.keys(hoursWorkedMap).forEach((weekName)=>{\n        const sheet = setUpNewSheet(weekName, workbook, percentageAccepted);\n        Object.keys(hoursWorkedMap[weekName].interns).forEach((intern)=>{\n            const currentInternData = hoursWorkedMap[weekName].interns[intern];\n            const firstName = currentInternData.firstName ? currentInternData.firstName : intern.split(\" \")[0];\n            const lastName = currentInternData.lastName ? currentInternData.lastName : intern.split(\" \").slice(1).join(\" \");\n            sheet.addRow({\n                firstName: firstName[0].toUpperCase() + firstName.slice(1),\n                lastName: lastName[0].toUpperCase() + lastName.slice(1),\n                hoursWorked: currentInternData.normalHoursWorked,\n                hoursScheduled: currentInternData.normalHoursScheduled,\n                percentWorked: currentInternData.percentageDifference == 0 ? \"0\" : currentInternData.percentageDifference,\n                changeFromPreviousWeek: currentInternData.changeFromPreviousWeek,\n                ta: taMap[intern]\n            });\n            colorPercentageCell(sheet, percentageAccepted);\n        });\n        sheet.getCell(2, 8).value = hoursWorkedMap[weekName].total.percentageAcceptedNumbers.percentageDifference;\n        sheet.getCell(2, 9).value = hoursWorkedMap[weekName].total.totalHoursWorked;\n        sheet.getCell(2, 10).value = hoursWorkedMap[weekName].total.totalHoursScheduled;\n        sheet.getCell(2, 11).value = hoursWorkedMap[weekName].total.percentageDifference;\n        sheet.getCell(2, 12).value = hoursWorkedMap[weekName].total.changeFromPreviousWeek;\n    });\n};\nconst processHoursData = (row, timeSheet, hoursWorkedMap, currentIntern, weekName, simplifiedSchedule, percentageAccepted)=>{\n    const normalHoursWorked = timeSheet.getCell(row, 15).value ? timeSheet.getCell(row, 15).value : \"0:00\";\n    hoursWorkedMap[weekName].interns[currentIntern].normalHoursWorked = normalHoursWorked;\n    const decimalHoursScheduled = simplifiedSchedule[weekName].interns[currentIntern];\n    const decimalHoursWorked = (0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(normalHoursWorked);\n    hoursWorkedMap[weekName].total.totalHoursWorked += decimalHoursWorked;\n    const totalInternHoursWorked = hoursWorkedMap.total.interns[currentIntern].normalHoursWorked;\n    hoursWorkedMap[weekName].total.percentageDifference = (hoursWorkedMap[weekName].total.totalHoursWorked / hoursWorkedMap[weekName].total.totalHoursScheduled * 100).toFixed(2);\n    hoursWorkedMap.total.interns[currentIntern].normalHoursWorked = (0,_decimalToHours__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(totalInternHoursWorked) + decimalHoursWorked);\n    hoursWorkedMap.total.interns[currentIntern].percentageDifference = ((0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(hoursWorkedMap.total.interns[currentIntern].normalHoursWorked) / (0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(hoursWorkedMap.total.interns[currentIntern].normalHoursScheduled) * 100).toFixed(2);\n    hoursWorkedMap.total.total.totalHoursWorked += decimalHoursWorked;\n    hoursWorkedMap.total.total.percentageDifference = (hoursWorkedMap.total.total.totalHoursWorked / hoursWorkedMap.total.total.totalHoursScheduled * 100).toFixed(2);\n    const percentageDifference = (decimalHoursWorked / decimalHoursScheduled * 100).toFixed(2);\n    hoursWorkedMap[weekName].interns[currentIntern].percentageDifference = percentageDifference;\n    if (percentageDifference < percentageAccepted) {\n        hoursWorkedMap[weekName].total.percentageAcceptedNumbers.numberBelowPercentageAccepted++;\n        if (weekName != \"total\") {\n            hoursWorkedMap.total.total.percentageAcceptedNumbers.numberBelowPercentageAccepted++;\n        }\n    }\n};\nconst processChangeFromPreviousWeek = (hoursWorkedMap)=>{\n    Object.keys(hoursWorkedMap).forEach((date)=>{\n        const workWeekPercentages = hoursWorkedMap[date].total.percentageAcceptedNumbers;\n        workWeekPercentages.percentageDifference = ((workWeekPercentages.totalNumberOfPercentages - workWeekPercentages.numberBelowPercentageAccepted) / workWeekPercentages.totalNumberOfPercentages * 100).toFixed(2);\n        if (date != \"total\") {\n            const weekBefore = (0,_getWeekBefore__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(date);\n            if (hoursWorkedMap[weekBefore]) {\n                Object.keys(hoursWorkedMap[date].interns).forEach((intern)=>{\n                    hoursWorkedMap[date].interns[intern].changeFromPreviousWeek = (parseFloat(hoursWorkedMap[date].interns[intern].percentageDifference) - parseFloat(hoursWorkedMap[weekBefore].interns[intern].percentageDifference)).toFixed(2);\n                });\n                hoursWorkedMap[date].total.changeFromPreviousWeek = (parseFloat(hoursWorkedMap[date].total.percentageDifference) - parseFloat(hoursWorkedMap[weekBefore].total.percentageDifference)).toFixed(2);\n            }\n        }\n    });\n};\nconst colorPercentageCell = (currSheet, percentageAccepted)=>{\n    const currCell = currSheet.getCell(currSheet.rowCount, 5);\n    const changeFromPreviousWeek = currSheet.getCell(currSheet.rowCount, 6);\n    if (parseFloat(currCell.value) < percentageAccepted) {\n        currCell.fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"80e76060\"\n            }\n        };\n    }\n    if (parseFloat(currCell.value) > 100) {\n        currCell.fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"80ffff00\"\n            }\n        };\n    }\n    if (parseFloat(changeFromPreviousWeek.value) < -15) {\n        changeFromPreviousWeek.fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"80e76060\"\n            }\n        };\n    }\n    if (parseFloat(changeFromPreviousWeek.value) > 15) {\n        changeFromPreviousWeek.fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"8042f58d\"\n            }\n        };\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (makeTimesheetAnalysis);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9oZWxwZXJzL21ha2VUaW1lU2hlZXRBbmFseXNpcy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0M7QUFDSztBQUNPO0FBQ007QUFDTjtBQUNGO0FBQ3NCO0FBQ0o7QUFFOUQsTUFBTVEsd0JBQXdCLENBQUNDLGdCQUFnQkMsb0JBQW9CQyxvQkFBb0JDO0lBQ25GLE1BQU1DLFdBQVcsSUFBSWIsNkNBQWdCO0lBQ3JDLElBQUcsQ0FBQ1ksT0FBTTtRQUNOQSxRQUFRLENBQUM7SUFDYjtJQUNBLE1BQU1HLGlCQUFpQjtRQUNuQkMsT0FBTztZQUNIQSxPQUFPO2dCQUNIQyxrQkFBa0I7Z0JBQ2xCQyxxQkFBcUI7Z0JBQ3JCQywyQkFBMkI7b0JBQ3ZCQywrQkFBK0I7b0JBQy9CQywwQkFBMEI7Z0JBQzlCO1lBQ0o7WUFDQUMsU0FBUyxDQUVUO1FBQ0o7SUFFSjtJQUVBaEIscUVBQXdCQSxDQUFDUyxnQkFBZ0JMO0lBQ3pDSCxtRUFBc0JBLENBQUNFLGdCQUFnQk0sZ0JBQWdCTCxvQkFBb0JDO0lBQzNFWSw4QkFBOEJSO0lBQzlCUyxRQUFRQyxHQUFHLENBQUNWLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVO0lBQzdEVyxXQUFXYixVQUFVRSxnQkFBZ0JKLG9CQUFvQkM7SUFDekRDLFNBQVNjLElBQUksQ0FBQ0MsV0FBVyxHQUFHQyxJQUFJLENBQUNDLENBQUFBO1FBQzdCLE1BQU1DLE9BQU8sSUFBSUMsS0FBSztZQUFDRjtTQUFLO1FBQzVCN0IsOENBQWdCLENBQUM4QixNQUFNO0lBQzNCO0FBRUo7QUFFQSxNQUFNRyxnQkFBZ0IsQ0FBQ0MsVUFBVXRCLFVBQVVGO0lBQ3ZDLE1BQU15QixRQUFRdkIsU0FBU3dCLFlBQVksQ0FBQ0Y7SUFDcENDLE1BQU1FLEtBQUssR0FBRztRQUFDLENBQUM7S0FBRTtJQUNsQkYsTUFBTUcsVUFBVSxDQUFDQyxlQUFlLEdBQUc7SUFDbkNKLE1BQU1HLFVBQVUsQ0FBQ0UsZ0JB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O1FBQy9DeEIsdUJBQXVCd0MsSUFBSSxHQUFHO1lBQzFCQyxNQUFNO1lBQ05DLFNBQVM7WUFDVEMsU0FBUztnQkFBRUMsTUFBTTtZQUFXO1FBQ2hDO0lBQ0o7QUFDSjtBQUdBLCtEQUFleEYscUJBQXFCQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9oZWxwZXJzL21ha2VUaW1lU2hlZXRBbmFseXNpcy5qc3g/OTVhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFeGNlbEpTIGZyb20gJ2V4Y2VsanMnXG5pbXBvcnQgKiBhcyBGaWxlU2F2ZXIgZnJvbSAnZmlsZS1zYXZlcidcbmltcG9ydCBob3Vyc1RvRGVjaW1hbCBmcm9tICcuL2hvdXJzVG9EZWNpbWFsJztcbmltcG9ydCBnZXREYXRlRnJvbVN0cmluZyBmcm9tICcuL2dldERhdGVGcm9tU3RyaW5nJztcbmltcG9ydCBkZWNpbWFsVG9Ib3VycyBmcm9tICcuL2RlY2ltYWxUb0hvdXJzJztcbmltcG9ydCBnZXRXZWVrQmVmb3JlIGZyb20gJy4vZ2V0V2Vla0JlZm9yZSc7XG5pbXBvcnQgaW5pdGlhbGl6ZUhvdXJzV29ya2VkTWFwIGZyb20gJy4vaW5pdGlhbGl6ZUhvdXJzV29ya2VkTWFwJztcbmltcG9ydCBwb3B1bGF0ZUhvdXJzV29ya2VkTWFwIGZyb20gJy4vcG9wdWxhdGVIb3Vyc1dvcmtlZE1hcCc7XG5cbmNvbnN0IG1ha2VUaW1lc2hlZXRBbmFseXNpcyA9ICh0aW1lc2hlZXRFeGNlbCwgc2ltcGxpZmllZFNjaGVkdWxlLCBwZXJjZW50YWdlQWNjZXB0ZWQsIHRhTWFwKSA9PiB7XG4gICAgY29uc3Qgd29ya2Jvb2sgPSBuZXcgRXhjZWxKUy5Xb3JrYm9vaygpO1xuICAgIGlmKCF0YU1hcCl7XG4gICAgICAgIHRhTWFwID0ge307XG4gICAgfVxuICAgIGNvbnN0IGhvdXJzV29ya2VkTWFwID0ge1xuICAgICAgICB0b3RhbDoge1xuICAgICAgICAgICAgdG90YWw6IHtcbiAgICAgICAgICAgICAgICB0b3RhbEhvdXJzV29ya2VkOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsSG91cnNTY2hlZHVsZWQ6IDAsXG4gICAgICAgICAgICAgICAgcGVyY2VudGFnZUFjY2VwdGVkTnVtYmVyczoge1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJCZWxvd1BlcmNlbnRhZ2VBY2NlcHRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxOdW1iZXJPZlBlcmNlbnRhZ2VzOiAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZXJuczoge1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuXG4gICAgfTtcblxuICAgIGluaXRpYWxpemVIb3Vyc1dvcmtlZE1hcChob3Vyc1dvcmtlZE1hcCwgc2ltcGxpZmllZFNjaGVkdWxlKTtcbiAgICBwb3B1bGF0ZUhvdXJzV29ya2VkTWFwKHRpbWVzaGVldEV4Y2VsLCBob3Vyc1dvcmtlZE1hcCwgc2ltcGxpZmllZFNjaGVkdWxlLCBwZXJjZW50YWdlQWNjZXB0ZWQpO1xuICAgIHByb2Nlc3NDaGFuZ2VGcm9tUHJldmlvdXNXZWVrKGhvdXJzV29ya2VkTWFwKTtcbiAgICBjb25zb2xlLmxvZyhob3Vyc1dvcmtlZE1hcFtcIjEtMS0yMDI0IHRvIDEtNy0yMDI0XCJdW1wiaW50ZXJuc1wiXSkgXG4gICAgbWFrZVNoZWV0cyh3b3JrYm9vaywgaG91cnNXb3JrZWRNYXAsIHBlcmNlbnRhZ2VBY2NlcHRlZCwgdGFNYXApO1xuICAgIHdvcmtib29rLnhsc3gud3JpdGVCdWZmZXIoKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgICAgICAgRmlsZVNhdmVyLnNhdmVBcyhibG9iLCBcIlRpbWVzaGVldCBBbmFseXNpcy54bHN4XCIpO1xuICAgIH0pO1xuXG59XG5cbmNvbnN0IHNldFVwTmV3U2hlZXQgPSAod2Vla05hbWUsIHdvcmtib29rLCBwZXJjZW50YWdlQWNjZXB0ZWQpID0+IHtcbiAgICBjb25zdCBzaGVldCA9IHdvcmtib29rLmFkZFdvcmtzaGVldCh3ZWVrTmFtZSk7XG4gICAgc2hlZXQudmlld3MgPSBbe31dO1xuICAgIHNoZWV0LnByb3BlcnRpZXMuZGVmYXVsdENvbFdpZHRoID0gMTU7XG4gICAgc2hlZXQucHJvcGVydGllcy5kZWZhdWx0Um93SGVpZ2h0ID0gMjA7XG4gICAgc2V0VXBDb2x1bW5zKHNoZWV0LCBwZXJjZW50YWdlQWNjZXB0ZWQpO1xuICAgIHJldHVybiBzaGVldDtcbn1cblxuY29uc3Qgc2V0VXBDb2x1bW5zID0gKHdvcmtzaGVldCwgcGVyY2VudGFnZUFjY2VwdGVkKSA9PiB7XG4gICAgY29uc3QgZmlyc3ROYW1lID0gd29ya3NoZWV0LmdldENvbHVtbigxKTtcbiAgICBmaXJzdE5hbWUuaGVhZGVyID0gXCJGaXJzdCBOYW1lXCI7XG4gICAgZmlyc3ROYW1lLmtleSA9IFwiZmlyc3ROYW1lXCI7XG5cbiAgICBjb25zdCBsYXN0TmFtZSA9IHdvcmtzaGVldC5nZXRDb2x1bW4oMik7XG4gICAgbGFzdE5hbWUuaGVhZGVyID0gXCJMYXN0IE5hbWVcIjtcbiAgICBsYXN0TmFtZS5rZXkgPSBcImxhc3ROYW1lXCI7XG5cbiAgICBjb25zdCBob3Vyc1dvcmtlZCA9IHdvcmtzaGVldC5nZXRDb2x1bW4oMyk7XG4gICAgaG91cnNXb3JrZWQuaGVhZGVyID0gXCJIb3VycyBXb3JrZWRcIjtcbiAgICBob3Vyc1dvcmtlZC5rZXkgPSBcImhvdXJzV29ya2VkXCI7XG5cbiAgICBjb25zdCBob3Vyc1NjaGVkdWxlZCA9IHdvcmtzaGVldC5nZXRDb2x1bW4oNCk7XG4gICAgaG91cnNTY2hlZHVsZWQuaGVhZGVyID0gXCJIb3VycyBTY2hlZHVsZWRcIjtcbiAgICBob3Vyc1NjaGVkdWxlZC5rZXkgPSBcImhvdXJzU2NoZWR1bGVkXCI7XG5cblxuICAgIGNvbnN0IHBlcmNlbnRXb3JrZWQgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDUpO1xuICAgIHBlcmNlbnRXb3JrZWQuaGVhZGVyID0gXCJQZXJjZW50IFdvcmtlZFwiO1xuICAgIHBlcmNlbnRXb3JrZWQua2V5ID0gXCJwZXJjZW50V29ya2VkXCI7XG5cbiAgICBjb25zdCBjaGFuZ2VGcm9tUHJldmlvdXNXZWVrID0gd29ya3NoZWV0LmdldENvbHVtbig2KTtcbiAgICBjaGFuZ2VGcm9tUHJldmlvdXNXZWVrLmhlYWRlciA9IFwiUGVyY2VudCBDaGFuZ2UgZnJvbSBMYXN0IFdlZWtcIjtcbiAgICBjaGFuZ2VGcm9tUHJldmlvdXNXZWVrLmtleSA9IFwiY2hhbmdlRnJvbVByZXZpb3VzV2Vla1wiO1xuICAgIGNoYW5nZUZyb21QcmV2aW91c1dlZWsud2lkdGggPSAyNTtcblxuICAgIGNvbnN0IHRhQXNzaWduZWQgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDcpO1xuICAgIHRhQXNzaWduZWQuaGVhZGVyID0gXCJUQVwiO1xuICAgIHRhQXNzaWduZWQua2V5ID0gXCJ0YVwiO1xuXG4gICAgY29uc3QgcGVyY2VudEFib3ZlQWNjZXB0ZWQgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDgpO1xuICAgIHBlcmNlbnRBYm92ZUFjY2VwdGVkLmhlYWRlciA9IFwiUGVyY2VudGFnZSBhYm92ZSBcIiArIHBlcmNlbnRhZ2VBY2NlcHRlZDtcbiAgICBwZXJjZW50QWJvdmVBY2NlcHRlZC5rZXkgPSBcInBlcmNlbnRBYm92ZUFjY2VwZXRlZFwiO1xuICAgIHBlcmNlbnRBYm92ZUFjY2VwdGVkLndpZHRoID0gMjA7XG5cblxuICAgIGNvbnN0IHRvdGFsV29ya2VkID0gd29ya3NoZWV0LmdldENvbHVtbig5KTtcbiAgICB0b3RhbFdvcmtlZC5oZWFkZXIgPSBcIlRvdGFsIFdvcmtlZFwiO1xuICAgIHRvdGFsV29ya2VkLmtleSA9IFwidG90YWxXb3JrZWRcIjtcblxuICAgIGNvbnN0IHRvdGFsU2NoZWR1bGVkID0gd29ya3NoZWV0LmdldENvbHVtbigxMCk7XG4gICAgdG90YWxTY2hlZHVsZWQuaGVhZGVyID0gXCJUb3RhbCBTY2hlZHVsZWRcIjtcbiAgICB0b3RhbFNjaGVkdWxlZC5rZXkgPSBcInRvdGFsU2NoZWR1bGVkXCI7XG5cbiAgICBjb25zdCB0b3RhbFBlcmNlbnRXb3JrZWQgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDExKTtcbiAgICB0b3RhbFBlcmNlbnRXb3JrZWQuaGVhZGVyID0gXCJQZXJjZW50IFdvcmtlZFwiO1xuICAgIHRvdGFsUGVyY2VudFdvcmtlZC5rZXkgPSBcInRvdGFsUGVyY2VudFdvcmtlZFwiO1xuXG4gICAgY29uc3QgdG90YWxQZXJjZW50Q2hhbmdlID0gd29ya3NoZWV0LmdldENvbHVtbigxMik7XG4gICAgdG90YWxQZXJjZW50Q2hhbmdlLmhlYWRlciA9IFwiVG90YWwgUGVyY2VudCBDaGFuZ2UgZnJvbSBMYXN0IFdlZWtcIjtcbiAgICB0b3RhbFBlcmNlbnRDaGFuZ2Uua2V5ID0gXCJ0b3RhbFBlcmNlbnRDaGFuZ2VcIjtcbiAgICB0b3RhbFBlcmNlbnRDaGFuZ2Uud2lkdGggPSAzMDtcblxuXG59XG5cbmNvbnN0IG1ha2VTaGVldHMgPSAod29ya2Jvb2ssIGhvdXJzV29ya2VkTWFwLCBwZXJjZW50YWdlQWNjZXB0ZWQsIHRhTWFwKSA9PiB7XG5cbiAgICBPYmplY3Qua2V5cyhob3Vyc1dvcmtlZE1hcCkuZm9yRWFjaCgod2Vla05hbWUpID0+IHtcbiAgICAgICAgY29uc3Qgc2hlZXQgPSBzZXRVcE5ld1NoZWV0KHdlZWtOYW1lLCB3b3JrYm9vaywgcGVyY2VudGFnZUFjY2VwdGVkKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0uaW50ZXJucykuZm9yRWFjaCgoaW50ZXJuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SW50ZXJuRGF0YSA9IGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS5pbnRlcm5zW2ludGVybl07XG4gICAgICAgICAgICBjb25zdCBmaXJzdE5hbWUgPSBjdXJyZW50SW50ZXJuRGF0YS5maXJzdE5hbWUgPyBjdXJyZW50SW50ZXJuRGF0YS5maXJzdE5hbWUgOiBpbnRlcm4uc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3ROYW1lID0gY3VycmVudEludGVybkRhdGEubGFzdE5hbWUgPyBjdXJyZW50SW50ZXJuRGF0YS5sYXN0TmFtZSA6IGludGVybi5zcGxpdCgnICcpLnNsaWNlKDEpLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIHNoZWV0LmFkZFJvdyh7XG4gICAgICAgICAgICAgICAgZmlyc3ROYW1lOiBmaXJzdE5hbWVbMF0udG9VcHBlckNhc2UoKSArIGZpcnN0TmFtZS5zbGljZSgxKSxcbiAgICAgICAgICAgICAgICBsYXN0TmFtZTogbGFzdE5hbWVbMF0udG9VcHBlckNhc2UoKSArIGxhc3ROYW1lLnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgIGhvdXJzV29ya2VkOiBjdXJyZW50SW50ZXJuRGF0YS5ub3JtYWxIb3Vyc1dvcmtlZCxcbiAgICAgICAgICAgICAgICBob3Vyc1NjaGVkdWxlZDogY3VycmVudEludGVybkRhdGEubm9ybWFsSG91cnNTY2hlZHVsZWQsXG4gICAgICAgICAgICAgICAgcGVyY2VudFdvcmtlZDogY3VycmVudEludGVybkRhdGEucGVyY2VudGFnZURpZmZlcmVuY2UgPT0gMCA/IFwiMFwiIDogY3VycmVudEludGVybkRhdGEucGVyY2VudGFnZURpZmZlcmVuY2UsXG4gICAgICAgICAgICAgICAgY2hhbmdlRnJvbVByZXZpb3VzV2VlazogY3VycmVudEludGVybkRhdGEuY2hhbmdlRnJvbVByZXZpb3VzV2VlayxcbiAgICAgICAgICAgICAgICB0YTogdGFNYXBbaW50ZXJuXSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBjb2xvclBlcmNlbnRhZ2VDZWxsKHNoZWV0LCBwZXJjZW50YWdlQWNjZXB0ZWQpO1xuXG4gICAgICAgIH0pXG4gICAgICAgIHNoZWV0LmdldENlbGwoMiw4KS52YWx1ZSA9IGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbC5wZXJjZW50YWdlQWNjZXB0ZWROdW1iZXJzLnBlcmNlbnRhZ2VEaWZmZXJlbmNlO1xuICAgICAgICBzaGVldC5nZXRDZWxsKDIsOSkudmFsdWUgPSBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0udG90YWwudG90YWxIb3Vyc1dvcmtlZDtcbiAgICAgICAgc2hlZXQuZ2V0Q2VsbCgyLDEwKS52YWx1ZSA9IGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbC50b3RhbEhvdXJzU2NoZWR1bGVkO1xuICAgICAgICBzaGVldC5nZXRDZWxsKDIsMTEpLnZhbHVlID0gaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdLnRvdGFsLnBlcmNlbnRhZ2VEaWZmZXJlbmNlO1xuICAgICAgICBzaGVldC5nZXRDZWxsKDIsMTIpLnZhbHVlID0gaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdLnRvdGFsLmNoYW5nZUZyb21QcmV2aW91c1dlZWs7XG5cbiAgICB9KVxuXG59XG5cbmNvbnN0IHByb2Nlc3NIb3Vyc0RhdGEgPSAocm93LCB0aW1lU2hlZXQsIGhvdXJzV29ya2VkTWFwLCBjdXJyZW50SW50ZXJuLCB3ZWVrTmFtZSwgc2ltcGxpZmllZFNjaGVkdWxlLCBwZXJjZW50YWdlQWNjZXB0ZWQpID0+IHtcbiAgICBjb25zdCBub3JtYWxIb3Vyc1dvcmtlZCA9IHRpbWVTaGVldC5nZXRDZWxsKHJvdywgMTUpLnZhbHVlID8gdGltZVNoZWV0LmdldENlbGwocm93LCAxNSkudmFsdWUgOiBcIjA6MDBcIjtcblxuICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS5pbnRlcm5zW2N1cnJlbnRJbnRlcm5dLm5vcm1hbEhvdXJzV29ya2VkID0gbm9ybWFsSG91cnNXb3JrZWQ7XG5cbiAgICBjb25zdCBkZWNpbWFsSG91cnNTY2hlZHVsZWQgPSBzaW1wbGlmaWVkU2NoZWR1bGVbd2Vla05hbWVdLmludGVybnNbY3VycmVudEludGVybl07XG4gICAgY29uc3QgZGVjaW1hbEhvdXJzV29ya2VkID0gaG91cnNUb0RlY2ltYWwobm9ybWFsSG91cnNXb3JrZWQpO1xuXG5cbiAgICBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0udG90YWwudG90YWxIb3Vyc1dvcmtlZCArPSBkZWNpbWFsSG91cnNXb3JrZWQ7XG4gICAgY29uc3QgdG90YWxJbnRlcm5Ib3Vyc1dvcmtlZCA9IGhvdXJzV29ya2VkTWFwLnRvdGFsLmludGVybnNbY3VycmVudEludGVybl0ubm9ybWFsSG91cnNXb3JrZWQ7XG4gICAgaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdLnRvdGFsLnBlcmNlbnRhZ2VEaWZmZXJlbmNlID0gKGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbC50b3RhbEhvdXJzV29ya2VkIC8gaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdLnRvdGFsLnRvdGFsSG91cnNTY2hlZHVsZWQgKiAxMDApLnRvRml4ZWQoMik7XG5cbiAgICBob3Vyc1dvcmtlZE1hcC50b3RhbC5pbnRlcm5zW2N1cnJlbnRJbnRlcm5dLm5vcm1hbEhvdXJzV29ya2VkID0gZGVjaW1hbFRvSG91cnMoaG91cnNUb0RlY2ltYWwodG90YWxJbnRlcm5Ib3Vyc1dvcmtlZCkgKyBkZWNpbWFsSG91cnNXb3JrZWQpO1xuXG4gICAgaG91cnNXb3JrZWRNYXAudG90YWwuaW50ZXJuc1tjdXJyZW50SW50ZXJuXS5wZXJjZW50YWdlRGlmZmVyZW5jZSA9IChob3Vyc1RvRGVjaW1hbChob3Vyc1dvcmtlZE1hcC50b3RhbC5pbnRlcm5zW2N1cnJlbnRJbnRlcm5dLm5vcm1hbEhvdXJzV29ya2VkKVxuICAgICAgICAvIGhvdXJzVG9EZWNpbWFsKGhvdXJzV29ya2VkTWFwLnRvdGFsLmludGVybnNbY3VycmVudEludGVybl0ubm9ybWFsSG91cnNTY2hlZHVsZWQpICogMTAwKS50b0ZpeGVkKDIpO1xuICAgIGhvdXJzV29ya2VkTWFwLnRvdGFsLnRvdGFsLnRvdGFsSG91cnNXb3JrZWQgKz0gZGVjaW1hbEhvdXJzV29ya2VkO1xuICAgIGhvdXJzV29ya2VkTWFwLnRvdGFsLnRvdGFsLnBlcmNlbnRhZ2VEaWZmZXJlbmNlID0gKGhvdXJzV29ya2VkTWFwLnRvdGFsLnRvdGFsLnRvdGFsSG91cnNXb3JrZWQgLyBob3Vyc1dvcmtlZE1hcC50b3RhbC50b3RhbC50b3RhbEhvdXJzU2NoZWR1bGVkICogMTAwKS50b0ZpeGVkKDIpO1xuXG4gICAgY29uc3QgcGVyY2VudGFnZURpZmZlcmVuY2UgPSAoZGVjaW1hbEhvdXJzV29ya2VkIC8gZGVjaW1hbEhvdXJzU2NoZWR1bGVkICogMTAwKS50b0ZpeGVkKDIpO1xuICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS5pbnRlcm5zW2N1cnJlbnRJbnRlcm5dLnBlcmNlbnRhZ2VEaWZmZXJlbmNlID0gcGVyY2VudGFnZURpZmZlcmVuY2U7XG4gICAgaWYgKHBlcmNlbnRhZ2VEaWZmZXJlbmNlIDwgcGVyY2VudGFnZUFjY2VwdGVkKSB7XG4gICAgICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbC5wZXJjZW50YWdlQWNjZXB0ZWROdW1iZXJzLm51bWJlckJlbG93UGVyY2VudGFnZUFjY2VwdGVkKys7XG4gICAgICAgIGlmICh3ZWVrTmFtZSAhPSBcInRvdGFsXCIpIHtcbiAgICAgICAgICAgIGhvdXJzV29ya2VkTWFwLnRvdGFsLnRvdGFsLnBlcmNlbnRhZ2VBY2NlcHRlZE51bWJlcnMubnVtYmVyQmVsb3dQZXJjZW50YWdlQWNjZXB0ZWQrKztcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5jb25zdCBwcm9jZXNzQ2hhbmdlRnJvbVByZXZpb3VzV2VlayA9IChob3Vyc1dvcmtlZE1hcCkgPT4ge1xuICAgIE9iamVjdC5rZXlzKGhvdXJzV29ya2VkTWFwKS5mb3JFYWNoKChkYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHdvcmtXZWVrUGVyY2VudGFnZXMgPSBob3Vyc1dvcmtlZE1hcFtkYXRlXS50b3RhbC5wZXJjZW50YWdlQWNjZXB0ZWROdW1iZXJzO1xuXG4gICAgICAgIHdvcmtXZWVrUGVyY2VudGFnZXMucGVyY2VudGFnZURpZmZlcmVuY2UgPSAoKHdvcmtXZWVrUGVyY2VudGFnZXMudG90YWxOdW1iZXJPZlBlcmNlbnRhZ2VzIC0gd29ya1dlZWtQZXJjZW50YWdlcy5udW1iZXJCZWxvd1BlcmNlbnRhZ2VBY2NlcHRlZClcbiAgICAgICAgICAgIC8gd29ya1dlZWtQZXJjZW50YWdlcy50b3RhbE51bWJlck9mUGVyY2VudGFnZXMgKiAxMDApLnRvRml4ZWQoMik7XG4gICAgICAgIGlmIChkYXRlICE9IFwidG90YWxcIikge1xuICAgICAgICAgICAgY29uc3Qgd2Vla0JlZm9yZSA9IGdldFdlZWtCZWZvcmUoZGF0ZSk7XG4gICAgICAgICAgICBpZiAoaG91cnNXb3JrZWRNYXBbd2Vla0JlZm9yZV0pIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhob3Vyc1dvcmtlZE1hcFtkYXRlXS5pbnRlcm5zKS5mb3JFYWNoKChpbnRlcm4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaG91cnNXb3JrZWRNYXBbZGF0ZV0uaW50ZXJuc1tpbnRlcm5dLmNoYW5nZUZyb21QcmV2aW91c1dlZWsgPSAocGFyc2VGbG9hdChob3Vyc1dvcmtlZE1hcFtkYXRlXS5pbnRlcm5zW2ludGVybl0ucGVyY2VudGFnZURpZmZlcmVuY2UpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaG91cnNXb3JrZWRNYXBbd2Vla0JlZm9yZV0uaW50ZXJuc1tpbnRlcm5dLnBlcmNlbnRhZ2VEaWZmZXJlbmNlKSkudG9GaXhlZCgyKTtcblxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgaG91cnNXb3JrZWRNYXBbZGF0ZV0udG90YWwuY2hhbmdlRnJvbVByZXZpb3VzV2VlayA9IChwYXJzZUZsb2F0KGhvdXJzV29ya2VkTWFwW2RhdGVdLnRvdGFsLnBlcmNlbnRhZ2VEaWZmZXJlbmNlKSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaG91cnNXb3JrZWRNYXBbd2Vla0JlZm9yZV0udG90YWwucGVyY2VudGFnZURpZmZlcmVuY2UpKS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuY29uc3QgY29sb3JQZXJjZW50YWdlQ2VsbCA9IChjdXJyU2hlZXQsIHBlcmNlbnRhZ2VBY2NlcHRlZCkgPT4ge1xuICAgIGNvbnN0IGN1cnJDZWxsID0gY3VyclNoZWV0LmdldENlbGwoY3VyclNoZWV0LnJvd0NvdW50LCA1KVxuICAgIGNvbnN0IGNoYW5nZUZyb21QcmV2aW91c1dlZWsgPSBjdXJyU2hlZXQuZ2V0Q2VsbChjdXJyU2hlZXQucm93Q291bnQsIDYpXG4gICAgaWYgKHBhcnNlRmxvYXQoY3VyckNlbGwudmFsdWUpIDwgcGVyY2VudGFnZUFjY2VwdGVkKSB7XG4gICAgICAgIGN1cnJDZWxsLmZpbGwgPSB7XG4gICAgICAgICAgICB0eXBlOiAncGF0dGVybicsXG4gICAgICAgICAgICBwYXR0ZXJuOiAnc29saWQnLFxuICAgICAgICAgICAgZmdDb2xvcjogeyBhcmdiOiAnODBlNzYwNjAnIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHBhcnNlRmxvYXQoY3VyckNlbGwudmFsdWUpID4gMTAwKSB7XG4gICAgICAgIGN1cnJDZWxsLmZpbGwgPSB7XG4gICAgICAgICAgICB0eXBlOiAncGF0dGVybicsXG4gICAgICAgICAgICBwYXR0ZXJuOiAnc29saWQnLFxuICAgICAgICAgICAgZmdDb2xvcjogeyBhcmdiOiAnODBmZmZmMDAnIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHBhcnNlRmxvYXQoY2hhbmdlRnJvbVByZXZpb3VzV2Vlay52YWx1ZSkgPCAtMTUpIHtcbiAgICAgICAgY2hhbmdlRnJvbVByZXZpb3VzV2Vlay5maWxsID0ge1xuICAgICAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgcGF0dGVybjogJ3NvbGlkJyxcbiAgICAgICAgICAgIGZnQ29sb3I6IHsgYXJnYjogJzgwZTc2MDYwJyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwYXJzZUZsb2F0KGNoYW5nZUZyb21QcmV2aW91c1dlZWsudmFsdWUpID4gMTUpIHtcbiAgICAgICAgY2hhbmdlRnJvbVByZXZpb3VzV2Vlay5maWxsID0ge1xuICAgICAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgcGF0dGVybjogJ3NvbGlkJyxcbiAgICAgICAgICAgIGZnQ29sb3I6IHsgYXJnYjogJzgwNDJmNThkJyB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IG1ha2VUaW1lc2hlZXRBbmFseXNpczsiXSwibmFtZXMiOlsiRXhjZWxKUyIsIkZpbGVTYXZlciIsImhvdXJzVG9EZWNpbWFsIiwiZ2V0RGF0ZUZyb21TdHJpbmciLCJkZWNpbWFsVG9Ib3VycyIsImdldFdlZWtCZWZvcmUiLCJpbml0aWFsaXplSG91cnNXb3JrZWRNYXAiLCJwb3B1bGF0ZUhvdXJzV29ya2VkTWFwIiwibWFrZVRpbWVzaGVldEFuYWx5c2lzIiwidGltZXNoZWV0RXhjZWwiLCJzaW1wbGlmaWVkU2NoZWR1bGUiLCJwZXJjZW50YWdlQWNjZXB0ZWQiLCJ0YU1hcCIsIndvcmtib29rIiwiV29ya2Jvb2siLCJob3Vyc1dvcmtlZE1hcCIsInRvdGFsIiwidG90YWxIb3Vyc1dvcmtlZCIsInRvdGFsSG91cnNTY2hlZHVsZWQiLCJwZXJjZW50YWdlQWNjZXB0ZWROdW1iZXJzIiwibnVtYmVyQmVsb3dQZXJjZW50YWdlQWNjZXB0ZWQiLCJ0b3RhbE51bWJlck9mUGVyY2VudGFnZXMiLCJpbnRlcm5zIiwicHJvY2Vzc0NoYW5nZUZyb21QcmV2aW91c1dlZWsiLCJjb25zb2xlIiwibG9nIiwibWFrZVNoZWV0cyIsInhsc3giLCJ3cml0ZUJ1ZmZlciIsInRoZW4iLCJkYXRhIiwiYmxvYiIsIkJsb2IiLCJzYXZlQXMiLCJzZXRVcE5ld1NoZWV0Iiwid2Vla05hbWUiLCJzaGVldCIsImFkZFdvcmtzaGVldCIsInZpZXdzIiwicHJvcGVydGllcyIsImRlZmF1bHRDb2xXaWR0aCIsImRlZmF1bHRSb3dIZWlnaHQiLCJzZXRVcENvbHVtbnMiLCJ3b3Jrc2hlZXQiLCJmaXJzdE5hbWUiLCJnZXRDb2x1bW4iLCJoZWFkZXIiLCJrZXkiLCJsYXN0TmFtZSIsImhvdXJzV29ya2VkIiwiaG91cnNTY2hlZHVsZWQiLCJwZXJjZW50V29ya2VkIiwiY2hhbmdlRnJvbVByZXZpb3VzV2VlayIsIndpZHRoIiwidGFBc3NpZ25lZCIsInBlcmNlbnRBYm92ZUFjY2VwdGVkIiwidG90YWxXb3JrZWQiLCJ0b3RhbFNjaGVkdWxlZCIsInRvdGFsUGVyY2VudFdvcmtlZCIsInRvdGFsUGVyY2VudENoYW5nZSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiaW50ZXJuIiwiY3VycmVudEludGVybkRhdGEiLCJzcGxpdCIsInNsaWNlIiwiam9pbiIsImFkZFJvdyIsInRvVXBwZXJDYXNlIiwibm9ybWFsSG91cnNXb3JrZWQiLCJub3JtYWxIb3Vyc1NjaGVkdWxlZCIsInBlcmNlbnRhZ2VEaWZmZXJlbmNlIiwidGEiLCJjb2xvclBlcmNlbnRhZ2VDZWxsIiwiZ2V0Q2VsbCIsInZhbHVlIiwicHJvY2Vzc0hvdXJzRGF0YSIsInJvdyIsInRpbWVTaGVldCIsImN1cnJlbnRJbnRlcm4iLCJkZWNpbWFsSG91cnNTY2hlZHVsZWQiLCJkZWNpbWFsSG91cnNXb3JrZWQiLCJ0b3RhbEludGVybkhvdXJzV29ya2VkIiwidG9GaXhlZCIsImRhdGUiLCJ3b3JrV2Vla1BlcmNlbnRhZ2VzIiwid2Vla0JlZm9yZSIsInBhcnNlRmxvYXQiLCJjdXJyU2hlZXQiLCJjdXJyQ2VsbCIsInJvd0NvdW50IiwiZmlsbCIsInR5cGUiLCJwYXR0ZXJuIiwiZmdDb2xvciIsImFyZ2IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/helpers/makeTimeSheetAnalysis.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/helpers/populateHoursWorkedMap.jsx":
/*!************************************************!*\
  !*** ./src/helpers/populateHoursWorkedMap.jsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst populateHoursWorkedMap = (timesheetExcel, hoursWorkedMap, simplifiedSchedule, percentageAccepted)=>{\n    const timeSheet = timesheetExcel.getWorksheet(\"All Employees\");\n    let firstName = timeSheet.getCell(2, 1).value;\n    let lastName = timeSheet.getCell(2, 2).value;\n    let currentIntern = firstName + \" \" + lastName;\n    for(let row = 2; row <= timeSheet.rowCount; row++){\n        const tempFirstName = timeSheet.getCell(row, 1).value;\n        const tempLastName = timeSheet.getCell(row, 2).value;\n        if (tempFirstName && tempFirstName + \" \" + tempLastName != currentIntern) {\n            currentIntern = tempFirstName + \" \" + tempLastName;\n            firstName = tempFirstName;\n            lastName = tempLastName;\n        }\n        const date = timeSheet.getCell(row, 5).value;\n        if (date) {\n            const weekName = getDateFromString(timeSheet.getCell(row, 5).value);\n            if (hoursWorkedMap[weekName]) {\n                const currentWeek = hoursWorkedMap[weekName].interns;\n                if (currentWeek[currentIntern] && currentWeek[currentIntern].normalHoursWorked == \"00:00\") {\n                    currentWeek[currentIntern].firstName = firstName;\n                    currentWeek[currentIntern].lastName = lastName;\n                    processHoursData(row, timeSheet, hoursWorkedMap, currentIntern, weekName, simplifiedSchedule, percentageAccepted);\n                }\n            }\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (populateHoursWorkedMap);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9oZWxwZXJzL3BvcHVsYXRlSG91cnNXb3JrZWRNYXAuanN4IiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSx5QkFBeUIsQ0FBQ0MsZ0JBQWdCQyxnQkFBZ0JDLG9CQUFvQkM7SUFDaEYsTUFBTUMsWUFBWUosZUFBZUssWUFBWSxDQUFDO0lBRTlDLElBQUlDLFlBQVlGLFVBQVVHLE9BQU8sQ0FBQyxHQUFHLEdBQUdDLEtBQUs7SUFDN0MsSUFBSUMsV0FBV0wsVUFBVUcsT0FBTyxDQUFDLEdBQUcsR0FBR0MsS0FBSztJQUM1QyxJQUFJRSxnQkFBZ0JKLFlBQVksTUFBTUc7SUFDdEMsSUFBSyxJQUFJRSxNQUFNLEdBQUdBLE9BQU9QLFVBQVVRLFFBQVEsRUFBRUQsTUFBTztRQUVoRCxNQUFNRSxnQkFBZ0JULFVBQVVHLE9BQU8sQ0FBQ0ksS0FBSyxHQUFHSCxLQUFLO1FBQ3JELE1BQU1NLGVBQWVWLFVBQVVHLE9BQU8sQ0FBQ0ksS0FBSyxHQUFHSCxLQUFLO1FBQ3BELElBQUlLLGlCQUNDQSxnQkFBZ0IsTUFBTUMsZ0JBQWdCSixlQUFnQjtZQUN2REEsZ0JBQWdCRyxnQkFBZ0IsTUFBTUM7WUFDdENSLFlBQVlPO1lBQ1pKLFdBQVdLO1FBQ2Y7UUFDQSxNQUFNQyxPQUFPWCxVQUFVRyxPQUFPLENBQUNJLEtBQUssR0FBR0gsS0FBSztRQUM1QyxJQUFJTyxNQUFNO1lBQ04sTUFBTUMsV0FBV0Msa0JBQWtCYixVQUFVRyxPQUFPLENBQUNJLEtBQUssR0FBR0gsS0FBSztZQUVsRSxJQUFJUCxjQUFjLENBQUNlLFNBQVMsRUFBRTtnQkFDMUIsTUFBTUUsY0FBY2pCLGNBQWMsQ0FBQ2UsU0FBUyxDQUFDRyxPQUFPO2dCQUVwRCxJQUFJRCxXQUFXLENBQUNSLGNBQWMsSUFBSVEsV0FBVyxDQUFDUixjQUFjLENBQUNVLGlCQUFpQixJQUFJLFNBQVM7b0JBQ3ZGRixXQUFXLENBQUNSLGNBQWMsQ0FBQ0osU0FBUyxHQUFHQTtvQkFDdkNZLFdBQVcsQ0FBQ1IsY0FBYyxDQUFDRCxRQUFRLEdBQUdBO29CQUN0Q1ksaUJBQWlCVixLQUFLUCxXQUFXSCxnQkFBZ0JTLGVBQWVNLFVBQVVkLG9CQUFvQkM7Z0JBQ2xHO1lBQ0o7UUFDSjtJQUNKO0FBRUo7QUFFQSwrREFBZUosc0JBQXNCQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9oZWxwZXJzL3BvcHVsYXRlSG91cnNXb3JrZWRNYXAuanN4P2IzMzMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcG9wdWxhdGVIb3Vyc1dvcmtlZE1hcCA9ICh0aW1lc2hlZXRFeGNlbCwgaG91cnNXb3JrZWRNYXAsIHNpbXBsaWZpZWRTY2hlZHVsZSwgcGVyY2VudGFnZUFjY2VwdGVkKSA9PiB7XG4gICAgY29uc3QgdGltZVNoZWV0ID0gdGltZXNoZWV0RXhjZWwuZ2V0V29ya3NoZWV0KFwiQWxsIEVtcGxveWVlc1wiKTtcblxuICAgIGxldCBmaXJzdE5hbWUgPSB0aW1lU2hlZXQuZ2V0Q2VsbCgyLCAxKS52YWx1ZTtcbiAgICBsZXQgbGFzdE5hbWUgPSB0aW1lU2hlZXQuZ2V0Q2VsbCgyLCAyKS52YWx1ZTtcbiAgICBsZXQgY3VycmVudEludGVybiA9IGZpcnN0TmFtZSArIFwiIFwiICsgbGFzdE5hbWU7XG4gICAgZm9yIChsZXQgcm93ID0gMjsgcm93IDw9IHRpbWVTaGVldC5yb3dDb3VudDsgcm93KyspIHtcblxuICAgICAgICBjb25zdCB0ZW1wRmlyc3ROYW1lID0gdGltZVNoZWV0LmdldENlbGwocm93LCAxKS52YWx1ZTtcbiAgICAgICAgY29uc3QgdGVtcExhc3ROYW1lID0gdGltZVNoZWV0LmdldENlbGwocm93LCAyKS52YWx1ZTtcbiAgICAgICAgaWYgKHRlbXBGaXJzdE5hbWUgJiZcbiAgICAgICAgICAgICh0ZW1wRmlyc3ROYW1lICsgXCIgXCIgKyB0ZW1wTGFzdE5hbWUgIT0gY3VycmVudEludGVybikpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbnRlcm4gPSB0ZW1wRmlyc3ROYW1lICsgXCIgXCIgKyB0ZW1wTGFzdE5hbWU7XG4gICAgICAgICAgICBmaXJzdE5hbWUgPSB0ZW1wRmlyc3ROYW1lO1xuICAgICAgICAgICAgbGFzdE5hbWUgPSB0ZW1wTGFzdE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZSA9IHRpbWVTaGVldC5nZXRDZWxsKHJvdywgNSkudmFsdWU7XG4gICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCB3ZWVrTmFtZSA9IGdldERhdGVGcm9tU3RyaW5nKHRpbWVTaGVldC5nZXRDZWxsKHJvdywgNSkudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFdlZWsgPSBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0uaW50ZXJucztcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50V2Vla1tjdXJyZW50SW50ZXJuXSAmJiBjdXJyZW50V2Vla1tjdXJyZW50SW50ZXJuXS5ub3JtYWxIb3Vyc1dvcmtlZCA9PSBcIjAwOjAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFdlZWtbY3VycmVudEludGVybl0uZmlyc3ROYW1lID0gZmlyc3ROYW1lO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2Vla1tjdXJyZW50SW50ZXJuXS5sYXN0TmFtZSA9IGxhc3ROYW1lO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzSG91cnNEYXRhKHJvdywgdGltZVNoZWV0LCBob3Vyc1dvcmtlZE1hcCwgY3VycmVudEludGVybiwgd2Vla05hbWUsIHNpbXBsaWZpZWRTY2hlZHVsZSwgcGVyY2VudGFnZUFjY2VwdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgcG9wdWxhdGVIb3Vyc1dvcmtlZE1hcDsiXSwibmFtZXMiOlsicG9wdWxhdGVIb3Vyc1dvcmtlZE1hcCIsInRpbWVzaGVldEV4Y2VsIiwiaG91cnNXb3JrZWRNYXAiLCJzaW1wbGlmaWVkU2NoZWR1bGUiLCJwZXJjZW50YWdlQWNjZXB0ZWQiLCJ0aW1lU2hlZXQiLCJnZXRXb3Jrc2hlZXQiLCJmaXJzdE5hbWUiLCJnZXRDZWxsIiwidmFsdWUiLCJsYXN0TmFtZSIsImN1cnJlbnRJbnRlcm4iLCJyb3ciLCJyb3dDb3VudCIsInRlbXBGaXJzdE5hbWUiLCJ0ZW1wTGFzdE5hbWUiLCJkYXRlIiwid2Vla05hbWUiLCJnZXREYXRlRnJvbVN0cmluZyIsImN1cnJlbnRXZWVrIiwiaW50ZXJucyIsIm5vcm1hbEhvdXJzV29ya2VkIiwicHJvY2Vzc0hvdXJzRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/helpers/populateHoursWorkedMap.jsx\n"));

/***/ })

});