"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/timesheet-tool/page",{

/***/ "(app-pages-browser)/./src/helpers/makeTimeSheetAnalysis.jsx":
/*!***********************************************!*\
  !*** ./src/helpers/makeTimeSheetAnalysis.jsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var exceljs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! exceljs */ \"(app-pages-browser)/./node_modules/exceljs/dist/exceljs.min.js\");\n/* harmony import */ var exceljs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(exceljs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hoursToDecimal */ \"(app-pages-browser)/./src/helpers/hoursToDecimal.jsx\");\n/* harmony import */ var _getDateFromString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getDateFromString */ \"(app-pages-browser)/./src/helpers/getDateFromString.jsx\");\n/* harmony import */ var _decimalToHours__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./decimalToHours */ \"(app-pages-browser)/./src/helpers/decimalToHours.jsx\");\n/* harmony import */ var _getWeekBefore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWeekBefore */ \"(app-pages-browser)/./src/helpers/getWeekBefore.jsx\");\n\n\n\n\n\n\nconst makeTimesheetAnalysis = (timesheetExcel, simplifiedSchedule, percentageAccepted)=>{\n    const workbook = new exceljs__WEBPACK_IMPORTED_MODULE_0__.Workbook();\n    const hoursWorkedMap = {\n        total: {\n            total: {\n                totalHoursWorked: 0,\n                totalHoursScheduled: 0,\n                percentageAcceptedNumbers: {\n                    numberBelowPercentageAccepted: 0,\n                    totalNumberOfPercentages: 0\n                }\n            },\n            interns: {}\n        }\n    };\n    initializeHoursWorkedMap(hoursWorkedMap, simplifiedSchedule);\n    populateHoursWorkedMap(timesheetExcel, hoursWorkedMap, simplifiedSchedule, percentageAccepted);\n    processChangeFromPreviousWeek(hoursWorkedMap);\n    console.log(hoursWorkedMap);\n// workbook.xlsx.writeBuffer().then(data => {\n//     const blob = new Blob([data]);\n//     FileSaver.saveAs(blob, \"Timesheet Analysis.xlsx\");\n// });\n};\nconst initializeHoursWorkedMap = (hoursWorkedMap, simplifiedSchedule)=>{\n    Object.keys(simplifiedSchedule).forEach((weekName)=>{\n        if (!hoursWorkedMap[weekName]) {\n            hoursWorkedMap[weekName] = {\n                total: {\n                    totalHoursWorked: 0,\n                    totalHoursScheduled: 0,\n                    percentageAcceptedNumbers: {\n                        numberBelowPercentageAccepted: 0,\n                        totalNumberOfPercentages: 0\n                    }\n                },\n                interns: {}\n            };\n        }\n        Object.keys(simplifiedSchedule[weekName].interns).forEach((intern)=>{\n            const decimalHoursScheduled = simplifiedSchedule[weekName].interns[intern];\n            const normalHoursScheduled1 = (0,_decimalToHours__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(decimalHoursScheduled);\n            if (!hoursWorkedMap[weekName].interns[intern]) {\n                hoursWorkedMap[weekName].interns[intern] = {};\n            }\n            const currIntern = hoursWorkedMap[weekName].interns[intern];\n            currIntern.normalHoursWorked = \"00:00\";\n            currIntern.normalHoursScheduled = normalHoursScheduled1;\n            currIntern.percentageDifference = 0;\n        });\n        hoursWorkedMap[weekName].total.totalHoursScheduled = simplifiedSchedule[weekName].totalHoursScheduled;\n    });\n};\nconst populateHoursWorkedMap = (timesheetExcel, hoursWorkedMap, simplifiedSchedule, percentageAccepted)=>{\n    const timeSheet = timesheetExcel.getWorksheet(\"All Employees\");\n    const tempFirstName = timeSheet.getCell(2, 1).value;\n    const tempLastName = timeSheet.getCell(2, 2).value;\n    let currentIntern = tempFirstName + \" \" + tempLastName;\n    for(let row = 2; row <= timeSheet.rowCount; row++){\n        const firstName = timeSheet.getCell(row, 1).value;\n        const lastName = timeSheet.getCell(row, 2).value;\n        if (firstName && firstName + \" \" + lastName != currentIntern) {\n            currentIntern = firstName + \" \" + lastName;\n        }\n        const date = timeSheet.getCell(row, 5).value;\n        if (date) {\n            const weekName = (0,_getDateFromString__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(timeSheet.getCell(row, 5).value);\n            if (hoursWorkedMap[weekName]) {\n                const currentWeek = hoursWorkedMap[weekName].interns;\n                if (currentWeek[currentIntern] && currentWeek[currentIntern].normalHoursWorked == \"00:00\") {\n                    processHoursData(row, timeSheet, hoursWorkedMap, currentIntern, weekName, simplifiedSchedule, percentageAccepted);\n                }\n            }\n        }\n    // populateRow(workBookData, currentInternData, percentageAccepted, row);\n    // currSheet.getCell(2, 9).value = hoursWorkedMap[weekName].total;\n    // currSheet.getCell(2, 10).value = simplifiedSchedule[weekName].totalScheduledHours;\n    // currSheet.getCell(2, 11).value = (hoursWorkedMap[weekName].total / simplifiedSchedule[weekName].totalScheduledHours * 100).toFixed(2);\n    }\n};\nconst setUpNewSheet = (hoursWorkedMap, weekName, workbook)=>{\n    hoursWorkedMap[weekName] = {};\n    hoursWorkedMap[weekName].total = 0;\n    const sheet = workbook.addWorksheet(weekName);\n    sheet.views = [\n        {}\n    ];\n    sheet.properties.defaultColWidth = 15;\n    sheet.properties.defaultRowHeight = 20;\n    setUpColumns(sheet);\n};\nconst setUpColumns = (worksheet)=>{\n    const firstName = worksheet.getColumn(1);\n    firstName.header = \"First Name\";\n    firstName.key = \"firstName\";\n    const lastName = worksheet.getColumn(2);\n    lastName.header = \"Last Name\";\n    lastName.key = \"lastName\";\n    const hoursWorked = worksheet.getColumn(3);\n    hoursWorked.header = \"Hours Worked\";\n    hoursWorked.key = \"hoursWorked\";\n    const hoursScheduled = worksheet.getColumn(4);\n    hoursScheduled.header = \"Hours Scheduled\";\n    hoursScheduled.key = \"hoursScheduled\";\n    const percentWorked = worksheet.getColumn(5);\n    percentWorked.header = \"Percent Worked\";\n    percentWorked.key = \"percentWorked\";\n    const changeFromPreviousWeek = worksheet.getColumn(6);\n    changeFromPreviousWeek.header = \"Percent Change from Last Week\";\n    changeFromPreviousWeek.key = \"changeFromPreviousWeek\";\n    changeFromPreviousWeek.width = 25;\n    const taAssigned = worksheet.getColumn(7);\n    taAssigned.header = \"TA\";\n    taAssigned.key = \"ta\";\n    const totalWorked = worksheet.getColumn(9);\n    totalWorked.header = \"Total Worked\";\n    totalWorked.key = \"totalWorked\";\n    const totalScheduled = worksheet.getColumn(10);\n    totalScheduled.header = \"Total Scheduled\";\n    totalScheduled.key = \"totalScheduled\";\n    const totalPercentWorked = worksheet.getColumn(11);\n    totalPercentWorked.header = \"Percent Worked\";\n    totalPercentWorked.key = \"totalPercentWorked\";\n    const totalPercentChange = worksheet.getColumn(12);\n    totalPercentChange.header = \"Total Percent Change from Last Week\";\n    totalPercentChange.key = \"totalPercentChange\";\n    totalPercentChange.width = 30;\n};\nconst populateRow = (workBookData, currentInternData, percentageAccepted, row)=>{\n    const currSheet = workBookData.workbook.getWorksheet(workBookData.weekName);\n    currSheet.addRow({\n        firstName: currentInternData.firstName,\n        lastName: currentInternData.lastName,\n        hoursWorked: normalHoursWorked,\n        hoursScheduled: normalHoursScheduled,\n        percentWorked: percentageDifference\n    });\n    colorPercentageCell(currSheet, percentageAccepted);\n};\nconst processHoursData = (row, timeSheet, hoursWorkedMap, currentIntern, weekName, simplifiedSchedule, percentageAccepted)=>{\n    const normalHoursWorked1 = timeSheet.getCell(row, 15).value ? timeSheet.getCell(row, 15).value : \"00:00\";\n    if (!hoursWorkedMap[weekName].total.percentageAcceptedNumbers) {\n        hoursWorkedMap[weekName].total.percentageAcceptedNumbers = {\n            numberBelowPercentageAccepted: 0,\n            totalNumberOfPercentages: 0\n        };\n    }\n    if (!hoursWorkedMap.total.total.percentageAcceptedNumbers) {\n        hoursWorkedMap.total.total.percentageAcceptedNumbers = {\n            numberBelowPercentageAccepted: 0,\n            totalNumberOfPercentages: 0\n        };\n    }\n    hoursWorkedMap[weekName].total.percentageAcceptedNumbers.totalNumberOfPercentages++;\n    hoursWorkedMap.total.total.percentageAcceptedNumbers.totalNumberOfPercentages++;\n    hoursWorkedMap[weekName].interns[currentIntern].normalHoursWorked = normalHoursWorked1;\n    const decimalHoursScheduled = simplifiedSchedule[weekName].interns[currentIntern];\n    const decimalHoursWorked = (0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(normalHoursWorked1);\n    hoursWorkedMap[weekName].total.totalHoursWorked += decimalHoursWorked;\n    const totalInternHoursWorked = hoursWorkedMap.total.interns[currentIntern].normalHoursWorked;\n    hoursWorkedMap[weekName].total.percentageDifference = (hoursWorkedMap[weekName].total.totalHoursWorked / hoursWorkedMap[weekName].total.totalHoursScheduled * 100).toFixed(2);\n    hoursWorkedMap.total.interns[currentIntern].normalHoursWorked = (0,_decimalToHours__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(totalInternHoursWorked) + decimalHoursWorked);\n    hoursWorkedMap.total.interns[currentIntern].percentageDifference = ((0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(hoursWorkedMap.total.interns[currentIntern].normalHoursWorked) / (0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(hoursWorkedMap.total.interns[currentIntern].normalHoursScheduled) * 100).toFixed(2);\n    hoursWorkedMap.total.total.totalHoursWorked += decimalHoursWorked;\n    hoursWorkedMap.total.total.percentageDifference = (hoursWorkedMap.total.total.totalHoursWorked / hoursWorkedMap.total.total.totalHoursScheduled * 100).toFixed(2);\n    const percentageDifference1 = (decimalHoursWorked / decimalHoursScheduled * 100).toFixed(2);\n    hoursWorkedMap[weekName].interns[currentIntern].percentageDifference = percentageDifference1;\n    if (percentageDifference1 < percentageAccepted) {\n        hoursWorkedMap[weekName].total.percentageAcceptedNumbers.numberBelowPercentageAccepted++;\n        hoursWorkedMap.total.total.percentageAcceptedNumbers.numberBelowPercentageAccepted++;\n    }\n};\nconst processChangeFromPreviousWeek = (hoursWorkedMap)=>{\n    Object.keys(hoursWorkedMap).forEach((date)=>{\n        const workWeekPercentages = hoursWorkedMap[date].total.percentageAcceptedNumbers;\n        workWeekPercentages.percentageDifference = ((workWeekPercentages.totalNumberOfPercentages - workWeekPercentages.numberBelowPercentageAccepted) / workWeekPercentages.totalNumberOfPercentages * 100).toFixed(2);\n        if (date != \"total\") {\n            const weekBefore = (0,_getWeekBefore__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(date);\n            if (hoursWorkedMap[weekBefore]) {\n                Object.keys(hoursWorkedMap[date].interns).forEach((intern)=>{\n                    hoursWorkedMap[date].interns[intern].changeFromPreviousWeek = (parseFloat(hoursWorkedMap[date].interns[intern].percentageDifference) - parseFloat(hoursWorkedMap[weekBefore].interns[intern].percentageDifference)).toFixed(2);\n                });\n                hoursWorkedMap[date].total.changeFromPreviousWeek = (parseFloat(hoursWorkedMap[date].total.percentageDifference) - parseFloat(hoursWorkedMap[weekBefore].total.percentageDifference)).toFixed(2);\n            }\n        }\n    });\n// workbook.eachSheet((worksheet) => {\n//     const currWeek = worksheet.name;\n//     const prevWeek = getWeekBefore(currWeek);\n//     for (let row = 2; row <= worksheet.rowCount; row++) {\n//         const firstName = worksheet.getCell(row, 1).value;\n//         const lastName = worksheet.getCell(row, 2).value;\n//         const fullName = firstName + ' ' + lastName;\n//         let percentageDifferenceOfPreviousWeek;\n//         if (hoursWorkedMap[prevWeek] && hoursWorkedMap[prevWeek][fullName]) {\n//             percentageDifferenceOfPreviousWeek = hoursWorkedMap[prevWeek][fullName].percentageDifference;\n//         }\n//         const percentageDifferenceOfCurrentWeek = hoursWorkedMap[currWeek][fullName].percentageDifference;\n//         let differenceFromWeeks = percentageDifferenceOfPreviousWeek ?\n//             (percentageDifferenceOfCurrentWeek - percentageDifferenceOfPreviousWeek).toFixed(2) : \"\";\n//         const currCell = worksheet.getCell(row, 6);\n//         currCell.value = differenceFromWeeks;\n//         if (currCell <= -15) {\n//             currCell.fill = {\n//                 type: 'pattern',\n//                 pattern: 'solid',\n//                 fgColor: { argb: '80e76060' }\n//             };\n//         }\n//         if (currCell > 15) {\n//             currCell.fill = {\n//                 type: 'pattern',\n//                 pattern: 'solid',\n//                 fgColor: { argb: '8042f58d' }\n//             };\n//         }\n//     }\n// })\n};\nconst colorPercentageCell = (currSheet, percentageAccepted)=>{\n    const currCell = currSheet.getCell(currSheet.rowCount, 5);\n    if (parseFloat(currCell) < percentageAccepted) {\n        currCell.fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"80e76060\"\n            }\n        };\n    }\n    if (parseFloat(currCell) > 100) {\n        currCell.fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"8042f58d\"\n            }\n        };\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (makeTimesheetAnalysis);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9oZWxwZXJzL21ha2VUaW1lU2hlZXRBbmFseXNpcy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtDO0FBQ0s7QUFDTztBQUNNO0FBQ047QUFDRjtBQUU1QyxNQUFNTSx3QkFBd0IsQ0FBQ0MsZ0JBQWdCQyxvQkFBb0JDO0lBQy9ELE1BQU1DLFdBQVcsSUFBSVYsNkNBQWdCO0lBQ3JDLE1BQU1ZLGlCQUFpQjtRQUNuQkMsT0FBTztZQUNIQSxPQUFPO2dCQUNIQyxrQkFBa0I7Z0JBQ2xCQyxxQkFBcUI7Z0JBQ3JCQywyQkFBMkI7b0JBQ3ZCQywrQkFBK0I7b0JBQy9CQywwQkFBMEI7Z0JBQzlCO1lBQ0o7WUFDQUMsU0FBUyxDQUVUO1FBRUo7SUFFSjtJQUVBQyx5QkFBeUJSLGdCQUFnQko7SUFDekNhLHVCQUF1QmQsZ0JBQWdCSyxnQkFBZ0JKLG9CQUFvQkM7SUFDM0VhLDhCQUE4QlY7SUFDOUJXLFFBQVFDLEdBQUcsQ0FBQ1o7QUFFWiw2Q0FBNkM7QUFDN0MscUNBQXFDO0FBQ3JDLHlEQUF5RDtBQUN6RCxNQUFNO0FBRVY7QUFFQSxNQUFNUSwyQkFBMkIsQ0FBQ1IsZ0JBQWdCSjtJQUM5Q2lCLE9BQU9DLElBQUksQ0FBQ2xCLG9CQUFvQm1CLE9BQU8sQ0FBQyxDQUFDQztRQUNyQyxJQUFJLENBQUNoQixjQUFjLENBQUNnQixTQUFTLEVBQUU7WUFDM0JoQixjQUFjLENBQUNnQixTQUFTLEdBQUc7Z0JBQ3ZCZixPQUFPO29CQUNIQyxrQkFBa0I7b0JBQ2xCQyxxQkFBcUI7b0JBQ3JCQywyQkFBMkI7d0JBQ3ZCQywrQkFBK0I7d0JBQy9CQywwQkFBMEI7b0JBQzlCO2dCQUNKO2dCQUNBQyxTQUFTLENBRVQ7WUFDSjtRQUNKO1FBRUFNLE9BQU9DLElBQUksQ0FBQ2xCLGtCQUFrQixDQUFDb0IsU0FBUyxDQUFDVCxPQUFPLEVBQUVRLE9BQU8sQ0FBQyxDQUFDRTtZQUN2RCxNQUFNQyx3QkFBd0J0QixrQkFBa0IsQ0FB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R0EsK0RBQWVsRixxQkFBcUJBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hlbHBlcnMvbWFrZVRpbWVTaGVldEFuYWx5c2lzLmpzeD85NWFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEV4Y2VsSlMgZnJvbSAnZXhjZWxqcydcbmltcG9ydCAqIGFzIEZpbGVTYXZlciBmcm9tICdmaWxlLXNhdmVyJ1xuaW1wb3J0IGhvdXJzVG9EZWNpbWFsIGZyb20gJy4vaG91cnNUb0RlY2ltYWwnO1xuaW1wb3J0IGdldERhdGVGcm9tU3RyaW5nIGZyb20gJy4vZ2V0RGF0ZUZyb21TdHJpbmcnO1xuaW1wb3J0IGRlY2ltYWxUb0hvdXJzIGZyb20gJy4vZGVjaW1hbFRvSG91cnMnO1xuaW1wb3J0IGdldFdlZWtCZWZvcmUgZnJvbSAnLi9nZXRXZWVrQmVmb3JlJztcblxuY29uc3QgbWFrZVRpbWVzaGVldEFuYWx5c2lzID0gKHRpbWVzaGVldEV4Y2VsLCBzaW1wbGlmaWVkU2NoZWR1bGUsIHBlcmNlbnRhZ2VBY2NlcHRlZCkgPT4ge1xuICAgIGNvbnN0IHdvcmtib29rID0gbmV3IEV4Y2VsSlMuV29ya2Jvb2soKTtcbiAgICBjb25zdCBob3Vyc1dvcmtlZE1hcCA9IHtcbiAgICAgICAgdG90YWw6IHtcbiAgICAgICAgICAgIHRvdGFsOiB7XG4gICAgICAgICAgICAgICAgdG90YWxIb3Vyc1dvcmtlZDogMCxcbiAgICAgICAgICAgICAgICB0b3RhbEhvdXJzU2NoZWR1bGVkOiAwLFxuICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2VBY2NlcHRlZE51bWJlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyQmVsb3dQZXJjZW50YWdlQWNjZXB0ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTnVtYmVyT2ZQZXJjZW50YWdlczogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGludGVybnM6IHtcblxuICAgICAgICAgICAgfSxcblxuICAgICAgICB9LFxuXG4gICAgfTtcblxuICAgIGluaXRpYWxpemVIb3Vyc1dvcmtlZE1hcChob3Vyc1dvcmtlZE1hcCwgc2ltcGxpZmllZFNjaGVkdWxlKTtcbiAgICBwb3B1bGF0ZUhvdXJzV29ya2VkTWFwKHRpbWVzaGVldEV4Y2VsLCBob3Vyc1dvcmtlZE1hcCwgc2ltcGxpZmllZFNjaGVkdWxlLCBwZXJjZW50YWdlQWNjZXB0ZWQpO1xuICAgIHByb2Nlc3NDaGFuZ2VGcm9tUHJldmlvdXNXZWVrKGhvdXJzV29ya2VkTWFwKTtcbiAgICBjb25zb2xlLmxvZyhob3Vyc1dvcmtlZE1hcCk7XG5cbiAgICAvLyB3b3JrYm9vay54bHN4LndyaXRlQnVmZmVyKCkudGhlbihkYXRhID0+IHtcbiAgICAvLyAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gICAgLy8gICAgIEZpbGVTYXZlci5zYXZlQXMoYmxvYiwgXCJUaW1lc2hlZXQgQW5hbHlzaXMueGxzeFwiKTtcbiAgICAvLyB9KTtcblxufVxuXG5jb25zdCBpbml0aWFsaXplSG91cnNXb3JrZWRNYXAgPSAoaG91cnNXb3JrZWRNYXAsIHNpbXBsaWZpZWRTY2hlZHVsZSkgPT4ge1xuICAgIE9iamVjdC5rZXlzKHNpbXBsaWZpZWRTY2hlZHVsZSkuZm9yRWFjaCgod2Vla05hbWUpID0+IHtcbiAgICAgICAgaWYgKCFob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0pIHtcbiAgICAgICAgICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB0b3RhbDoge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbEhvdXJzV29ya2VkOiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbEhvdXJzU2NoZWR1bGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50YWdlQWNjZXB0ZWROdW1iZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJCZWxvd1BlcmNlbnRhZ2VBY2NlcHRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTnVtYmVyT2ZQZXJjZW50YWdlczogMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGludGVybnM6IHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhzaW1wbGlmaWVkU2NoZWR1bGVbd2Vla05hbWVdLmludGVybnMpLmZvckVhY2goKGludGVybikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVjaW1hbEhvdXJzU2NoZWR1bGVkID0gc2ltcGxpZmllZFNjaGVkdWxlW3dlZWtOYW1lXS5pbnRlcm5zW2ludGVybl07XG4gICAgICAgICAgICBjb25zdCBub3JtYWxIb3Vyc1NjaGVkdWxlZCA9IGRlY2ltYWxUb0hvdXJzKGRlY2ltYWxIb3Vyc1NjaGVkdWxlZCk7XG4gICAgICAgICAgICBpZiAoIWhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS5pbnRlcm5zW2ludGVybl0pIHtcbiAgICAgICAgICAgICAgICBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0uaW50ZXJuc1tpbnRlcm5dID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJJbnRlcm4gPSBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0uaW50ZXJuc1tpbnRlcm5dO1xuICAgICAgICAgICAgY3VyckludGVybi5ub3JtYWxIb3Vyc1dvcmtlZCA9IFwiMDA6MDBcIjtcbiAgICAgICAgICAgIGN1cnJJbnRlcm4ubm9ybWFsSG91cnNTY2hlZHVsZWQgPSBub3JtYWxIb3Vyc1NjaGVkdWxlZDtcbiAgICAgICAgICAgIGN1cnJJbnRlcm4ucGVyY2VudGFnZURpZmZlcmVuY2UgPSAwO1xuICAgICAgICB9KVxuICAgICAgICBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0udG90YWwudG90YWxIb3Vyc1NjaGVkdWxlZCA9IHNpbXBsaWZpZWRTY2hlZHVsZVt3ZWVrTmFtZV0udG90YWxIb3Vyc1NjaGVkdWxlZDtcbiAgICB9KVxufVxuXG5jb25zdCBwb3B1bGF0ZUhvdXJzV29ya2VkTWFwID0gKHRpbWVzaGVldEV4Y2VsLCBob3Vyc1dvcmtlZE1hcCwgc2ltcGxpZmllZFNjaGVkdWxlLCBwZXJjZW50YWdlQWNjZXB0ZWQpID0+IHtcbiAgICBjb25zdCB0aW1lU2hlZXQgPSB0aW1lc2hlZXRFeGNlbC5nZXRXb3Jrc2hlZXQoXCJBbGwgRW1wbG95ZWVzXCIpO1xuXG4gICAgY29uc3QgdGVtcEZpcnN0TmFtZSA9IHRpbWVTaGVldC5nZXRDZWxsKDIsIDEpLnZhbHVlO1xuICAgIGNvbnN0IHRlbXBMYXN0TmFtZSA9IHRpbWVTaGVldC5nZXRDZWxsKDIsIDIpLnZhbHVlO1xuICAgIGxldCBjdXJyZW50SW50ZXJuID0gdGVtcEZpcnN0TmFtZSArIFwiIFwiICsgdGVtcExhc3ROYW1lO1xuICAgIGZvciAobGV0IHJvdyA9IDI7IHJvdyA8PSB0aW1lU2hlZXQucm93Q291bnQ7IHJvdysrKSB7XG5cbiAgICAgICAgY29uc3QgZmlyc3ROYW1lID0gdGltZVNoZWV0LmdldENlbGwocm93LCAxKS52YWx1ZTtcbiAgICAgICAgY29uc3QgbGFzdE5hbWUgPSB0aW1lU2hlZXQuZ2V0Q2VsbChyb3csIDIpLnZhbHVlO1xuICAgICAgICBpZiAoZmlyc3ROYW1lICYmXG4gICAgICAgICAgICAoZmlyc3ROYW1lICsgXCIgXCIgKyBsYXN0TmFtZSAhPSBjdXJyZW50SW50ZXJuKSkge1xuICAgICAgICAgICAgY3VycmVudEludGVybiA9IGZpcnN0TmFtZSArIFwiIFwiICsgbGFzdE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZSA9IHRpbWVTaGVldC5nZXRDZWxsKHJvdywgNSkudmFsdWU7XG4gICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCB3ZWVrTmFtZSA9IGdldERhdGVGcm9tU3RyaW5nKHRpbWVTaGVldC5nZXRDZWxsKHJvdywgNSkudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFdlZWsgPSBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0uaW50ZXJucztcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50V2Vla1tjdXJyZW50SW50ZXJuXSAmJiBjdXJyZW50V2Vla1tjdXJyZW50SW50ZXJuXS5ub3JtYWxIb3Vyc1dvcmtlZCA9PSBcIjAwOjAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0hvdXJzRGF0YShyb3csIHRpbWVTaGVldCwgaG91cnNXb3JrZWRNYXAsIGN1cnJlbnRJbnRlcm4sIHdlZWtOYW1lLCBzaW1wbGlmaWVkU2NoZWR1bGUsIHBlcmNlbnRhZ2VBY2NlcHRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBvcHVsYXRlUm93KHdvcmtCb29rRGF0YSwgY3VycmVudEludGVybkRhdGEsIHBlcmNlbnRhZ2VBY2NlcHRlZCwgcm93KTtcbiAgICAgICAgLy8gY3VyclNoZWV0LmdldENlbGwoMiwgOSkudmFsdWUgPSBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0udG90YWw7XG4gICAgICAgIC8vIGN1cnJTaGVldC5nZXRDZWxsKDIsIDEwKS52YWx1ZSA9IHNpbXBsaWZpZWRTY2hlZHVsZVt3ZWVrTmFtZV0udG90YWxTY2hlZHVsZWRIb3VycztcbiAgICAgICAgLy8gY3VyclNoZWV0LmdldENlbGwoMiwgMTEpLnZhbHVlID0gKGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbCAvIHNpbXBsaWZpZWRTY2hlZHVsZVt3ZWVrTmFtZV0udG90YWxTY2hlZHVsZWRIb3VycyAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICB9XG5cbn1cblxuY29uc3Qgc2V0VXBOZXdTaGVldCA9IChob3Vyc1dvcmtlZE1hcCwgd2Vla05hbWUsIHdvcmtib29rKSA9PiB7XG4gICAgaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdID0ge307XG4gICAgaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdLnRvdGFsID0gMDtcbiAgICBjb25zdCBzaGVldCA9IHdvcmtib29rLmFkZFdvcmtzaGVldCh3ZWVrTmFtZSk7XG4gICAgc2hlZXQudmlld3MgPSBbe31dO1xuICAgIHNoZWV0LnByb3BlcnRpZXMuZGVmYXVsdENvbFdpZHRoID0gMTU7XG4gICAgc2hlZXQucHJvcGVydGllcy5kZWZhdWx0Um93SGVpZ2h0ID0gMjA7XG4gICAgc2V0VXBDb2x1bW5zKHNoZWV0KTtcbn1cblxuY29uc3Qgc2V0VXBDb2x1bW5zID0gKHdvcmtzaGVldCkgPT4ge1xuICAgIGNvbnN0IGZpcnN0TmFtZSA9IHdvcmtzaGVldC5nZXRDb2x1bW4oMSk7XG4gICAgZmlyc3ROYW1lLmhlYWRlciA9IFwiRmlyc3QgTmFtZVwiO1xuICAgIGZpcnN0TmFtZS5rZXkgPSBcImZpcnN0TmFtZVwiO1xuXG4gICAgY29uc3QgbGFzdE5hbWUgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDIpO1xuICAgIGxhc3ROYW1lLmhlYWRlciA9IFwiTGFzdCBOYW1lXCI7XG4gICAgbGFzdE5hbWUua2V5ID0gXCJsYXN0TmFtZVwiO1xuXG4gICAgY29uc3QgaG91cnNXb3JrZWQgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDMpO1xuICAgIGhvdXJzV29ya2VkLmhlYWRlciA9IFwiSG91cnMgV29ya2VkXCI7XG4gICAgaG91cnNXb3JrZWQua2V5ID0gXCJob3Vyc1dvcmtlZFwiO1xuXG4gICAgY29uc3QgaG91cnNTY2hlZHVsZWQgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDQpO1xuICAgIGhvdXJzU2NoZWR1bGVkLmhlYWRlciA9IFwiSG91cnMgU2NoZWR1bGVkXCI7XG4gICAgaG91cnNTY2hlZHVsZWQua2V5ID0gXCJob3Vyc1NjaGVkdWxlZFwiO1xuXG5cbiAgICBjb25zdCBwZXJjZW50V29ya2VkID0gd29ya3NoZWV0LmdldENvbHVtbig1KTtcbiAgICBwZXJjZW50V29ya2VkLmhlYWRlciA9IFwiUGVyY2VudCBXb3JrZWRcIjtcbiAgICBwZXJjZW50V29ya2VkLmtleSA9IFwicGVyY2VudFdvcmtlZFwiO1xuXG4gICAgY29uc3QgY2hhbmdlRnJvbVByZXZpb3VzV2VlayA9IHdvcmtzaGVldC5nZXRDb2x1bW4oNik7XG4gICAgY2hhbmdlRnJvbVByZXZpb3VzV2Vlay5oZWFkZXIgPSBcIlBlcmNlbnQgQ2hhbmdlIGZyb20gTGFzdCBXZWVrXCI7XG4gICAgY2hhbmdlRnJvbVByZXZpb3VzV2Vlay5rZXkgPSBcImNoYW5nZUZyb21QcmV2aW91c1dlZWtcIjtcbiAgICBjaGFuZ2VGcm9tUHJldmlvdXNXZWVrLndpZHRoID0gMjU7XG5cbiAgICBjb25zdCB0YUFzc2lnbmVkID0gd29ya3NoZWV0LmdldENvbHVtbig3KTtcbiAgICB0YUFzc2lnbmVkLmhlYWRlciA9IFwiVEFcIjtcbiAgICB0YUFzc2lnbmVkLmtleSA9IFwidGFcIjtcblxuICAgIGNvbnN0IHRvdGFsV29ya2VkID0gd29ya3NoZWV0LmdldENvbHVtbig5KTtcbiAgICB0b3RhbFdvcmtlZC5oZWFkZXIgPSBcIlRvdGFsIFdvcmtlZFwiO1xuICAgIHRvdGFsV29ya2VkLmtleSA9IFwidG90YWxXb3JrZWRcIjtcblxuICAgIGNvbnN0IHRvdGFsU2NoZWR1bGVkID0gd29ya3NoZWV0LmdldENvbHVtbigxMCk7XG4gICAgdG90YWxTY2hlZHVsZWQuaGVhZGVyID0gXCJUb3RhbCBTY2hlZHVsZWRcIjtcbiAgICB0b3RhbFNjaGVkdWxlZC5rZXkgPSBcInRvdGFsU2NoZWR1bGVkXCI7XG5cbiAgICBjb25zdCB0b3RhbFBlcmNlbnRXb3JrZWQgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDExKTtcbiAgICB0b3RhbFBlcmNlbnRXb3JrZWQuaGVhZGVyID0gXCJQZXJjZW50IFdvcmtlZFwiO1xuICAgIHRvdGFsUGVyY2VudFdvcmtlZC5rZXkgPSBcInRvdGFsUGVyY2VudFdvcmtlZFwiO1xuXG4gICAgY29uc3QgdG90YWxQZXJjZW50Q2hhbmdlID0gd29ya3NoZWV0LmdldENvbHVtbigxMik7XG4gICAgdG90YWxQZXJjZW50Q2hhbmdlLmhlYWRlciA9IFwiVG90YWwgUGVyY2VudCBDaGFuZ2UgZnJvbSBMYXN0IFdlZWtcIjtcbiAgICB0b3RhbFBlcmNlbnRDaGFuZ2Uua2V5ID0gXCJ0b3RhbFBlcmNlbnRDaGFuZ2VcIjtcbiAgICB0b3RhbFBlcmNlbnRDaGFuZ2Uud2lkdGggPSAzMDtcblxuXG59XG5cbmNvbnN0IHBvcHVsYXRlUm93ID0gKHdvcmtCb29rRGF0YSwgY3VycmVudEludGVybkRhdGEsIHBlcmNlbnRhZ2VBY2NlcHRlZCwgcm93KSA9PiB7XG4gICAgY29uc3QgY3VyclNoZWV0ID0gd29ya0Jvb2tEYXRhLndvcmtib29rLmdldFdvcmtzaGVldCh3b3JrQm9va0RhdGEud2Vla05hbWUpO1xuXG4gICAgY3VyclNoZWV0LmFkZFJvdyh7XG4gICAgICAgIGZpcnN0TmFtZTogY3VycmVudEludGVybkRhdGEuZmlyc3ROYW1lLFxuICAgICAgICBsYXN0TmFtZTogY3VycmVudEludGVybkRhdGEubGFzdE5hbWUsXG4gICAgICAgIGhvdXJzV29ya2VkOiBub3JtYWxIb3Vyc1dvcmtlZCxcbiAgICAgICAgaG91cnNTY2hlZHVsZWQ6IG5vcm1hbEhvdXJzU2NoZWR1bGVkLFxuICAgICAgICBwZXJjZW50V29ya2VkOiBwZXJjZW50YWdlRGlmZmVyZW5jZSxcblxuICAgIH0pXG5cbiAgICBjb2xvclBlcmNlbnRhZ2VDZWxsKGN1cnJTaGVldCwgcGVyY2VudGFnZUFjY2VwdGVkKTtcblxufVxuXG5jb25zdCBwcm9jZXNzSG91cnNEYXRhID0gKHJvdywgdGltZVNoZWV0LCBob3Vyc1dvcmtlZE1hcCwgY3VycmVudEludGVybiwgd2Vla05hbWUsIHNpbXBsaWZpZWRTY2hlZHVsZSwgcGVyY2VudGFnZUFjY2VwdGVkKSA9PiB7XG4gICAgY29uc3Qgbm9ybWFsSG91cnNXb3JrZWQgPSB0aW1lU2hlZXQuZ2V0Q2VsbChyb3csIDE1KS52YWx1ZSA/IHRpbWVTaGVldC5nZXRDZWxsKHJvdywgMTUpLnZhbHVlIDogXCIwMDowMFwiO1xuICAgIGlmICghaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdLnRvdGFsLnBlcmNlbnRhZ2VBY2NlcHRlZE51bWJlcnMpIHtcbiAgICAgICAgaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdLnRvdGFsLnBlcmNlbnRhZ2VBY2NlcHRlZE51bWJlcnMgPSB7XG4gICAgICAgICAgICBudW1iZXJCZWxvd1BlcmNlbnRhZ2VBY2NlcHRlZDogMCxcbiAgICAgICAgICAgIHRvdGFsTnVtYmVyT2ZQZXJjZW50YWdlczogMCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWhvdXJzV29ya2VkTWFwLnRvdGFsLnRvdGFsLnBlcmNlbnRhZ2VBY2NlcHRlZE51bWJlcnMpIHtcbiAgICAgICAgaG91cnNXb3JrZWRNYXAudG90YWwudG90YWwucGVyY2VudGFnZUFjY2VwdGVkTnVtYmVycyA9IHtcbiAgICAgICAgICAgIG51bWJlckJlbG93UGVyY2VudGFnZUFjY2VwdGVkOiAwLFxuICAgICAgICAgICAgdG90YWxOdW1iZXJPZlBlcmNlbnRhZ2VzOiAwLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbC5wZXJjZW50YWdlQWNjZXB0ZWROdW1iZXJzLnRvdGFsTnVtYmVyT2ZQZXJjZW50YWdlcysrO1xuXG4gICAgaG91cnNXb3JrZWRNYXAudG90YWwudG90YWwucGVyY2VudGFnZUFjY2VwdGVkTnVtYmVycy50b3RhbE51bWJlck9mUGVyY2VudGFnZXMrKztcblxuXG5cbiAgICBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0uaW50ZXJuc1tjdXJyZW50SW50ZXJuXS5ub3JtYWxIb3Vyc1dvcmtlZCA9IG5vcm1hbEhvdXJzV29ya2VkO1xuXG4gICAgY29uc3QgZGVjaW1hbEhvdXJzU2NoZWR1bGVkID0gc2ltcGxpZmllZFNjaGVkdWxlW3dlZWtOYW1lXS5pbnRlcm5zW2N1cnJlbnRJbnRlcm5dO1xuICAgIGNvbnN0IGRlY2ltYWxIb3Vyc1dvcmtlZCA9IGhvdXJzVG9EZWNpbWFsKG5vcm1hbEhvdXJzV29ya2VkKTtcblxuXG4gICAgaG91cnNXb3JrZWRNYXBbd2Vla05hbWVdLnRvdGFsLnRvdGFsSG91cnNXb3JrZWQgKz0gZGVjaW1hbEhvdXJzV29ya2VkO1xuICAgIGNvbnN0IHRvdGFsSW50ZXJuSG91cnNXb3JrZWQgPSBob3Vyc1dvcmtlZE1hcC50b3RhbC5pbnRlcm5zW2N1cnJlbnRJbnRlcm5dLm5vcm1hbEhvdXJzV29ya2VkO1xuICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbC5wZXJjZW50YWdlRGlmZmVyZW5jZSA9IChob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0udG90YWwudG90YWxIb3Vyc1dvcmtlZCAvIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbC50b3RhbEhvdXJzU2NoZWR1bGVkICogMTAwKS50b0ZpeGVkKDIpO1xuXG4gICAgaG91cnNXb3JrZWRNYXAudG90YWwuaW50ZXJuc1tjdXJyZW50SW50ZXJuXS5ub3JtYWxIb3Vyc1dvcmtlZCA9IGRlY2ltYWxUb0hvdXJzKGhvdXJzVG9EZWNpbWFsKHRvdGFsSW50ZXJuSG91cnNXb3JrZWQpICsgZGVjaW1hbEhvdXJzV29ya2VkKTtcblxuICAgIGhvdXJzV29ya2VkTWFwLnRvdGFsLmludGVybnNbY3VycmVudEludGVybl0ucGVyY2VudGFnZURpZmZlcmVuY2UgPSAoaG91cnNUb0RlY2ltYWwoaG91cnNXb3JrZWRNYXAudG90YWwuaW50ZXJuc1tjdXJyZW50SW50ZXJuXS5ub3JtYWxIb3Vyc1dvcmtlZClcbiAgICAgICAgLyBob3Vyc1RvRGVjaW1hbChob3Vyc1dvcmtlZE1hcC50b3RhbC5pbnRlcm5zW2N1cnJlbnRJbnRlcm5dLm5vcm1hbEhvdXJzU2NoZWR1bGVkKSAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICBob3Vyc1dvcmtlZE1hcC50b3RhbC50b3RhbC50b3RhbEhvdXJzV29ya2VkICs9IGRlY2ltYWxIb3Vyc1dvcmtlZDtcbiAgICBob3Vyc1dvcmtlZE1hcC50b3RhbC50b3RhbC5wZXJjZW50YWdlRGlmZmVyZW5jZSA9IChob3Vyc1dvcmtlZE1hcC50b3RhbC50b3RhbC50b3RhbEhvdXJzV29ya2VkIC8gaG91cnNXb3JrZWRNYXAudG90YWwudG90YWwudG90YWxIb3Vyc1NjaGVkdWxlZCAqIDEwMCkudG9GaXhlZCgyKTtcblxuICAgIGNvbnN0IHBlcmNlbnRhZ2VEaWZmZXJlbmNlID0gKGRlY2ltYWxIb3Vyc1dvcmtlZCAvIGRlY2ltYWxIb3Vyc1NjaGVkdWxlZCAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0uaW50ZXJuc1tjdXJyZW50SW50ZXJuXS5wZXJjZW50YWdlRGlmZmVyZW5jZSA9IHBlcmNlbnRhZ2VEaWZmZXJlbmNlO1xuICAgIGlmIChwZXJjZW50YWdlRGlmZmVyZW5jZSA8IHBlcmNlbnRhZ2VBY2NlcHRlZCkge1xuICAgICAgICBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0udG90YWwucGVyY2VudGFnZUFjY2VwdGVkTnVtYmVycy5udW1iZXJCZWxvd1BlcmNlbnRhZ2VBY2NlcHRlZCsrO1xuICAgICAgICBob3Vyc1dvcmtlZE1hcC50b3RhbC50b3RhbC5wZXJjZW50YWdlQWNjZXB0ZWROdW1iZXJzLm51bWJlckJlbG93UGVyY2VudGFnZUFjY2VwdGVkKys7XG5cbiAgICB9XG59XG5cbmNvbnN0IHByb2Nlc3NDaGFuZ2VGcm9tUHJldmlvdXNXZWVrID0gKGhvdXJzV29ya2VkTWFwKSA9PiB7XG4gICAgT2JqZWN0LmtleXMoaG91cnNXb3JrZWRNYXApLmZvckVhY2goKGRhdGUpID0+IHtcbiAgICAgICAgY29uc3Qgd29ya1dlZWtQZXJjZW50YWdlcyA9IGhvdXJzV29ya2VkTWFwW2RhdGVdLnRvdGFsLnBlcmNlbnRhZ2VBY2NlcHRlZE51bWJlcnM7XG4gICAgICAgIHdvcmtXZWVrUGVyY2VudGFnZXMucGVyY2VudGFnZURpZmZlcmVuY2UgPSAoKHdvcmtXZWVrUGVyY2VudGFnZXMudG90YWxOdW1iZXJPZlBlcmNlbnRhZ2VzIC0gd29ya1dlZWtQZXJjZW50YWdlcy5udW1iZXJCZWxvd1BlcmNlbnRhZ2VBY2NlcHRlZClcbiAgICAgICAgICAgIC8gd29ya1dlZWtQZXJjZW50YWdlcy50b3RhbE51bWJlck9mUGVyY2VudGFnZXMgKiAxMDApLnRvRml4ZWQoMik7XG4gICAgICAgIGlmIChkYXRlICE9IFwidG90YWxcIikge1xuICAgICAgICAgICAgY29uc3Qgd2Vla0JlZm9yZSA9IGdldFdlZWtCZWZvcmUoZGF0ZSk7XG4gICAgICAgICAgICBpZiAoaG91cnNXb3JrZWRNYXBbd2Vla0JlZm9yZV0pIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhob3Vyc1dvcmtlZE1hcFtkYXRlXS5pbnRlcm5zKS5mb3JFYWNoKChpbnRlcm4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaG91cnNXb3JrZWRNYXBbZGF0ZV0uaW50ZXJuc1tpbnRlcm5dLmNoYW5nZUZyb21QcmV2aW91c1dlZWsgPSAocGFyc2VGbG9hdChob3Vyc1dvcmtlZE1hcFtkYXRlXS5pbnRlcm5zW2ludGVybl0ucGVyY2VudGFnZURpZmZlcmVuY2UpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaG91cnNXb3JrZWRNYXBbd2Vla0JlZm9yZV0uaW50ZXJuc1tpbnRlcm5dLnBlcmNlbnRhZ2VEaWZmZXJlbmNlKSkudG9GaXhlZCgyKTtcblxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgaG91cnNXb3JrZWRNYXBbZGF0ZV0udG90YWwuY2hhbmdlRnJvbVByZXZpb3VzV2VlayA9IChwYXJzZUZsb2F0KGhvdXJzV29ya2VkTWFwW2RhdGVdLnRvdGFsLnBlcmNlbnRhZ2VEaWZmZXJlbmNlKSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaG91cnNXb3JrZWRNYXBbd2Vla0JlZm9yZV0udG90YWwucGVyY2VudGFnZURpZmZlcmVuY2UpKS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcbiAgICAvLyB3b3JrYm9vay5lYWNoU2hlZXQoKHdvcmtzaGVldCkgPT4ge1xuICAgIC8vICAgICBjb25zdCBjdXJyV2VlayA9IHdvcmtzaGVldC5uYW1lO1xuICAgIC8vICAgICBjb25zdCBwcmV2V2VlayA9IGdldFdlZWtCZWZvcmUoY3VycldlZWspO1xuICAgIC8vICAgICBmb3IgKGxldCByb3cgPSAyOyByb3cgPD0gd29ya3NoZWV0LnJvd0NvdW50OyByb3crKykge1xuICAgIC8vICAgICAgICAgY29uc3QgZmlyc3ROYW1lID0gd29ya3NoZWV0LmdldENlbGwocm93LCAxKS52YWx1ZTtcbiAgICAvLyAgICAgICAgIGNvbnN0IGxhc3ROYW1lID0gd29ya3NoZWV0LmdldENlbGwocm93LCAyKS52YWx1ZTtcbiAgICAvLyAgICAgICAgIGNvbnN0IGZ1bGxOYW1lID0gZmlyc3ROYW1lICsgJyAnICsgbGFzdE5hbWU7XG4gICAgLy8gICAgICAgICBsZXQgcGVyY2VudGFnZURpZmZlcmVuY2VPZlByZXZpb3VzV2VlaztcbiAgICAvLyAgICAgICAgIGlmIChob3Vyc1dvcmtlZE1hcFtwcmV2V2Vla10gJiYgaG91cnNXb3JrZWRNYXBbcHJldldlZWtdW2Z1bGxOYW1lXSkge1xuICAgIC8vICAgICAgICAgICAgIHBlcmNlbnRhZ2VEaWZmZXJlbmNlT2ZQcmV2aW91c1dlZWsgPSBob3Vyc1dvcmtlZE1hcFtwcmV2V2Vla11bZnVsbE5hbWVdLnBlcmNlbnRhZ2VEaWZmZXJlbmNlO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICAgICAgY29uc3QgcGVyY2VudGFnZURpZmZlcmVuY2VPZkN1cnJlbnRXZWVrID0gaG91cnNXb3JrZWRNYXBbY3VycldlZWtdW2Z1bGxOYW1lXS5wZXJjZW50YWdlRGlmZmVyZW5jZTtcbiAgICAvLyAgICAgICAgIGxldCBkaWZmZXJlbmNlRnJvbVdlZWtzID0gcGVyY2VudGFnZURpZmZlcmVuY2VPZlByZXZpb3VzV2VlayA/XG4gICAgLy8gICAgICAgICAgICAgKHBlcmNlbnRhZ2VEaWZmZXJlbmNlT2ZDdXJyZW50V2VlayAtIHBlcmNlbnRhZ2VEaWZmZXJlbmNlT2ZQcmV2aW91c1dlZWspLnRvRml4ZWQoMikgOiBcIlwiO1xuXG4gICAgLy8gICAgICAgICBjb25zdCBjdXJyQ2VsbCA9IHdvcmtzaGVldC5nZXRDZWxsKHJvdywgNik7XG4gICAgLy8gICAgICAgICBjdXJyQ2VsbC52YWx1ZSA9IGRpZmZlcmVuY2VGcm9tV2Vla3M7XG5cbiAgICAvLyAgICAgICAgIGlmIChjdXJyQ2VsbCA8PSAtMTUpIHtcbiAgICAvLyAgICAgICAgICAgICBjdXJyQ2VsbC5maWxsID0ge1xuICAgIC8vICAgICAgICAgICAgICAgICB0eXBlOiAncGF0dGVybicsXG4gICAgLy8gICAgICAgICAgICAgICAgIHBhdHRlcm46ICdzb2xpZCcsXG4gICAgLy8gICAgICAgICAgICAgICAgIGZnQ29sb3I6IHsgYXJnYjogJzgwZTc2MDYwJyB9XG4gICAgLy8gICAgICAgICAgICAgfTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIGlmIChjdXJyQ2VsbCA+IDE1KSB7XG4gICAgLy8gICAgICAgICAgICAgY3VyckNlbGwuZmlsbCA9IHtcbiAgICAvLyAgICAgICAgICAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgIC8vICAgICAgICAgICAgICAgICBwYXR0ZXJuOiAnc29saWQnLFxuICAgIC8vICAgICAgICAgICAgICAgICBmZ0NvbG9yOiB7IGFyZ2I6ICc4MDQyZjU4ZCcgfVxuICAgIC8vICAgICAgICAgICAgIH07XG4gICAgLy8gICAgICAgICB9XG5cbiAgICAvLyAgICAgfVxuICAgIC8vIH0pXG5cbn1cblxuY29uc3QgY29sb3JQZXJjZW50YWdlQ2VsbCA9IChjdXJyU2hlZXQsIHBlcmNlbnRhZ2VBY2NlcHRlZCkgPT4ge1xuICAgIGNvbnN0IGN1cnJDZWxsID0gY3VyclNoZWV0LmdldENlbGwoY3VyclNoZWV0LnJvd0NvdW50LCA1KVxuICAgIGlmIChwYXJzZUZsb2F0KGN1cnJDZWxsKSA8IHBlcmNlbnRhZ2VBY2NlcHRlZCkge1xuICAgICAgICBjdXJyQ2VsbC5maWxsID0ge1xuICAgICAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgcGF0dGVybjogJ3NvbGlkJyxcbiAgICAgICAgICAgIGZnQ29sb3I6IHsgYXJnYjogJzgwZTc2MDYwJyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwYXJzZUZsb2F0KGN1cnJDZWxsKSA+IDEwMCkge1xuICAgICAgICBjdXJyQ2VsbC5maWxsID0ge1xuICAgICAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgcGF0dGVybjogJ3NvbGlkJyxcbiAgICAgICAgICAgIGZnQ29sb3I6IHsgYXJnYjogJzgwNDJmNThkJyB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IG1ha2VUaW1lc2hlZXRBbmFseXNpczsiXSwibmFtZXMiOlsiRXhjZWxKUyIsIkZpbGVTYXZlciIsImhvdXJzVG9EZWNpbWFsIiwiZ2V0RGF0ZUZyb21TdHJpbmciLCJkZWNpbWFsVG9Ib3VycyIsImdldFdlZWtCZWZvcmUiLCJtYWtlVGltZXNoZWV0QW5hbHlzaXMiLCJ0aW1lc2hlZXRFeGNlbCIsInNpbXBsaWZpZWRTY2hlZHVsZSIsInBlcmNlbnRhZ2VBY2NlcHRlZCIsIndvcmtib29rIiwiV29ya2Jvb2siLCJob3Vyc1dvcmtlZE1hcCIsInRvdGFsIiwidG90YWxIb3Vyc1dvcmtlZCIsInRvdGFsSG91cnNTY2hlZHVsZWQiLCJwZXJjZW50YWdlQWNjZXB0ZWROdW1iZXJzIiwibnVtYmVyQmVsb3dQZXJjZW50YWdlQWNjZXB0ZWQiLCJ0b3RhbE51bWJlck9mUGVyY2VudGFnZXMiLCJpbnRlcm5zIiwiaW5pdGlhbGl6ZUhvdXJzV29ya2VkTWFwIiwicG9wdWxhdGVIb3Vyc1dvcmtlZE1hcCIsInByb2Nlc3NDaGFuZ2VGcm9tUHJldmlvdXNXZWVrIiwiY29uc29sZSIsImxvZyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwid2Vla05hbWUiLCJpbnRlcm4iLCJkZWNpbWFsSG91cnNTY2hlZHVsZWQiLCJub3JtYWxIb3Vyc1NjaGVkdWxlZCIsImN1cnJJbnRlcm4iLCJub3JtYWxIb3Vyc1dvcmtlZCIsInBlcmNlbnRhZ2VEaWZmZXJlbmNlIiwidGltZVNoZWV0IiwiZ2V0V29ya3NoZWV0IiwidGVtcEZpcnN0TmFtZSIsImdldENlbGwiLCJ2YWx1ZSIsInRlbXBMYXN0TmFtZSIsImN1cnJlbnRJbnRlcm4iLCJyb3ciLCJyb3dDb3VudCIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiZGF0ZSIsImN1cnJlbnRXZWVrIiwicHJvY2Vzc0hvdXJzRGF0YSIsInNldFVwTmV3U2hlZXQiLCJzaGVldCIsImFkZFdvcmtzaGVldCIsInZpZXdzIiwicHJvcGVydGllcyIsImRlZmF1bHRDb2xXaWR0aCIsImRlZmF1bHRSb3dIZWlnaHQiLCJzZXRVcENvbHVtbnMiLCJ3b3Jrc2hlZXQiLCJnZXRDb2x1bW4iLCJoZWFkZXIiLCJrZXkiLCJob3Vyc1dvcmtlZCIsImhvdXJzU2NoZWR1bGVkIiwicGVyY2VudFdvcmtlZCIsImNoYW5nZUZyb21QcmV2aW91c1dlZWsiLCJ3aWR0aCIsInRhQXNzaWduZWQiLCJ0b3RhbFdvcmtlZCIsInRvdGFsU2NoZWR1bGVkIiwidG90YWxQZXJjZW50V29ya2VkIiwidG90YWxQZXJjZW50Q2hhbmdlIiwicG9wdWxhdGVSb3ciLCJ3b3JrQm9va0RhdGEiLCJjdXJyZW50SW50ZXJuRGF0YSIsImN1cnJTaGVldCIsImFkZFJvdyIsImNvbG9yUGVyY2VudGFnZUNlbGwiLCJkZWNpbWFsSG91cnNXb3JrZWQiLCJ0b3RhbEludGVybkhvdXJzV29ya2VkIiwidG9GaXhlZCIsIndvcmtXZWVrUGVyY2VudGFnZXMiLCJ3ZWVrQmVmb3JlIiwicGFyc2VGbG9hdCIsImN1cnJDZWxsIiwiZmlsbCIsInR5cGUiLCJwYXR0ZXJuIiwiZmdDb2xvciIsImFyZ2IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/helpers/makeTimeSheetAnalysis.jsx\n"));

/***/ })

});