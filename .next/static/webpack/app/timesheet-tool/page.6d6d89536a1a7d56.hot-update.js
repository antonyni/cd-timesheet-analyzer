"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/timesheet-tool/page",{

/***/ "(app-pages-browser)/./src/helpers/makeTimeSheetAnalysis.jsx":
/*!***********************************************!*\
  !*** ./src/helpers/makeTimeSheetAnalysis.jsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var exceljs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! exceljs */ \"(app-pages-browser)/./node_modules/exceljs/dist/exceljs.min.js\");\n/* harmony import */ var exceljs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(exceljs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hoursToDecimal */ \"(app-pages-browser)/./src/helpers/hoursToDecimal.jsx\");\n/* harmony import */ var _getDateFromString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getDateFromString */ \"(app-pages-browser)/./src/helpers/getDateFromString.jsx\");\n/* harmony import */ var _decimalToHours__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./decimalToHours */ \"(app-pages-browser)/./src/helpers/decimalToHours.jsx\");\n/* harmony import */ var _getWeekBefore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWeekBefore */ \"(app-pages-browser)/./src/helpers/getWeekBefore.jsx\");\n\n\n\n\n\n\nconst makeTimesheetAnalysis = (timesheetExcel, simplifiedSchedule, percentageAccepted)=>{\n    const workbook = new exceljs__WEBPACK_IMPORTED_MODULE_0__.Workbook();\n    let hoursWorkedMap = {};\n    hoursWorkedMap.total = 0;\n    const timeSheet = timesheetExcel.getWorksheet(\"All Employees\");\n    let firstName = timeSheet.getCell(2, 1).value;\n    let lastName = timeSheet.getCell(2, 2).value;\n    let currentIntern = firstName + \" \" + lastName;\n    for(let row = 2; row <= timeSheet.rowCount; row++){\n        const tempFirstName = timeSheet.getCell(row, 1).value;\n        const tempLastName = timeSheet.getCell(row, 2).value;\n        if (tempFirstName && tempFirstName + \" \" + tempLastName != currentIntern) {\n            currentIntern = tempFirstName + \" \" + tempLastName;\n            firstName = tempFirstName;\n            lastName = tempLastName;\n        }\n        const weekName = (0,_getDateFromString__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(timeSheet.getCell(row, 5).value);\n        const weekSchedule = simplifiedSchedule[weekName];\n        if (weekSchedule && weekSchedule[currentIntern]) {\n            if (!hoursWorkedMap[weekName]) {\n                setUpNewSheet(hoursWorkedMap, weekName, workbook);\n            }\n            const currentWeek = hoursWorkedMap[weekName];\n            if (!currentWeek[currentIntern]) {\n                const currentInternData = {\n                    fullName: currentIntern,\n                    firstName: firstName,\n                    lastName: lastName\n                };\n                const workBookData = {\n                    workbook: workbook,\n                    weekName: weekName,\n                    timeSheet: timeSheet,\n                    currentWeek: currentWeek,\n                    hoursWorkedMap: hoursWorkedMap,\n                    simplifiedSchedule: simplifiedSchedule\n                };\n                populateRow(workBookData, currentInternData, percentageAccepted, row);\n            // currSheet.getCell(2, 9).value = hoursWorkedMap[weekName].total;\n            // currSheet.getCell(2, 10).value = simplifiedSchedule[weekName].totalScheduledHours;\n            // currSheet.getCell(2, 11).value = (hoursWorkedMap[weekName].total / simplifiedSchedule[weekName].totalScheduledHours * 100).toFixed(2);\n            }\n        }\n    }\n    workbook.eachSheet((worksheet, sheetId)=>{\n        console.log(sheetId);\n    });\n// workbook.xlsx.writeBuffer().then(data => {\n//     const blob = new Blob([data]);\n//     FileSaver.saveAs(blob, \"Timesheet Analysis.xlsx\");\n// });\n};\nconst setUpNewSheet = (hoursWorkedMap, weekName, workbook)=>{\n    hoursWorkedMap[weekName] = {};\n    hoursWorkedMap[weekName].total = 0;\n    const sheet = workbook.addWorksheet(weekName);\n    sheet.views = [\n        {}\n    ];\n    sheet.properties.defaultColWidth = 15;\n    sheet.properties.defaultRowHeight = 20;\n    setUpColumns(sheet);\n};\nconst setUpColumns = (worksheet)=>{\n    const firstName = worksheet.getColumn(1);\n    firstName.header = \"First Name\";\n    firstName.key = \"firstName\";\n    const lastName = worksheet.getColumn(2);\n    lastName.header = \"Last Name\";\n    lastName.key = \"lastName\";\n    const hoursWorked = worksheet.getColumn(3);\n    hoursWorked.header = \"Hours Worked\";\n    hoursWorked.key = \"hoursWorked\";\n    const hoursScheduled = worksheet.getColumn(4);\n    hoursScheduled.header = \"Hours Scheduled\";\n    hoursScheduled.key = \"hoursScheduled\";\n    const percentWorked = worksheet.getColumn(5);\n    percentWorked.header = \"Percent Worked\";\n    percentWorked.key = \"percentWorked\";\n    const changeFromPreviousWeek = worksheet.getColumn(6);\n    changeFromPreviousWeek.header = \"Change from Last Week\";\n    changeFromPreviousWeek.key = \"changeFromPreviousWeek\";\n    const taAssigned = worksheet.getColumn(7);\n    taAssigned.header = \"TA\";\n    taAssigned.key = \"ta\";\n    const totalWorked = worksheet.getColumn(9);\n    totalWorked.header = \"Total Worked\";\n    totalWorked.key = \"totalWorked\";\n    const totalScheduled = worksheet.getColumn(10);\n    totalScheduled.header = \"Total Scheduled\";\n    totalScheduled.key = \"totalScheduled\";\n    const totalPercentWorked = worksheet.getColumn(11);\n    totalPercentWorked.header = \"Percent Worked\";\n    totalPercentWorked.key = \"totalPercentWorked\";\n    const totalPercentChange = worksheet.getColumn(12);\n    totalPercentChange.header = \"Change from Last Week\";\n    totalPercentChange.key = \"totalPercentChange\";\n};\nconst populateRow = (workBookData, currentInternData, percentageAccepted, row)=>{\n    const currSheet = workBookData.workbook.getWorksheet(workBookData.weekName);\n    const [normalHoursWorked, normalHoursScheduled, percentageDifference] = processHoursData(row, workBookData.timeSheet, workBookData.currentWeek, currentInternData.fullName, workBookData.weekName, workBookData.simplifiedSchedule);\n    currSheet.addRow({\n        firstName: currentInternData.firstName,\n        lastName: currentInternData.lastName,\n        hoursWorked: normalHoursWorked,\n        hoursScheduled: normalHoursScheduled,\n        percentWorked: percentageDifference\n    });\n    colorPercentageCell(currSheet, percentageAccepted);\n};\nconst processHoursData = (row, timeSheet, currentWeek, currentIntern, weekName, simplifiedSchedule)=>{\n    const potentialWorkHours = timeSheet.getCell(row, 15).value;\n    const workHours = potentialWorkHours ? potentialWorkHours : \"00:00\";\n    currentWeek[currentIntern] = {\n        hoursWorked: (0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(workHours)\n    };\n    const decimalHoursScheduled = simplifiedSchedule[weekName][currentIntern];\n    const normalHoursScheduled = (0,_decimalToHours__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(decimalHoursScheduled);\n    const normalHoursWorked = workHours;\n    const decimalHoursWorked = (0,_hoursToDecimal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(normalHoursWorked);\n    currentWeek.total += decimalHoursWorked;\n    const percentageDifference = (decimalHoursWorked / decimalHoursScheduled * 100).toFixed(2);\n    currentWeek[currentIntern].percentageDifference = percentageDifference;\n    return [\n        normalHoursWorked,\n        normalHoursScheduled,\n        percentageDifference\n    ];\n};\nconst processChangeFromPreviousWeek = (workBookData, currentInternData)=>{\n    const currWeek = workBookData.weekName;\n    const prevWeek = (0,_getWeekBefore__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(currWeek);\n    let percentageDifferenceOfPreviousWeek;\n    if (workBookData.hoursWorkedMap[prevWeek]) {\n        console.log(currWeek);\n        console.log(workBookData.hoursWorkedMap[currWeek]);\n        console.log(prevWeek);\n        console.log(workBookData.hoursWorkedMap[prevWeek]);\n        if (workBookData.hoursWorkedMap[prevWeek][currentInternData.fullName]) {\n            console.log(\"hi\");\n        }\n    }\n    const percentageDifferenceOfCurrentWeek = workBookData.hoursWorkedMap[currWeek][currentInternData.fullName].percentageDifference;\n    let differenceFromWeeks = percentageDifferenceOfPreviousWeek ? (percentageDifferenceOfCurrentWeek - percentageDifferenceOfPreviousWeek).toFixed(2) : \"\";\n    return differenceFromWeeks;\n};\nconst colorPercentageCell = (currSheet, percentageAccepted)=>{\n    const currCell = currSheet.getCell(currSheet.rowCount, 5);\n    if (parseFloat(currCell) < percentageAccepted) {\n        currCell.fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"80e76060\"\n            }\n        };\n    }\n    if (parseFloat(currCell) > 100) {\n        currCell.fill = {\n            type: \"pattern\",\n            pattern: \"solid\",\n            fgColor: {\n                argb: \"8042f58d\"\n            }\n        };\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (makeTimesheetAnalysis);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9oZWxwZXJzL21ha2VUaW1lU2hlZXRBbmFseXNpcy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtDO0FBQ0s7QUFDTztBQUNNO0FBQ047QUFDRjtBQUU1QyxNQUFNTSx3QkFBd0IsQ0FBQ0MsZ0JBQWdCQyxvQkFBb0JDO0lBQy9ELE1BQU1DLFdBQVcsSUFBSVYsNkNBQWdCO0lBQ3JDLElBQUlZLGlCQUFpQixDQUFDO0lBQ3RCQSxlQUFlQyxLQUFLLEdBQUc7SUFFdkIsTUFBTUMsWUFBWVAsZUFBZVEsWUFBWSxDQUFDO0lBRTlDLElBQUlDLFlBQVlGLFVBQVVHLE9BQU8sQ0FBQyxHQUFHLEdBQUdDLEtBQUs7SUFDN0MsSUFBSUMsV0FBV0wsVUFBVUcsT0FBTyxDQUFDLEdBQUcsR0FBR0MsS0FBSztJQUM1QyxJQUFJRSxnQkFBZ0JKLFlBQVksTUFBTUc7SUFFdEMsSUFBSyxJQUFJRSxNQUFNLEdBQUdBLE9BQU9QLFVBQVVRLFFBQVEsRUFBRUQsTUFBTztRQUVoRCxNQUFNRSxnQkFBZ0JULFVBQVVHLE9BQU8sQ0FBQ0ksS0FBSyxHQUFHSCxLQUFLO1FBQ3JELE1BQU1NLGVBQWVWLFVBQVVHLE9BQU8sQ0FBQ0ksS0FBSyxHQUFHSCxLQUFLO1FBQ3BELElBQUlLLGlCQUNDQSxnQkFBZ0IsTUFBTUMsZ0JBQWdCSixlQUFnQjtZQUN2REEsZ0JBQWdCRyxnQkFBZ0IsTUFBTUM7WUFDdENSLFlBQVlPO1lBQ1pKLFdBQVdLO1FBQ2Y7UUFFQSxNQUFNQyxXQUFXdEIsOERBQWlCQSxDQUFDVyxVQUFVRyxPQUFPLENBQUNJLEtBQUssR0FBR0gsS0FBSztRQUNsRSxNQUFNUSxlQUFlbEIsa0JBQWtCLENBQUNpQixTQUFTO1FBRWpELElBQUlDLGdCQUFnQkEsWUFBWSxDQUFDTixjQUFjLEVBQUU7WUFDN0MsSUFBSSxDQUFDUixjQUFjLENBQUNhLFNBQVMsRUFBRTtnQkFDM0JFLGNBQWNmLGdCQUFnQmEsVUFBVWY7WUFDNUM7WUFF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QUNpRTtJQUMvQixJQUFJRTtJQUNKLElBQUl6QyxhQUFhbkIsY0FBYyxDQUFDMkQsU0FBUyxFQUFFO1FBQ3ZDbkMsUUFBUUMsR0FBRyxDQUFDaUM7UUFDWmxDLFFBQVFDLEdBQUcsQ0FBQ04sYUFBYW5CLGNBQWMsQ0FBQzBELFNBQVM7UUFDakRsQyxRQUFRQyxHQUFHLENBQUNrQztRQUNabkMsUUFBUUMsR0FBRyxDQUFDTixhQUFhbkIsY0FBYyxDQUFDMkQsU0FBUztRQUNqRCxJQUFHeEMsYUFBYW5CLGNBQWMsQ0FBQzJELFNBQVMsQ0FBQzFDLGtCQUFrQkMsUUFBUSxDQUFDLEVBQUM7WUFDakVNLFFBQVFDLEdBQUcsQ0FBQztRQUNoQjtJQUNKO0lBQ0EsTUFBTW9DLG9DQUFvQzFDLGFBQWFuQixjQUFjLENBQUMwRCxTQUFTLENBQUN6QyxrQkFBa0JDLFFBQVEsQ0FBQyxDQUFDOEIsb0JBQW9CO0lBQ2hJLElBQUljLHNCQUFzQkYscUNBQ3RCLENBQUNDLG9DQUFvQ0Qsa0NBQWlDLEVBQUdKLE9BQU8sQ0FBQyxLQUFLO0lBRTFGLE9BQU9NO0FBQ1g7QUFFQSxNQUFNWCxzQkFBc0IsQ0FBQ04sV0FBV2hEO0lBQ3BDLE1BQU1rRSxXQUFXbEIsVUFBVXhDLE9BQU8sQ0FBQ3dDLFVBQVVuQyxRQUFRLEVBQUU7SUFDdkQsSUFBSXNELFdBQVdELFlBQVlsRSxvQkFBb0I7UUFDM0NrRSxTQUFTRSxJQUFJLEdBQUc7WUFDWkMsTUFBTTtZQUNOQyxTQUFTO1lBQ1RDLFNBQVM7Z0JBQUVDLE1BQU07WUFBVztRQUNoQztJQUNKO0lBQ0EsSUFBSUwsV0FBV0QsWUFBWSxLQUFLO1FBQzVCQSxTQUFTRSxJQUFJLEdBQUc7WUFDWkMsTUFBTTtZQUNOQyxTQUFTO1lBQ1RDLFNBQVM7Z0JBQUVDLE1BQU07WUFBVztRQUNoQztJQUNKO0FBQ0o7QUFHQSwrREFBZTNFLHFCQUFxQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaGVscGVycy9tYWtlVGltZVNoZWV0QW5hbHlzaXMuanN4Pzk1YWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXhjZWxKUyBmcm9tICdleGNlbGpzJ1xuaW1wb3J0ICogYXMgRmlsZVNhdmVyIGZyb20gJ2ZpbGUtc2F2ZXInXG5pbXBvcnQgaG91cnNUb0RlY2ltYWwgZnJvbSAnLi9ob3Vyc1RvRGVjaW1hbCc7XG5pbXBvcnQgZ2V0RGF0ZUZyb21TdHJpbmcgZnJvbSAnLi9nZXREYXRlRnJvbVN0cmluZyc7XG5pbXBvcnQgZGVjaW1hbFRvSG91cnMgZnJvbSAnLi9kZWNpbWFsVG9Ib3Vycyc7XG5pbXBvcnQgZ2V0V2Vla0JlZm9yZSBmcm9tICcuL2dldFdlZWtCZWZvcmUnO1xuXG5jb25zdCBtYWtlVGltZXNoZWV0QW5hbHlzaXMgPSAodGltZXNoZWV0RXhjZWwsIHNpbXBsaWZpZWRTY2hlZHVsZSwgcGVyY2VudGFnZUFjY2VwdGVkKSA9PiB7XG4gICAgY29uc3Qgd29ya2Jvb2sgPSBuZXcgRXhjZWxKUy5Xb3JrYm9vaygpO1xuICAgIGxldCBob3Vyc1dvcmtlZE1hcCA9IHt9O1xuICAgIGhvdXJzV29ya2VkTWFwLnRvdGFsID0gMDtcblxuICAgIGNvbnN0IHRpbWVTaGVldCA9IHRpbWVzaGVldEV4Y2VsLmdldFdvcmtzaGVldChcIkFsbCBFbXBsb3llZXNcIik7XG5cbiAgICBsZXQgZmlyc3ROYW1lID0gdGltZVNoZWV0LmdldENlbGwoMiwgMSkudmFsdWU7XG4gICAgbGV0IGxhc3ROYW1lID0gdGltZVNoZWV0LmdldENlbGwoMiwgMikudmFsdWVcbiAgICBsZXQgY3VycmVudEludGVybiA9IGZpcnN0TmFtZSArIFwiIFwiICsgbGFzdE5hbWU7XG5cbiAgICBmb3IgKGxldCByb3cgPSAyOyByb3cgPD0gdGltZVNoZWV0LnJvd0NvdW50OyByb3crKykge1xuXG4gICAgICAgIGNvbnN0IHRlbXBGaXJzdE5hbWUgPSB0aW1lU2hlZXQuZ2V0Q2VsbChyb3csIDEpLnZhbHVlO1xuICAgICAgICBjb25zdCB0ZW1wTGFzdE5hbWUgPSB0aW1lU2hlZXQuZ2V0Q2VsbChyb3csIDIpLnZhbHVlO1xuICAgICAgICBpZiAodGVtcEZpcnN0TmFtZSAmJlxuICAgICAgICAgICAgKHRlbXBGaXJzdE5hbWUgKyBcIiBcIiArIHRlbXBMYXN0TmFtZSAhPSBjdXJyZW50SW50ZXJuKSkge1xuICAgICAgICAgICAgY3VycmVudEludGVybiA9IHRlbXBGaXJzdE5hbWUgKyBcIiBcIiArIHRlbXBMYXN0TmFtZTtcbiAgICAgICAgICAgIGZpcnN0TmFtZSA9IHRlbXBGaXJzdE5hbWU7XG4gICAgICAgICAgICBsYXN0TmFtZSA9IHRlbXBMYXN0TmFtZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2Vla05hbWUgPSBnZXREYXRlRnJvbVN0cmluZyh0aW1lU2hlZXQuZ2V0Q2VsbChyb3csIDUpLnZhbHVlKTtcbiAgICAgICAgY29uc3Qgd2Vla1NjaGVkdWxlID0gc2ltcGxpZmllZFNjaGVkdWxlW3dlZWtOYW1lXTtcblxuICAgICAgICBpZiAod2Vla1NjaGVkdWxlICYmIHdlZWtTY2hlZHVsZVtjdXJyZW50SW50ZXJuXSkge1xuICAgICAgICAgICAgaWYgKCFob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBzZXRVcE5ld1NoZWV0KGhvdXJzV29ya2VkTWFwLCB3ZWVrTmFtZSwgd29ya2Jvb2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50V2VlayA9IGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXTtcbiAgICAgICAgICAgIGlmICghY3VycmVudFdlZWtbY3VycmVudEludGVybl0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SW50ZXJuRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbE5hbWU6IGN1cnJlbnRJbnRlcm4sXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TmFtZTogZmlyc3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0TmFtZTogbGFzdE5hbWUsXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya0Jvb2tEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICB3b3JrYm9vazogd29ya2Jvb2ssXG4gICAgICAgICAgICAgICAgICAgIHdlZWtOYW1lOiB3ZWVrTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGltZVNoZWV0OiB0aW1lU2hlZXQsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXZWVrOiBjdXJyZW50V2VlayxcbiAgICAgICAgICAgICAgICAgICAgaG91cnNXb3JrZWRNYXA6IGhvdXJzV29ya2VkTWFwLFxuICAgICAgICAgICAgICAgICAgICBzaW1wbGlmaWVkU2NoZWR1bGU6IHNpbXBsaWZpZWRTY2hlZHVsZSxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb3B1bGF0ZVJvdyh3b3JrQm9va0RhdGEsIGN1cnJlbnRJbnRlcm5EYXRhLCBwZXJjZW50YWdlQWNjZXB0ZWQsIHJvdyk7XG4gICAgICAgICAgICAgICAgLy8gY3VyclNoZWV0LmdldENlbGwoMiwgOSkudmFsdWUgPSBob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0udG90YWw7XG4gICAgICAgICAgICAgICAgLy8gY3VyclNoZWV0LmdldENlbGwoMiwgMTApLnZhbHVlID0gc2ltcGxpZmllZFNjaGVkdWxlW3dlZWtOYW1lXS50b3RhbFNjaGVkdWxlZEhvdXJzO1xuICAgICAgICAgICAgICAgIC8vIGN1cnJTaGVldC5nZXRDZWxsKDIsIDExKS52YWx1ZSA9IChob3Vyc1dvcmtlZE1hcFt3ZWVrTmFtZV0udG90YWwgLyBzaW1wbGlmaWVkU2NoZWR1bGVbd2Vla05hbWVdLnRvdGFsU2NoZWR1bGVkSG91cnMgKiAxMDApLnRvRml4ZWQoMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cbiAgICB3b3JrYm9vay5lYWNoU2hlZXQoKHdvcmtzaGVldCwgc2hlZXRJZCk9PntcblxuICAgICAgICBjb25zb2xlLmxvZyhzaGVldElkKTtcblxuICAgIH0pXG5cblxuICAgIC8vIHdvcmtib29rLnhsc3gud3JpdGVCdWZmZXIoKS50aGVuKGRhdGEgPT4ge1xuICAgIC8vICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgICAvLyAgICAgRmlsZVNhdmVyLnNhdmVBcyhibG9iLCBcIlRpbWVzaGVldCBBbmFseXNpcy54bHN4XCIpO1xuICAgIC8vIH0pO1xuXG59XG5cbmNvbnN0IHNldFVwTmV3U2hlZXQgPSAoaG91cnNXb3JrZWRNYXAsIHdlZWtOYW1lLCB3b3JrYm9vaykgPT4ge1xuICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXSA9IHt9O1xuICAgIGhvdXJzV29ya2VkTWFwW3dlZWtOYW1lXS50b3RhbCA9IDA7XG4gICAgY29uc3Qgc2hlZXQgPSB3b3JrYm9vay5hZGRXb3Jrc2hlZXQod2Vla05hbWUpO1xuICAgIHNoZWV0LnZpZXdzID0gW3t9XTtcbiAgICBzaGVldC5wcm9wZXJ0aWVzLmRlZmF1bHRDb2xXaWR0aCA9IDE1O1xuICAgIHNoZWV0LnByb3BlcnRpZXMuZGVmYXVsdFJvd0hlaWdodCA9IDIwO1xuICAgIHNldFVwQ29sdW1ucyhzaGVldCk7XG59XG5cbmNvbnN0IHNldFVwQ29sdW1ucyA9ICh3b3Jrc2hlZXQpID0+IHtcbiAgICBjb25zdCBmaXJzdE5hbWUgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDEpO1xuICAgIGZpcnN0TmFtZS5oZWFkZXIgPSBcIkZpcnN0IE5hbWVcIjtcbiAgICBmaXJzdE5hbWUua2V5ID0gXCJmaXJzdE5hbWVcIjtcblxuICAgIGNvbnN0IGxhc3ROYW1lID0gd29ya3NoZWV0LmdldENvbHVtbigyKTtcbiAgICBsYXN0TmFtZS5oZWFkZXIgPSBcIkxhc3QgTmFtZVwiO1xuICAgIGxhc3ROYW1lLmtleSA9IFwibGFzdE5hbWVcIjtcblxuICAgIGNvbnN0IGhvdXJzV29ya2VkID0gd29ya3NoZWV0LmdldENvbHVtbigzKTtcbiAgICBob3Vyc1dvcmtlZC5oZWFkZXIgPSBcIkhvdXJzIFdvcmtlZFwiO1xuICAgIGhvdXJzV29ya2VkLmtleSA9IFwiaG91cnNXb3JrZWRcIjtcblxuICAgIGNvbnN0IGhvdXJzU2NoZWR1bGVkID0gd29ya3NoZWV0LmdldENvbHVtbig0KTtcbiAgICBob3Vyc1NjaGVkdWxlZC5oZWFkZXIgPSBcIkhvdXJzIFNjaGVkdWxlZFwiO1xuICAgIGhvdXJzU2NoZWR1bGVkLmtleSA9IFwiaG91cnNTY2hlZHVsZWRcIjtcblxuXG4gICAgY29uc3QgcGVyY2VudFdvcmtlZCA9IHdvcmtzaGVldC5nZXRDb2x1bW4oNSk7XG4gICAgcGVyY2VudFdvcmtlZC5oZWFkZXIgPSBcIlBlcmNlbnQgV29ya2VkXCI7XG4gICAgcGVyY2VudFdvcmtlZC5rZXkgPSBcInBlcmNlbnRXb3JrZWRcIjtcblxuICAgIGNvbnN0IGNoYW5nZUZyb21QcmV2aW91c1dlZWsgPSB3b3Jrc2hlZXQuZ2V0Q29sdW1uKDYpO1xuICAgIGNoYW5nZUZyb21QcmV2aW91c1dlZWsuaGVhZGVyID0gXCJDaGFuZ2UgZnJvbSBMYXN0IFdlZWtcIjtcbiAgICBjaGFuZ2VGcm9tUHJldmlvdXNXZWVrLmtleSA9IFwiY2hhbmdlRnJvbVByZXZpb3VzV2Vla1wiO1xuXG4gICAgY29uc3QgdGFBc3NpZ25lZCA9IHdvcmtzaGVldC5nZXRDb2x1bW4oNyk7XG4gICAgdGFBc3NpZ25lZC5oZWFkZXIgPSBcIlRBXCI7XG4gICAgdGFBc3NpZ25lZC5rZXkgPSBcInRhXCI7XG5cbiAgICBjb25zdCB0b3RhbFdvcmtlZCA9IHdvcmtzaGVldC5nZXRDb2x1bW4oOSk7XG4gICAgdG90YWxXb3JrZWQuaGVhZGVyID0gXCJUb3RhbCBXb3JrZWRcIjtcbiAgICB0b3RhbFdvcmtlZC5rZXkgPSBcInRvdGFsV29ya2VkXCI7XG5cbiAgICBjb25zdCB0b3RhbFNjaGVkdWxlZCA9IHdvcmtzaGVldC5nZXRDb2x1bW4oMTApO1xuICAgIHRvdGFsU2NoZWR1bGVkLmhlYWRlciA9IFwiVG90YWwgU2NoZWR1bGVkXCI7XG4gICAgdG90YWxTY2hlZHVsZWQua2V5ID0gXCJ0b3RhbFNjaGVkdWxlZFwiO1xuXG4gICAgY29uc3QgdG90YWxQZXJjZW50V29ya2VkID0gd29ya3NoZWV0LmdldENvbHVtbigxMSk7XG4gICAgdG90YWxQZXJjZW50V29ya2VkLmhlYWRlciA9IFwiUGVyY2VudCBXb3JrZWRcIjtcbiAgICB0b3RhbFBlcmNlbnRXb3JrZWQua2V5ID0gXCJ0b3RhbFBlcmNlbnRXb3JrZWRcIjtcblxuICAgIGNvbnN0IHRvdGFsUGVyY2VudENoYW5nZSA9IHdvcmtzaGVldC5nZXRDb2x1bW4oMTIpO1xuICAgIHRvdGFsUGVyY2VudENoYW5nZS5oZWFkZXIgPSBcIkNoYW5nZSBmcm9tIExhc3QgV2Vla1wiO1xuICAgIHRvdGFsUGVyY2VudENoYW5nZS5rZXkgPSBcInRvdGFsUGVyY2VudENoYW5nZVwiO1xuXG59XG5cbmNvbnN0IHBvcHVsYXRlUm93ID0gKHdvcmtCb29rRGF0YSwgY3VycmVudEludGVybkRhdGEsIHBlcmNlbnRhZ2VBY2NlcHRlZCwgcm93KSA9PiB7XG4gICAgY29uc3QgY3VyclNoZWV0ID0gd29ya0Jvb2tEYXRhLndvcmtib29rLmdldFdvcmtzaGVldCh3b3JrQm9va0RhdGEud2Vla05hbWUpO1xuXG4gICAgY29uc3QgW25vcm1hbEhvdXJzV29ya2VkLCBub3JtYWxIb3Vyc1NjaGVkdWxlZCwgcGVyY2VudGFnZURpZmZlcmVuY2VdID0gcHJvY2Vzc0hvdXJzRGF0YShyb3csIHdvcmtCb29rRGF0YS50aW1lU2hlZXQsIHdvcmtCb29rRGF0YS5jdXJyZW50V2VlaywgY3VycmVudEludGVybkRhdGEuZnVsbE5hbWUsIHdvcmtCb29rRGF0YS53ZWVrTmFtZSwgd29ya0Jvb2tEYXRhLnNpbXBsaWZpZWRTY2hlZHVsZSk7XG5cblxuICAgIGN1cnJTaGVldC5hZGRSb3coe1xuICAgICAgICBmaXJzdE5hbWU6IGN1cnJlbnRJbnRlcm5EYXRhLmZpcnN0TmFtZSxcbiAgICAgICAgbGFzdE5hbWU6IGN1cnJlbnRJbnRlcm5EYXRhLmxhc3ROYW1lLFxuICAgICAgICBob3Vyc1dvcmtlZDogbm9ybWFsSG91cnNXb3JrZWQsXG4gICAgICAgIGhvdXJzU2NoZWR1bGVkOiBub3JtYWxIb3Vyc1NjaGVkdWxlZCxcbiAgICAgICAgcGVyY2VudFdvcmtlZDogcGVyY2VudGFnZURpZmZlcmVuY2UsXG5cbiAgICB9KVxuXG4gICAgY29sb3JQZXJjZW50YWdlQ2VsbChjdXJyU2hlZXQsIHBlcmNlbnRhZ2VBY2NlcHRlZCk7XG5cbn1cblxuY29uc3QgcHJvY2Vzc0hvdXJzRGF0YSA9IChyb3csIHRpbWVTaGVldCwgY3VycmVudFdlZWssIGN1cnJlbnRJbnRlcm4sIHdlZWtOYW1lLCBzaW1wbGlmaWVkU2NoZWR1bGUpID0+IHtcbiAgICBjb25zdCBwb3RlbnRpYWxXb3JrSG91cnMgPSB0aW1lU2hlZXQuZ2V0Q2VsbChyb3csIDE1KS52YWx1ZTtcbiAgICBjb25zdCB3b3JrSG91cnMgPSBwb3RlbnRpYWxXb3JrSG91cnMgPyBwb3RlbnRpYWxXb3JrSG91cnMgOiBcIjAwOjAwXCI7XG5cbiAgICBjdXJyZW50V2Vla1tjdXJyZW50SW50ZXJuXSA9IHsgaG91cnNXb3JrZWQ6IGhvdXJzVG9EZWNpbWFsKHdvcmtIb3VycykgfTtcbiAgICBjb25zdCBkZWNpbWFsSG91cnNTY2hlZHVsZWQgPSBzaW1wbGlmaWVkU2NoZWR1bGVbd2Vla05hbWVdW2N1cnJlbnRJbnRlcm5dO1xuICAgIGNvbnN0IG5vcm1hbEhvdXJzU2NoZWR1bGVkID0gZGVjaW1hbFRvSG91cnMoZGVjaW1hbEhvdXJzU2NoZWR1bGVkKTtcblxuICAgIGNvbnN0IG5vcm1hbEhvdXJzV29ya2VkID0gd29ya0hvdXJzO1xuICAgIGNvbnN0IGRlY2ltYWxIb3Vyc1dvcmtlZCA9IGhvdXJzVG9EZWNpbWFsKG5vcm1hbEhvdXJzV29ya2VkKTtcbiAgICBjdXJyZW50V2Vlay50b3RhbCArPSBkZWNpbWFsSG91cnNXb3JrZWQ7XG4gICAgY29uc3QgcGVyY2VudGFnZURpZmZlcmVuY2UgPSAoZGVjaW1hbEhvdXJzV29ya2VkIC8gZGVjaW1hbEhvdXJzU2NoZWR1bGVkICogMTAwKS50b0ZpeGVkKDIpO1xuICAgIGN1cnJlbnRXZWVrW2N1cnJlbnRJbnRlcm5dLnBlcmNlbnRhZ2VEaWZmZXJlbmNlID0gcGVyY2VudGFnZURpZmZlcmVuY2U7XG4gICAgcmV0dXJuIFtub3JtYWxIb3Vyc1dvcmtlZCwgbm9ybWFsSG91cnNTY2hlZHVsZWQsIHBlcmNlbnRhZ2VEaWZmZXJlbmNlXTtcbn1cblxuY29uc3QgcHJvY2Vzc0NoYW5nZUZyb21QcmV2aW91c1dlZWsgPSAod29ya0Jvb2tEYXRhLCBjdXJyZW50SW50ZXJuRGF0YSkgPT4ge1xuICAgIGNvbnN0IGN1cnJXZWVrID0gd29ya0Jvb2tEYXRhLndlZWtOYW1lO1xuICAgIGNvbnN0IHByZXZXZWVrID0gZ2V0V2Vla0JlZm9yZShjdXJyV2Vlayk7XG4gICAgbGV0IHBlcmNlbnRhZ2VEaWZmZXJlbmNlT2ZQcmV2aW91c1dlZWs7XG4gICAgaWYgKHdvcmtCb29rRGF0YS5ob3Vyc1dvcmtlZE1hcFtwcmV2V2Vla10pIHtcbiAgICAgICAgY29uc29sZS5sb2coY3VycldlZWspO1xuICAgICAgICBjb25zb2xlLmxvZyh3b3JrQm9va0RhdGEuaG91cnNXb3JrZWRNYXBbY3VycldlZWtdKVxuICAgICAgICBjb25zb2xlLmxvZyhwcmV2V2Vlayk7XG4gICAgICAgIGNvbnNvbGUubG9nKHdvcmtCb29rRGF0YS5ob3Vyc1dvcmtlZE1hcFtwcmV2V2Vla10pXG4gICAgICAgIGlmKHdvcmtCb29rRGF0YS5ob3Vyc1dvcmtlZE1hcFtwcmV2V2Vla11bY3VycmVudEludGVybkRhdGEuZnVsbE5hbWVdKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaGlcIilcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwZXJjZW50YWdlRGlmZmVyZW5jZU9mQ3VycmVudFdlZWsgPSB3b3JrQm9va0RhdGEuaG91cnNXb3JrZWRNYXBbY3VycldlZWtdW2N1cnJlbnRJbnRlcm5EYXRhLmZ1bGxOYW1lXS5wZXJjZW50YWdlRGlmZmVyZW5jZTtcbiAgICBsZXQgZGlmZmVyZW5jZUZyb21XZWVrcyA9IHBlcmNlbnRhZ2VEaWZmZXJlbmNlT2ZQcmV2aW91c1dlZWsgP1xuICAgICAgICAocGVyY2VudGFnZURpZmZlcmVuY2VPZkN1cnJlbnRXZWVrIC0gcGVyY2VudGFnZURpZmZlcmVuY2VPZlByZXZpb3VzV2VlaykudG9GaXhlZCgyKSA6IFwiXCI7XG5cbiAgICByZXR1cm4gZGlmZmVyZW5jZUZyb21XZWVrcztcbn1cblxuY29uc3QgY29sb3JQZXJjZW50YWdlQ2VsbCA9IChjdXJyU2hlZXQsIHBlcmNlbnRhZ2VBY2NlcHRlZCkgPT4ge1xuICAgIGNvbnN0IGN1cnJDZWxsID0gY3VyclNoZWV0LmdldENlbGwoY3VyclNoZWV0LnJvd0NvdW50LCA1KVxuICAgIGlmIChwYXJzZUZsb2F0KGN1cnJDZWxsKSA8IHBlcmNlbnRhZ2VBY2NlcHRlZCkge1xuICAgICAgICBjdXJyQ2VsbC5maWxsID0ge1xuICAgICAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgcGF0dGVybjogJ3NvbGlkJyxcbiAgICAgICAgICAgIGZnQ29sb3I6IHsgYXJnYjogJzgwZTc2MDYwJyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwYXJzZUZsb2F0KGN1cnJDZWxsKSA+IDEwMCkge1xuICAgICAgICBjdXJyQ2VsbC5maWxsID0ge1xuICAgICAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgcGF0dGVybjogJ3NvbGlkJyxcbiAgICAgICAgICAgIGZnQ29sb3I6IHsgYXJnYjogJzgwNDJmNThkJyB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IG1ha2VUaW1lc2hlZXRBbmFseXNpczsiXSwibmFtZXMiOlsiRXhjZWxKUyIsIkZpbGVTYXZlciIsImhvdXJzVG9EZWNpbWFsIiwiZ2V0RGF0ZUZyb21TdHJpbmciLCJkZWNpbWFsVG9Ib3VycyIsImdldFdlZWtCZWZvcmUiLCJtYWtlVGltZXNoZWV0QW5hbHlzaXMiLCJ0aW1lc2hlZXRFeGNlbCIsInNpbXBsaWZpZWRTY2hlZHVsZSIsInBlcmNlbnRhZ2VBY2NlcHRlZCIsIndvcmtib29rIiwiV29ya2Jvb2siLCJob3Vyc1dvcmtlZE1hcCIsInRvdGFsIiwidGltZVNoZWV0IiwiZ2V0V29ya3NoZWV0IiwiZmlyc3ROYW1lIiwiZ2V0Q2VsbCIsInZhbHVlIiwibGFzdE5hbWUiLCJjdXJyZW50SW50ZXJuIiwicm93Iiwicm93Q291bnQiLCJ0ZW1wRmlyc3ROYW1lIiwidGVtcExhc3ROYW1lIiwid2Vla05hbWUiLCJ3ZWVrU2NoZWR1bGUiLCJzZXRVcE5ld1NoZWV0IiwiY3VycmVudFdlZWsiLCJjdXJyZW50SW50ZXJuRGF0YSIsImZ1bGxOYW1lIiwid29ya0Jvb2tEYXRhIiwicG9wdWxhdGVSb3ciLCJlYWNoU2hlZXQiLCJ3b3Jrc2hlZXQiLCJzaGVldElkIiwiY29uc29sZSIsImxvZyIsInNoZWV0IiwiYWRkV29ya3NoZWV0Iiwidmlld3MiLCJwcm9wZXJ0aWVzIiwiZGVmYXVsdENvbFdpZHRoIiwiZGVmYXVsdFJvd0hlaWdodCIsInNldFVwQ29sdW1ucyIsImdldENvbHVtbiIsImhlYWRlciIsImtleSIsImhvdXJzV29ya2VkIiwiaG91cnNTY2hlZHVsZWQiLCJwZXJjZW50V29ya2VkIiwiY2hhbmdlRnJvbVByZXZpb3VzV2VlayIsInRhQXNzaWduZWQiLCJ0b3RhbFdvcmtlZCIsInRvdGFsU2NoZWR1bGVkIiwidG90YWxQZXJjZW50V29ya2VkIiwidG90YWxQZXJjZW50Q2hhbmdlIiwiY3VyclNoZWV0Iiwibm9ybWFsSG91cnNXb3JrZWQiLCJub3JtYWxIb3Vyc1NjaGVkdWxlZCIsInBlcmNlbnRhZ2VEaWZmZXJlbmNlIiwicHJvY2Vzc0hvdXJzRGF0YSIsImFkZFJvdyIsImNvbG9yUGVyY2VudGFnZUNlbGwiLCJwb3RlbnRpYWxXb3JrSG91cnMiLCJ3b3JrSG91cnMiLCJkZWNpbWFsSG91cnNTY2hlZHVsZWQiLCJkZWNpbWFsSG91cnNXb3JrZWQiLCJ0b0ZpeGVkIiwicHJvY2Vzc0NoYW5nZUZyb21QcmV2aW91c1dlZWsiLCJjdXJyV2VlayIsInByZXZXZWVrIiwicGVyY2VudGFnZURpZmZlcmVuY2VPZlByZXZpb3VzV2VlayIsInBlcmNlbnRhZ2VEaWZmZXJlbmNlT2ZDdXJyZW50V2VlayIsImRpZmZlcmVuY2VGcm9tV2Vla3MiLCJjdXJyQ2VsbCIsInBhcnNlRmxvYXQiLCJmaWxsIiwidHlwZSIsInBhdHRlcm4iLCJmZ0NvbG9yIiwiYXJnYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/helpers/makeTimeSheetAnalysis.jsx\n"));

/***/ })

});